<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>迭代和递归</title>
      <link href="2021/08/13/%E8%BF%AD%E4%BB%A3%E5%92%8C%E9%80%92%E5%BD%92/"/>
      <url>2021/08/13/%E8%BF%AD%E4%BB%A3%E5%92%8C%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>​    重复调用函数自身实现循环称为递归。典型问题：斐波那契数列，阶乘（n!）。</p><p>​    构成递归需具备的条件：</p><ol><li>子问题需与原问题为同样的事，且更为简单。</li><li>不能无限制的调用本身，需要有出口。</li></ol><h1 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h1><p>​    迭代法是一种不断用变量的旧值递推新值的过程，典型问题：斐波那契数列，背包问题。</p><h1 id="二者关系与区别"><a href="#二者关系与区别" class="headerlink" title="二者关系与区别"></a>二者关系与区别</h1><p>​    从概念上讲，递归就是指程序调用自身的编程思想，即一个函数调用本身；迭代是利用已知的变量值，根据递推公式不断演进得到新变量值的编程思想。简单的说，递归是重复调用函数自身实现循环。迭代时函数内某段代码实现循环。</p><p>​    迭代与普通循环的区别：迭代时，循环代码中参与运算的变量同时是保存结果的变量，当前保存的结果作为下一次循环计算的初始值。</p><p>​    递归与普通循环的区别：递归是有去无回，而递归是有去有回。</p><p>​    <font color=red>迭代是顺序推导，用临时变量保存结果；递归是逆序推导，用相同函数嵌套调用。</font></p><p>​    </p><p><a href="https://blog.csdn.net/gaoyu1253401563/article/details/82384958?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control">参考链接1</a>          <a href="https://blog.csdn.net/qq_40817827/article/details/89950325">参考链接2</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 迭代 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git权限管理</title>
      <link href="2021/07/28/git%E6%9D%83%E9%99%90/"/>
      <url>2021/07/28/git%E6%9D%83%E9%99%90/</url>
      
        <content type="html"><![CDATA[<p>​    运行Ardupilot出现permission denied错误解决方案：    git config core.filemode false + chmod</p><h3 id="忽略文件权限"><a href="#忽略文件权限" class="headerlink" title="忽略文件权限"></a>忽略文件权限</h3><p>​    有很多时候我们并不需要过多关注文件权限，特别是部署时会重置文件权限的情况，在开发时由于各环境不同，总是有文件权限的冲突，此时，我们可以忽略文件变更追踪。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config core.filemode <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>可以禁止 <code>Git</code> 跟踪文件权限。</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存管理（1）</title>
      <link href="2021/07/23/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%881%EF%BC%89/"/>
      <url>2021/07/23/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="C-memory-primitives"><a href="#C-memory-primitives" class="headerlink" title="C++ memory primitives"></a>C++ memory primitives</h1><table><thead><tr><th>分配</th><th>释放</th><th>类属</th><th>可否重载</th></tr></thead><tbody><tr><td>malloc()</td><td>free()</td><td>C函数</td><td>不可</td></tr><tr><td>new</td><td>delete</td><td>C++表达式（expressions）</td><td>不可</td></tr><tr><td>::operator new()</td><td>::operator delete()</td><td>C++函数</td><td>可</td></tr><tr><td>allocator<T>:: allocate()</td><td>allocator<T>:: deallocate()</td><td>C++标准库</td><td>可自由设计并搭配任何容器</td></tr></tbody></table><p>各用法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* malloc() and free() */</span></span><br><span class="line"><span class="keyword">void</span>* p1 = <span class="built_in">malloc</span>(<span class="number">512</span>);  <span class="comment">// 分配512个bytes</span></span><br><span class="line"><span class="built_in">free</span>(p1);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* new and delete expression */</span></span><br><span class="line">complex&lt;<span class="keyword">int</span>&gt;* p2 = <span class="keyword">new</span> complex&lt;<span class="keyword">int</span>&gt;; <span class="comment">// one object;</span></span><br><span class="line"><span class="keyword">delete</span> p2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* array new, array delete */</span></span><br><span class="line">Complex* pca = <span class="keyword">new</span> Complex[<span class="number">3</span>];  <span class="comment">// 这里的Complex为自己定义的；</span></span><br><span class="line"><span class="comment">// 调用三次ctor</span></span><br><span class="line"><span class="keyword">delete</span>[] pca;  <span class="comment">// 如果不加[]会导致内存泄漏</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ::operator new() and ::operator delete() */</span></span><br><span class="line"><span class="keyword">void</span>* p3 = ::<span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span>(<span class="number">512</span>); <span class="comment">// 512 bytes</span></span><br><span class="line">::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(p3)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* allocator&lt;T&gt;:: allocate() and allocator&lt;T&gt;:: deallocate() */</span></span><br><span class="line"><span class="comment">// 以下是使用c++标准库提供的allocators</span></span><br><span class="line"><span class="comment">// 不同三家的形式如下 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _MSC_VER</span></span><br><span class="line"><span class="comment">// 以下两函数都是non-static的，需要通过object调用。以下分配3个int</span></span><br><span class="line"><span class="keyword">int</span>* p4 = allocator&lt;<span class="keyword">int</span>&gt;().<span class="built_in">allocate</span>(<span class="number">3</span>, (<span class="keyword">int</span>*)<span class="number">0</span>)； <span class="comment">// 其中(int*)0 目前无用</span></span><br><span class="line">allocator&lt;<span class="keyword">int</span>&gt;().<span class="built_in">deallocate</span>(p4, <span class="number">3</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _BORLANDC_</span></span><br><span class="line"><span class="comment">// 以下两函数都是non-static的，需要通过object调用。以下分配5个int</span></span><br><span class="line"><span class="keyword">void</span>* p4 = allocator&lt;<span class="keyword">int</span>&gt;().<span class="built_in">allocate</span>(<span class="number">5</span>);</span><br><span class="line">allocator&lt;<span class="keyword">int</span>&gt;().deallocate&lt;p4, <span class="number">5</span>&gt;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _GNUC_</span></span><br><span class="line"><span class="comment">// 此为GNUC早期版本 </span></span><br><span class="line"><span class="comment">// 以下两函数都是static的，可通过全名调用。以下分配512 bytes</span></span><br><span class="line"><span class="keyword">void</span>* p4 = alloc::<span class="built_in">allocate</span>(<span class="number">512</span>);</span><br><span class="line">alloc::<span class="built_in">deallocate</span>(p4, <span class="number">512</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _GNUC_</span></span><br><span class="line"><span class="comment">// 新版GNUC</span></span><br><span class="line"><span class="comment">// 以下两函数都是non-static的，需要通过object调用。以下分配7个int</span></span><br><span class="line"><span class="keyword">void</span>* p4 = allocator&lt;<span class="keyword">int</span>&gt;().<span class="built_in">allocate</span>(<span class="number">7</span>);</span><br><span class="line">allocator&lt;<span class="keyword">int</span>&gt;().<span class="built_in">deallocate</span>((<span class="keyword">int</span>*)p4, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下两函数都是non-static的，需要通过object调用。一下分配9个int</span></span><br><span class="line"><span class="keyword">void</span>* p5 = _gnu_cxx::_pool_alloc&lt;<span class="keyword">int</span>&gt;().<span class="built_in">allocate</span>(<span class="number">9</span>);</span><br><span class="line">_gnu_cxx::_pool_alloc&lt;<span class="keyword">int</span>&gt;().<span class="built_in">deallocate</span>((<span class="keyword">int</span>*)p5, <span class="number">9</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="array-new-和-array-delete"><a href="#array-new-和-array-delete" class="headerlink" title="array new 和 array delete"></a>array new 和 array delete</h2><p><img src="https://i.loli.net/2021/07/26/xYs3LaVISlkdFDz.png" alt="image.png"></p><p>​    其中cookie会保存申请的内存的长度等信息，如果delete不加[] 会使得只释放第一或者最后一个内存块，导致内存泄漏。</p><p>​    在使用array new的时候并不能对对象进行想要的初始化，解决方法是使用palcement new。</p><p>Eg：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">A</span>() : <span class="built_in">id</span>(<span class="number">0</span>) &#123; cout&lt;&lt;<span class="string">&quot;default ctor.this=&quot;</span>&lt;&lt;<span class="keyword">this</span>&lt;&lt;<span class="string">&quot; id:&quot;</span>&lt;&lt;id&lt;&lt;endl; &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> i) : <span class="built_in">id</span>(i) &#123; cout&lt;&lt;<span class="string">&quot;ctor.this=&quot;</span>&lt;&lt;<span class="keyword">this</span>&lt;&lt;<span class="string">&quot; id:&quot;</span>&lt;&lt;id&lt;&lt;endl; &#125;</span><br><span class="line">    ~<span class="built_in">A</span>()             &#123; cout&lt;&lt;<span class="string">&quot;dtor.this=&quot;</span>&lt;&lt;<span class="keyword">this</span>&lt;&lt;<span class="string">&quot; id:&quot;</span>&lt;&lt;id&lt;&lt;endl; &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A* buf = <span class="keyword">new</span> A[<span class="number">3</span>];  <span class="comment">// 调用三次default ctor；</span></span><br><span class="line">    A* tmp = buf;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;buf = &quot;</span>&lt;&lt;buf&lt;&lt;<span class="string">&quot; tmp = &quot;</span>&lt;&lt;tmp&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span>(tmp++)<span class="built_in">A</span>(i);  <span class="comment">// ctor 3次</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;buf = &quot;</span>&lt;&lt;buf&lt;&lt;<span class="string">&quot; tmp = &quot;</span>&lt;&lt;tmp&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span>[] buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://i.loli.net/2021/07/26/bhSITMqziPGuERa.png" alt="image.png"></p><p>​    ctor的顺序和dtor顺序正好相反。</p><h2 id="new-expression-和-delete-expression"><a href="#new-expression-和-delete-expression" class="headerlink" title="new expression 和 delete expression:"></a>new expression 和 delete expression:</h2><h3 id="new-expression"><a href="#new-expression" class="headerlink" title="new expression"></a>new expression</h3> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Complex* pc =  <span class="keyword">new</span> <span class="built_in">Complex</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>编译器将其转换为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Complex *pc;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">void</span>* mem = <span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span>(<span class="built_in"><span class="keyword">sizeof</span></span>(Complex));<span class="comment">//allocate</span></span><br><span class="line">    pc = <span class="keyword">static_cast</span>&lt;Complex*&gt;(mem);               <span class="comment">// cast</span></span><br><span class="line">    pc-&gt;Complex::<span class="built_in">Complex</span>(<span class="number">1</span>, <span class="number">2</span>);                    <span class="comment">// construct</span></span><br><span class="line">    <span class="comment">// 只有编译器可以像上一行一样直接呼叫ctor；</span></span><br><span class="line">  <span class="comment">// 我们想直接调用构造函数可使用 placement new：   new(p)Complex(1, 2);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span>(std::bad_alloc) &#123;</span><br><span class="line">    <span class="comment">// 若allocation失败就不执行 constructor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="delete-expression"><a href="#delete-expression" class="headerlink" title="delete expression"></a>delete expression</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Complex* pc = <span class="keyword">new</span> <span class="built_in">Complex</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> pc;</span><br></pre></td></tr></table></figure><p>编译器转换为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pc-&gt;~<span class="built_in">Complex</span>();        <span class="comment">// 先析构</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(pc)</span></span>;   <span class="comment">// 然后释放内存</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>右值引用</title>
      <link href="2021/07/23/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"/>
      <url>2021/07/23/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h1><p>​    右值引用是为了支持移动操作，所谓右值引用就是必须绑定到右值的引用，右值引用只能绑定到一个将要销毁的对象，把即将销毁对象的内存、值等全都 “ 拿 ” 过来。</p><p>​    右值引用只能绑定右值。</p><p>Eg：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp;rr1 = <span class="number">42</span>;  <span class="comment">// 正确，字面值是右值</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr2 = rr1; <span class="comment">// 错误，表达式rr1是左值，变量是左值，即使这个变量是右值引用类型也不行</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr3 = std::<span class="built_in">move</span>(rr1); <span class="comment">// ok  ,move 将左值显式转换成右值行是，但这就意味着调用move后，除了对rr1进行赋值或者销毁外，我们将不再使用它。</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 右值引用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++程序编译过程</title>
      <link href="2021/07/21/C++%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/"/>
      <url>2021/07/21/C++%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="C-程序的编译过程（源码如何转化成二进制）"><a href="#C-程序的编译过程（源码如何转化成二进制）" class="headerlink" title="C++程序的编译过程（源码如何转化成二进制）"></a>C++程序的编译过程（源码如何转化成二进制）</h1><h2 id="编译过程分为四个步骤：编译（编译预处理、编译、优化），汇编，链接"><a href="#编译过程分为四个步骤：编译（编译预处理、编译、优化），汇编，链接" class="headerlink" title="编译过程分为四个步骤：编译（编译预处理、编译、优化），汇编，链接"></a>编译过程分为四个步骤：编译（编译预处理、编译、优化），汇编，链接</h2><ul><li>编译预处理：处理以 # 开头的指令。</li><li>编译、优化：将源码 .cpp 文件翻译成 .s 汇编代码。</li><li>汇编：将汇编代码 .s 翻译成机器指令 .o 文件。</li><li>链接：汇编程序生成的目标文件不会立即执行，可能有源文件中的函数引用了另一个源文件中定义的符号或者调用了某个库文件中的函数。链接的目的就是将这些目标文件连接成一个整体，生成一个可执行的.exe文件。</li></ul><p><img src="https://i.loli.net/2021/07/26/OS5yPWYLGnDjk9r.png" alt="编译过程"></p><h2 id="链接分为两种：静态和动态"><a href="#链接分为两种：静态和动态" class="headerlink" title="链接分为两种：静态和动态"></a>链接分为两种：静态和动态</h2><ul><li>静态链接：代码从其所在的动态链接库中拷贝到最终的可执行程序中，在该程序被执行时，这些代码会被装入到该进程的虚拟地址空间中。</li><li>动态链接：代码被放到动态链接库或共享对象的某个目标文件中，链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息。在程序执行时，动态链接库的全部内容会被映射到运行时相应进行的虚拟地址的空间。</li></ul><h2 id="二者优缺点"><a href="#二者优缺点" class="headerlink" title="二者优缺点"></a>二者优缺点</h2><ul><li>静态链接：<strong>浪费空间</strong>，每个可执行程序都会有目标文件的一个副本，这样如果目标文件进行了更新操作，就需要重新进行编译链接生成可执行程序（<strong>更新困难</strong>）；优点就是执行的时候运行速度快，因为可执行程序具备了程序运行的所有内容。</li><li>动态链接：节省内存、更新方便，但是动态链接是在程序运行时，每次执行任务都需要进行链接，性能会有一定的损失。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 编译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C、C++和Python区别</title>
      <link href="2021/05/31/C%E3%80%81C++%E5%92%8CPython/"/>
      <url>2021/05/31/C%E3%80%81C++%E5%92%8CPython/</url>
      
        <content type="html"><![CDATA[<h1 id="C和C-区别"><a href="#C和C-区别" class="headerlink" title="C和C++区别"></a>C和C++区别</h1><ul><li>C是面向用户的编程，特点是函数；C++是面向对象的编程，特点是类。<font color=blue>（特性）</font>    </li><li>C主要应用于嵌入式开发、驱动开发和硬件直接打交道的领域；C++可以应用于应用层的开发、用户界面开发等和操作系统直接打交道的领域。<font color=blue>（应用领域 ）</font></li><li>C++继承了C的底层操作特性，增加了面向对象的机制，增加而泛型编程 、异常处理、运算符重载，还增加了命名空间，避免了命名冲突。<font color=blue>（相较于C的升级）</font>    </li></ul><h1 id="C-和-python区别"><a href="#C-和-python区别" class="headerlink" title="C++和 python区别"></a>C++和 python区别</h1>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重写和重载</title>
      <link href="2021/05/31/%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E8%BD%BD/"/>
      <url>2021/05/31/%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="C-中重载和重写（覆盖）的区别"><a href="#C-中重载和重写（覆盖）的区别" class="headerlink" title="C++中重载和重写（覆盖）的区别"></a>C++中重载和重写（覆盖）的区别</h1><ul><li>对于类中函数的重载和重写而言，重载发生在同一个类内部，重写则发生在不同的类之间，子类和父类之间。</li><li>重载的函数需要与原函数有相同的函数名、不同的参数列表，不关注函数的返回值类型；重写的函数的函数名、参数列表和返回值类型都需要与原函数相同，父类中被重写的函数需要有virtual修饰。</li><li>virtual关键字：重写的函数基类中必须有virtual关键字的修饰，重载的函数可以有virtual关键字修饰也可以没有。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 重写 </tag>
            
            <tag> 重载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>new/delete和malloc/free用法及区别</title>
      <link href="2021/05/28/new%E3%80%81delete%E5%92%8Cmalloc/"/>
      <url>2021/05/28/new%E3%80%81delete%E5%92%8Cmalloc/</url>
      
        <content type="html"><![CDATA[<h1 id="new和delete的用法"><a href="#new和delete的用法" class="headerlink" title="new和delete的用法"></a>new和delete的用法</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//开辟一个空间</span></span><br><span class="line"><span class="keyword">int</span>* p1=<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> p1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开辟多个空间</span></span><br><span class="line"><span class="keyword">int</span>*p2=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> []p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="malloc和free的用法"><a href="#malloc和free的用法" class="headerlink" title="malloc和free的用法"></a>malloc和free的用法</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//开辟一个空间</span></span><br><span class="line"><span class="keyword">int</span>* p1=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">if</span>(p1==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(p1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//开辟多个空间</span></span><br><span class="line"><span class="keyword">int</span>*p2=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)*<span class="number">4</span>);</span><br><span class="line"><span class="keyword">if</span>(p2==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="new和malloc的区别"><a href="#new和malloc的区别" class="headerlink" title="new和malloc的区别"></a>new和malloc的区别</h1><p>在使用的时候，new和delete搭配使用，malloc和free搭配使用，二者从功能上来看都是用来申请内存和回收内存的。</p><ul><li>属性：malloc/free是库函数，需要头文件的支持；new/delete是关键字，需要编译器的支持。</li><li>参数：new申请空间时，无需指定分配空间的大小，编译器会根据类型自行计算；malloc在申请空间时，需要确定所申请的空间大小。</li><li>返回值：new申请空间时，返回的类型是对象的指针类型，无需强制类型转换，故new是符合类型安全性的操作符。而malloc申请空间返回的是void*类型，需要进行强制类型转换，转化为对象类型的指针。</li><li>分配失败：new分配失败会抛出bad_alloc异常，malloc分配失败时返回空指针。</li><li>重载：new/delete是操作符，支持重载，只能在C++使用；malloc/free是函数，可以覆盖（重写），但不能重载，在C、C++都可以使用。</li><li>自定义类型实现：new首先调用operator new函数申请空间（底层通过malloc实现），然后调用构造函数进行初始化，最后返回自定义类型的指针；delete首先调用析构函数，然后调用operator delete释放空间（底层通过free实现）。malloc/free无法进行自定义类型对象的构造和析构。new分配一个对象，malloc分配一块内存。</li><li>内存区域：new操作符从自由存储区上为对象动态分配内存，malloc函数从堆上动态分配内存。（自由存储区 ≠ 堆）。</li></ul><p><a href="https://blog.csdn.net/weibo1230123/article/details/81980889">参考链接1</a></p><p><a href="https://www.cnblogs.com/maluning/p/7944231.html">参考链接2</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> new </tag>
            
            <tag> malloc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存分区模型</title>
      <link href="2021/05/21/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA%E6%A8%A1%E5%9E%8B/"/>
      <url>2021/05/21/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="内存分区模型"><a href="#内存分区模型" class="headerlink" title="内存分区模型"></a>内存分区模型</h1><p>目前网络上主要有两种内存分区方法：</p><h2 id="四区"><a href="#四区" class="headerlink" title="四区"></a>四区</h2><p>C++程序在执行时，将内存大方向分为四个区：</p><ul><li>代码区：存放函数体的二进制代码，由操作系统进行管理。<font color=blue>(共享、只读)</font></li><li>全局区：存放全局变量和静态变量以及常量。<font color=blue>（该区数据在程序结束后由操作系统释放）</font></li><li>栈区：由编译器自动分配释放，存放函数的参数值，局部变量等。<font color=blue>（注意函数不要返回局部变量的地址 ）</font></li><li>堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。<font color=blue>（可以把函数返回的地址保存住，用new来开辟内存）</font></li></ul><h2 id="五区"><a href="#五区" class="headerlink" title="五区"></a>五区</h2><p>分为五区：</p><ul><li>栈区：存放函数的局部变量，由编译器自动分配和释放。</li><li>堆区：动态申请的内存空间，由malloc分配的内存块，由程序员控制它的分配和释放，如果程序执行结束还没有释放，操作系统会自动回收。</li><li>自由存储区：和堆十分相似，存放由new分配的内存块，由delete释放内存。</li><li>全局区/静态区：存放全局变量和静态变量。</li><li>常量存储区：存放的是常量，不允许修改。</li></ul><p><strong>内存四区的意义：不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活性来编程。</strong></p><h2 id="堆和自由存储区的区别："><a href="#堆和自由存储区的区别：" class="headerlink" title="堆和自由存储区的区别："></a>堆和自由存储区的区别：</h2><ul><li>自由存储区是C++中通过new与delete动态分配和释放对象的抽象概念，而堆是C语言和操作系统的术语，是操作系统维护的一块动态分配内存。</li><li>new所申请的内存区域在C++中成为自由存储区，通过堆实现的自由存储，可以说new所申请的内存区域在堆上。</li><li>堆和自由存储区有区别，并非等价。使用new来分配内存，程序员也可以通过重载操作符，改用其他的内存来实现自由存储，例如全局变量做的对象池，这时自由存储区就区别于堆了。</li></ul><p><a href="https://www.cnblogs.com/QG-whz/p/5060894.html">参考链接</a></p><h1 id="堆和自由存储区定义："><a href="#堆和自由存储区定义：" class="headerlink" title="堆和自由存储区定义："></a>堆和自由存储区定义：</h1><blockquote><p>Free Store：<br>The free store is one of the two dynamic memory areas, allocated/freed by new/delete. Object lifetime can be less than the time the storage is allocated; that is, free store objects can have memory allocated without being immediately initialized, and can be destroyed without the memory being immediately deallocated. During the period when the storage is allocated but outside the object’s lifetime, the storage may be accessed and manipulated through a void* but none of the proto-object’s non-static members or member functions may be accessed, have their addresses taken, or be otherwise manipulated.</p></blockquote><blockquote><p>Heap：<br>The heap is the other dynamic memory area, allocated/freed by malloc/free and their variants. Note that while the default global new and delete might be implemented in terms of malloc and free by a particular compiler, the heap is not the same as free store and memory allocated in one area cannot be safely deallocated in the other. Memory allocated from the heap can be used for objects of class type by placement-new construction and explicit destruction. If so used, the notes about free store object lifetime apply similarly here.</p></blockquote><p>来源：<a href="http://www.gotw.ca/gotw/009.htm">http://www.gotw.ca/gotw/009.htm</a></p><h2 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h2><ul><li>申请方式：栈是系统自动分配的，而堆是程序员主动申请的。</li><li>申请后系统响应：分配栈空间，如果剩余空间大于申请空间则分配成功，否则分配失败栈溢出；申请堆空间，堆在内存中的呈现方式类似于链表（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序 ，将该节点从链表中删除，大多数系统会在该块空间的首地址处记录本次分配的大小，便于之后的delete语句释放内存。另外，找到的内存空间大小不一定正好等于申请空间大小，系统自动将多余部分重新放入空闲链表中。</li><li>栈在内存中是连续的一块空间（向低地址扩展）最大容量是系统预定好的，堆在内存中的空间（向高地址扩展）是不连续的。</li><li>申请效率：栈是由系统自动分配的，申请效率高但程序员无法控制；堆是由程序员主动申请的，效率低，使用起来方便但是容易产生碎片。</li><li>存放内容：栈中存放的是局部变量，函数的参数；堆中存放的内容是由程序员控制的。</li></ul><p><a href="https://blog.csdn.net/hairetz/article/details/4141043">参考链接</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 内存 </tag>
            
            <tag> 堆 </tag>
            
            <tag> 栈 </tag>
            
            <tag> 自由存储区 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>const小结</title>
      <link href="2021/05/16/const%E5%B0%8F%E7%BB%93/"/>
      <url>2021/05/16/const%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="const-分类"><a href="#const-分类" class="headerlink" title="const 分类"></a>const 分类</h1><h3 id="顶层const："><a href="#顶层const：" class="headerlink" title="顶层const："></a>顶层const：</h3><ul><li>顶层const可以表示任意的对象是常量，例如常量指针，指针本身为常量。<font color=#FF0000>顶层const作用于对象本身。</font></li></ul><h3 id="底层const："><a href="#底层const：" class="headerlink" title="底层const："></a>底层const：</h3><ul><li>底层const与指针和引用等复合类型部分有关，例如指针所指对象是常量。</li></ul><p><strong>Eg:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p1 = &amp;i;        <span class="comment">// 顶层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> c1 = <span class="number">42</span>;         <span class="comment">// 顶层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p2 = &amp;c1;       <span class="comment">// 底层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> p3 = p2; <span class="comment">// 左边底层， 右边顶层</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r = c1;         <span class="comment">// 用于声明引用的是底层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = <span class="number">42</span>;        <span class="comment">// 允许为一个常量引用绑定非常量的对象、字面值、甚至是个一般表达式</span></span><br></pre></td></tr></table></figure><h3 id="注："><a href="#注：" class="headerlink" title="注："></a><font color=red>注：</font></h3><ul><li>顶层const形参无法重载函数</li></ul><p><strong>Eg:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lookup</span><span class="params">(Phone)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Phone)</span></span>;  <span class="comment">// 等价的重复声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lookup</span><span class="params">(Phone*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lookup</span><span class="params">(Phone* <span class="keyword">const</span>)</span></span>; <span class="comment">// 等价的重复声明</span></span><br></pre></td></tr></table></figure><ul><li>底层const形参可实现函数重载</li></ul><p><strong>Eg：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lookup</span><span class="params">(Phone&amp;)</span></span>;       <span class="comment">// 作用于Phone的引用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Phone&amp;)</span></span>; <span class="comment">// 作用于Phone的常量引用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loohup</span><span class="params">(Phone*)</span></span>;       <span class="comment">// 作用于指向Phone的指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Phone*)</span></span>; <span class="comment">// 作用于指向Phone常量的指针</span></span><br></pre></td></tr></table></figure><p>当传递非常量对象或指向非常量对象的指针时，会优先选用非常量版本。</p><h1 id="const-用法"><a href="#const-用法" class="headerlink" title="const 用法"></a>const 用法</h1><ul><li><p>const修饰成员变量，定义成const常量，相较于宏常量，可进行类型检查，节省内存空间，提高了效率；const成员变量要进行初始化。</p></li><li><p>const修饰函数参数，使得传递过来的函数参数的值不能改变。</p></li><li><p>const修饰成员函数（常函数），使得成员函数不能修改任何类型的成员变量（mutable修饰的变量除外，函数参数也除外），也不能调用非const成员函数，因为非const成员函数可能会修改成员变量。</p></li><li><p>const修饰对象（常对象），只能调用常函数，不可调用普通成员函数，因为普通函数可以修改属性；同时不能对成员变量进行修改。</p></li></ul><h1 id="const注意事项"><a href="#const注意事项" class="headerlink" title="const注意事项"></a>const注意事项</h1><h2 id="const成员变量"><a href="#const成员变量" class="headerlink" title="const成员变量"></a>const成员变量</h2><ul><li><p>const成员变量只能在类内声明、定义，在构造函数初始化列表中初始化，注意在构造函数函数体内部叫赋值（经测试在声明时初始化也可，尽量不要，原因见下条）。</p></li><li><p>const成员变量只在某个对象的生存周期内是常量，对于整个类而言是可变的，因为类可以创建多个对象，不同对象的const成员变量值不同，所以不能在类的声明中初始化const成员变量，因为类的对象还没有创建，编译器不知道他的值。</p></li></ul><h2 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h2><ul><li>不能修改成员变量的值，除非有mutable修饰；只能访问成员变量。</li><li>不能调用非常量成员的函数，以防修改成员变量的值。</li></ul><h1 id="define和const的区别（编译阶段、安全性、内存占用等）"><a href="#define和const的区别（编译阶段、安全性、内存占用等）" class="headerlink" title="define和const的区别（编译阶段、安全性、内存占用等）"></a>define和const的区别（编译阶段、安全性、内存占用等）</h1><ul><li>编译阶段：define是在编译预处理阶段起作用，const是在编译阶段和程序运行阶段起作用。</li><li>安全性：define定义的宏常量没有数据类型，只是进行简单的替换，不会进行类型安全的检查；const定义的只读变量是有类型的，需要进行判断，可以避免一些低级错误。</li><li>内存占用：define定义的宏常量，在程序中使用多少次就会进行多少次替换，内存中有多个备份；const定义的只读变量在程序运行过程中只有一份。</li><li>调试：define定义的不能调试，因为在预编译阶段就进行替换了；const定义的可以进行调试。</li></ul><h1 id="const的优点"><a href="#const的优点" class="headerlink" title="const的优点"></a>const的优点</h1><ul><li>有数据类型，在定义时可进行安全性检查</li><li>可调试</li><li>占用较少的空间</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> const </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
