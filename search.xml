<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>OS小知识点</title>
      <link href="2022/03/04/OS%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>2022/03/04/OS%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="MMU（内存管理单元）"><a href="#MMU（内存管理单元）" class="headerlink" title="MMU（内存管理单元）"></a>MMU（内存管理单元）</h1><p><img src="https://s2.loli.net/2022/03/04/1L35G4UghYlkuc8.png" alt="QQ截图20220304133224.png"></p><p><img src="https://s2.loli.net/2022/03/04/Pg6hLpMdvDy9Bzu.png" alt="MMU.png"></p><p>MMU作用：</p><ul><li>虚拟内存与物理内存映射。</li><li>设置修改内存访问级别。</li></ul>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++面试知识点</title>
      <link href="2022/02/27/C++%E9%9D%A2%E7%BB%8F%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>2022/02/27/C++%E9%9D%A2%E7%BB%8F%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h1><ul><li>指针所指向的内存空间在程序运行过程中可以改变，而引用所绑定的对象一旦绑定就不能改变（是否可变）。</li><li>指针本身在内存中占有内存空间，引用相当于变量别名，而在内存中不占内存空间（是否占内存）。</li><li>指针可以为空，但是引用必须绑定对象（是否可空）。</li><li>指针可以有多级，但是引用只能一级（是否能多级）。</li></ul><h1 id="sizeof和strlen区别"><a href="#sizeof和strlen区别" class="headerlink" title="sizeof和strlen区别"></a>sizeof和strlen区别</h1><ul><li><p>strlen 是函数，sizeof 是运算符。</p></li><li><p>strlen 测量的是字符的实际长度，以’\0’ 结束（不包含’\0’ ）。而sizeof 测量的是字符的分配大小，如果未分配大小，则遇到’\0’ 结束（包含’\0’ ，也就是strlen测量的长度加1），如果已经分配内存大小，返回的就是分配的内存大小。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[] = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> str1[<span class="number">100</span>] = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"> </span><br><span class="line">cout &lt;&lt; <span class="built_in">strlen</span>(str) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(str) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(str1) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190929145538553.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>适配器</title>
      <link href="2022/02/25/%E9%80%82%E9%85%8D%E5%99%A8/"/>
      <url>2022/02/25/%E9%80%82%E9%85%8D%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h1><h2 id="函数适配器"><a href="#函数适配器" class="headerlink" title="函数适配器"></a>函数适配器</h2><p><strong>一元转二元：</strong></p><ul><li>bind2nd 绑定第二个参数。</li><li>继承binary_function&lt;参数类型1, 参数类型2, 返回值类型&gt;。</li><li>const修饰operator()。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrint</span>:</span> <span class="keyword">public</span> binary_fuction&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">void</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> start)</span>  <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; num+start &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; a&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    cin&lt;&lt;start;</span><br><span class="line">    for_each(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">MyPront</span>(), start));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="取反适配器"><a href="#取反适配器" class="headerlink" title="取反适配器"></a>取反适配器</h2><p>一元取反：</p><ul><li>not1()。</li><li>继承unary_function&lt;参数类型1,  返回值类型 &gt;。</li><li>const修饰。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreaterFive</span>:</span> <span class="keyword">public</span> unary_function&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt; <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 一元取反</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">not1</span>(<span class="built_in">GreatrerFive</span>()));  <span class="comment">//  找不大于5的 返回0。</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数指针适配器"><a href="#函数指针适配器" class="headerlink" title="函数指针适配器"></a>函数指针适配器</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyPrint03</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; v+ start &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tets03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">ptr_fun</span>(<span class="built_in">MyPrint03</span>()), <span class="number">100</span>)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="成员函数适配器"><a href="#成员函数适配器" class="headerlink" title="成员函数适配器"></a>成员函数适配器</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">int</span> age) : <span class="built_in">mAge</span>(age) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; mAge &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;Person&gt; p;</span><br><span class="line">    p.<span class="built_in">push_back</span>(<span class="built_in">Person</span>(<span class="number">1</span>));</span><br><span class="line">    p.<span class="built_in">push_back</span>(<span class="built_in">Person</span>(<span class="number">2</span>));</span><br><span class="line">    p.<span class="built_in">push_back</span>(<span class="built_in">Person</span>(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    for_each(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>(), <span class="built_in">mem_fun_ref</span>(&amp;Person::showAge));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 适配器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>仿函数、谓词和lambda表达式</title>
      <link href="2022/02/25/%E4%BB%BF%E5%87%BD%E6%95%B0%E3%80%81%E8%B0%93%E8%AF%8D%E5%92%8Clambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>2022/02/25/%E4%BB%BF%E5%87%BD%E6%95%B0%E3%80%81%E8%B0%93%E8%AF%8D%E5%92%8Clambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="函数对象（仿函数）"><a href="#函数对象（仿函数）" class="headerlink" title="函数对象（仿函数）"></a>函数对象（仿函数）</h1><p>​        重载函数调用操作符的类，其对象称为函数对象，即其行为类似函数的对象，又称为仿函数。重载了“（）”使其可以向函数一样调用。</p><p><strong>注意 ：</strong></p><ul><li>函数对象（仿函数）是一个类，不是一个函数。</li><li>函数对象（仿函数）重载了“（）”使其可以向函数一样调用。</li></ul><p><strong>分类：</strong></p><ul><li>一元仿函数：一个参数。</li><li>二元仿函数：两个参数。</li></ul><h1 id="内建仿函数"><a href="#内建仿函数" class="headerlink" title="内建仿函数"></a>内建仿函数</h1><ul><li>头文件：<code>#include&lt;functional&gt;</code></li><li>取反仿函数：<code>template&lt;class T&gt; T negate&lt;T&gt;</code></li><li>加法仿函数：<code>template&lt;class T&gt; T plus&lt;T&gt;</code> </li><li>大于仿函数：<code>template&lt;class T&gt; bool greater&lt;T&gt;</code></li><li>小于仿函数：<code>template&lt;class T&gt; bool less&lt;T&gt;</code></li><li>….</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">negate&lt;<span class="keyword">int</span>&gt; n;</span><br><span class="line">cout &lt;&lt; <span class="built_in">n</span>(<span class="number">10</span>) &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    plus&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">plus</span>(<span class="number">1</span>,<span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; a &#123;<span class="number">1</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());  <span class="comment">// 7 7 6 4 3 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h1><p>​        谓词就是一个判断式，是一个返回bool类型的函数，或者也可以是函数对象（仿函数）。一个参数是一元谓词，两个参数是二元谓词。</p><h1 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h1><ul><li>写法：<code>[](参数列表) &#123; 函数内容 &#125;</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 仿函数 </tag>
            
            <tag> 谓词 </tag>
            
            <tag> lambda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础知识点</title>
      <link href="2022/02/24/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>2022/02/24/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><table><thead><tr><th>命令</th><th>执行操作</th></tr></thead><tbody><tr><td>history</td><td>查看历史命令</td></tr><tr><td>ls</td><td>查看文件目录    -l 显示详细信息    -a 显示隐藏目录    -R递归显示子目录信息</td></tr><tr><td>cd</td><td>更改目录</td></tr><tr><td>pwd</td><td>查看当前的工作目录</td></tr><tr><td>mkdir</td><td>创建目录</td></tr><tr><td>tree</td><td>目录成树状显示</td></tr><tr><td>rmdir</td><td>删除目录，只能删非空目录</td></tr><tr><td>which</td><td>显示对应命令所在的路径</td></tr><tr><td>touch</td><td>创建文件，如果不存在创建，如果存在则只更改访问时间</td></tr><tr><td>rm</td><td>删除文件或者目录  -r 递归删除子目录    rm -rf * 强制删除目录下所有内容</td></tr><tr><td>cp</td><td>拷贝文件或者目录</td></tr><tr><td>mv</td><td>移动文件或者目录</td></tr><tr><td>cat</td><td>直接显示文件信息</td></tr><tr><td>more和less</td><td>分屏显示文件信息</td></tr><tr><td>head</td><td>head -n file 显示文件头n行，不加-n默认10行</td></tr><tr><td>tail</td><td>tail -n file 显示文件后n行；tail -f file 查看文件尾部内容，不退出，用于追踪日志</td></tr><tr><td>du</td><td>-h 查看文件占用空间</td></tr><tr><td>ln</td><td>建立硬连接   ln hello hello.hard1   见下图 ；  ln -s hello hello.hard3  建立软连接</td></tr><tr><td>unlink</td><td>删除软硬连接</td></tr><tr><td>chmod</td><td>改变文件权限</td></tr><tr><td>chown</td><td>改变文件所属权限  sudo chown   用户：组  文件名|目录</td></tr><tr><td>find</td><td>find dir [opt] 内容     opt：-name  -type  -size        按名字、类型、大小找文件</td></tr><tr><td>grep</td><td>过滤信息</td></tr><tr><td>xargs</td><td>将前一目录的输出分成小块输入给后面的命令</td></tr><tr><td>zip</td><td>zip -r zipname.zip filename1 filename2 …   压缩文件  -r递归子目录</td></tr><tr><td>unzip</td><td>unzip zipname.zip  解压文件</td></tr><tr><td>tar</td><td>tar zcvf zipname.tar.gz filename1 filename2 …  压缩文件 <br />tar zxvf zipname.tar.gz  解压文件</td></tr><tr><td>rar</td><td>rar a -r rarname（可以无后缀） filename1 filename2 …  压缩文件<br />rar x rarname.rar 解压文件</td></tr><tr><td>ps</td><td>ps aux 查看进程信息<br />ps ajk  也是查看进程信息，可以追溯进程之间的血缘关系</td></tr><tr><td>kill</td><td>给进程发送一个信号<br /> kill -9 pid  杀死进程</td></tr></tbody></table><h1 id="小知识点"><a href="#小知识点" class="headerlink" title="小知识点"></a>小知识点</h1><p><strong>通配符*和？：</strong>* 代表任意多个字符，? 代表任意一个字符。</p><p><strong>相对路径和绝对路径：</strong> 以”/“开头为绝对路径，否则为相对路径。 </p><p><font color=red>linux一切皆文件。</font></p><p><strong>文件权限表示法：</strong></p><p><img src="https://s2.loli.net/2022/02/26/aCGT69pZHrv8cnO.png" alt="image.png"></p><p><strong>硬连接：</strong></p><ul><li>文件指向同一块磁盘块，只要有一个文件内容变了，建立连接的文件也跟着变。</li></ul><p><strong>软连接：</strong></p><ul><li>相当于创建快捷方式。</li></ul><p><img src="https://s2.loli.net/2022/02/26/dSngu69ODZKw2Vp.png" alt="image.png"></p><p><strong>类unix系统目录结构：</strong></p><p><img src="https://s2.loli.net/2022/02/26/NRCgm4r6dMULqFb.png" alt="image.png"></p><p><strong>进程的虚拟地址空间</strong></p><p><img src="https://s2.loli.net/2022/03/03/yKps2PtraMoSBZG.png" alt="QQ截图20220303111420.png"></p><h1 id="GCC流程"><a href="#GCC流程" class="headerlink" title="GCC流程"></a>GCC流程</h1><ul><li><strong>示例代码</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="keyword">int</span> main（<span class="keyword">void</span>） &#123;</span><br><span class="line"><span class="built_in">printf</span>（<span class="string">&quot;hello\n&quot;</span>）;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>预编译过程</strong></li></ul><p>这个过程处理宏定义和include，去除注释，不会对语法进行检查。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E a.c -o a.i</span><br></pre></td></tr></table></figure><ul><li><strong>编译过程</strong></li></ul><p>这个阶段，检查语法，生成汇编代码。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S a.i -o a.s</span><br></pre></td></tr></table></figure><ul><li><strong>汇编过程</strong></li></ul><p>这个阶段，生成目标代码。</p><p>此过程生成ELF格式的目标代码。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c a.s -o a.o</span><br></pre></td></tr></table></figure><ul><li><strong>链接过程</strong></li></ul><p>链接过程。生成可执行代码。链接分为两种，一种是静态链接，另外一种是动态链接。使用静态链接的好处是，依赖的动态链接库较少，对动态链接库的版本不会很敏感，具有较好的兼容性；缺点是生成的程序比较大。使用动态链接的好处是，生成的程序比较小，占用较少的内存。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc a.o -o a</span><br><span class="line">./a</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200607142556997.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcxODc5NA==,size_16,color_FFFFFF,t_70" alt="image.png"></p><p><strong>动态库和静态库制作流程：</strong><a href="https://blog.csdn.net/weixin_44718794/article/details/106599417">https://blog.csdn.net/weixin_44718794/article/details/106599417</a></p><h1 id="Makefile文件编写"><a href="#Makefile文件编写" class="headerlink" title="Makefile文件编写"></a>Makefile文件编写</h1><ul><li><p>命名规则：makefile  Makefile</p></li><li><p>写法：</p><ul><li>目标：依赖</li><li>Tab键 规则命令</li></ul></li><li><p>Eg（第一版 ）：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">app:main.c add.c sub.c div.c mul.c</span></span><br><span class="line">gcc -o app -I ./<span class="keyword">include</span> main.c add.c sub.c div.c mul.c</span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line"><span class="comment"># make -f makefilename 可以指定具体的makefile文件</span></span><br></pre></td></tr></table></figure><p>如果更改其中一个，所有源码都重新编译。</p><p>Eg（第二版 ）：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># objFlies 定义的目标文件</span></span><br><span class="line">objFiles=main.o add.o sub.o div.o mul.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标文件用法 $（var）</span></span><br><span class="line"><span class="section">app:<span class="variable">$(objFiles)</span></span></span><br><span class="line">gcc -o app -I ./<span class="keyword">include</span> main.o add.o sub.o div.o mul.o</span><br><span class="line"></span><br><span class="line"><span class="section">main.o:main.c</span></span><br><span class="line">gcc -c main.c -I./<span class="keyword">include</span></span><br><span class="line"><span class="section">add.o:add.c</span></span><br><span class="line">gcc -c add.c -I./<span class="keyword">include</span></span><br><span class="line"><span class="section">sub.o:sub.c</span></span><br><span class="line">gcc -c sub.c -I./<span class="keyword">include</span></span><br><span class="line"><span class="section">div.o:div.c</span></span><br><span class="line">gcc -c div.c -I./<span class="keyword">include</span></span><br><span class="line"><span class="section">mul.o:mul.c</span></span><br><span class="line">gcc -c mul.c -I./<span class="keyword">include</span></span><br></pre></td></tr></table></figure><p>makefile隐含规则：默认处理第一个目标。</p><p>Eg（第三版 ）：</p><ul><li>函数：<ul><li>wildcard 进行文件匹配。</li><li>patsubst 内容替换。</li></ul></li><li>makefile变量：<ul><li>$@ 代表目标。</li><li>$^ 代表全部依赖。</li><li>$&lt; 代表第一个依赖。</li><li>$? 代表第一个变化的依赖 。</li></ul></li><li>@在规则前代表不输出该条规则的命令。</li><li>-在规则前代表该条规则报错，仍然继续执行。</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">SecFiles =<span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line"></span><br><span class="line">objFiles=<span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,<span class="variable">$(SrcFiles)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标文件用法 $（var）</span></span><br><span class="line"><span class="section">app:<span class="variable">$(objFiles)</span></span></span><br><span class="line">gcc -o app -I ./<span class="keyword">include</span> <span class="variable">$(objFiles)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># $@,$&lt;只能在规则中出现</span></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">gcc -c <span class="variable">$&lt;</span> -I ./<span class="keyword">include</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义伪目标，防止有歧义</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:clean all</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm *.o</span><br><span class="line">rm app</span><br></pre></td></tr></table></figure></li></ul><h1 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h1><ul><li>启动gdb:<code>gdb app</code>app为对应程序名。</li><li>在gdb启动程序：<ul><li><code>r(un)</code> 启动。</li><li><code>start</code> 启动-停留在 main函数，分步调试。</li><li><code>n(ext)</code> 下一条指令。</li><li><code>s(tep)</code> 下一条指令，可以进入函数内部，库函数不能进。</li><li><code>q(uit)</code> 退出。</li><li><code>b(reak)</code> n 在主函数所在文件 第n行设置断点， <code>b func</code> 在func函数设置断点， <code>b main.cpp:2=10</code> 在某个文件某一行设置断点；<code>b main.cpp:2=10 if i==0</code>设置条件断点。</li><li><code>l(ist)</code> 查看主函数对应文件，<code>list func.cpp:1</code>看func从第一行 。</li><li><code>info b</code> 查看断点。</li><li><code>d(el)  n</code> 删除断点，n对应info b里的第几个 断点。</li><li><code>c(ontinue)</code> 跳到下一断点。</li><li><code>p(rint) context </code>打印context的内容。</li><li><code>ptype x</code>  打印x类型。</li><li><code>set</code> 设置变量值。</li><li><code>display argc</code> 执行任何一个指令argc的值都显示一下。</li><li><code>undisplay n</code>不显示display，n代表display的那个行号，也可以通过info display查看。</li></ul></li><li>gdb追踪core<ul><li>查看core文件大小 ：<code>ulimit -c</code></li><li>设置生成core文件大小：<code>ulimit -c unlimited</code> 设置无限大</li><li>gdb app core<ul><li>where 查看错误在哪。</li></ul></li></ul></li></ul><h1 id="umask"><a href="#umask" class="headerlink" title="umask"></a>umask</h1><ul><li>设置文件没有的权限。</li><li>用户默认创建文件的最高权限为666。</li><li>用户默认创建目录的最高权限为777。</li></ul><h1 id="Linux库函数"><a href="#Linux库函数" class="headerlink" title="Linux库函数"></a>Linux库函数</h1><p><strong>open：</strong></p><ul><li>查看 man 2 open</li><li><code>int open(const char *pathname, int flags);</code></li><li><code>int open(const char *pathname, int flags, mode_t mode);</code><ul><li>pathname 文件名</li><li>flags<ul><li>必选项<ul><li>O_RDONLY  只读。</li><li>O_WRONLY 只写。</li><li>O_RWR         读写。</li></ul></li><li>可选项<ul><li>O_APPEND 追加。</li><li>O_CREAT    创建文件。<ul><li>O_EXCL 与 O_CREAT 如果文件存在报错。</li><li>创建的文件权限是（mode&amp;~umask）。</li></ul></li><li>O_NONBLOCK  非阻塞。</li></ul></li></ul></li></ul></li><li>返回值：返回一个新的文件描述符，返回的是当前最小可用的文件描述符。失败返回-1，设置errno。</li><li>注意：在打开fifo文件时read端会阻塞等待write端open，write端同理，也会阻塞的能带另一端打开。</li></ul><p><strong>close</strong>：</p><ul><li><code>int close(int fd);</code> 关闭文件描述符。</li><li>返回值：成功返回0，失败返回-1。</li></ul><p><strong>read：</strong></p><ul><li><code> ssize_t read(int fd, void *buf, size_t count);</code></li><li>fd          文件描述符</li><li>buf        缓冲区</li><li>count    缓冲区大小</li><li>返回值：<ul><li>失败返回-1，设置errno。</li><li>成功返回读的大小。</li><li>0代表读到文件末尾。</li><li>非阻塞的情况下，read返回-1，但是此时需要判断errno的值。</li></ul></li></ul><p><strong>write：</strong></p><ul><li><code>ssize_t write(int fd, const void *buf, size_t count);</code></li><li>fd          文件描述符</li><li>buf        缓冲区</li><li>count    缓冲区大小</li><li>返回值：失败返回-1，设置errno；成功返回写入的字节数；0代表未写入。 </li></ul><p><strong>lseek:</strong></p><ul><li><p><code>off_t lseek(int fd, off_t offset, int whence);</code></p></li><li><p>fd 文件描述符</p></li><li><p>offset 偏移量 设0</p></li><li><p>whence </p><ul><li>SEEK_SET  文件开始位置    </li><li>SEEK_CUR 当前位置</li><li>SEEK_END 结尾</li></ul></li><li><p>返回值：成功返回当前位置到开始的长度；失败返回-1，设置errno。</p></li><li><p>函数作用：</p><ul><li>移动文件读写位置。</li><li>计算文件大小。</li><li>拓展文件。</li></ul></li></ul><p><strong>阻塞的概念：</strong></p><ul><li>read函数在读设备或者读管道或者读网络的时候。</li></ul><p><strong>fcntl：</strong></p><ul><li><p><code>int fcntl(int fd, int cmd, ... /* arg */ );</code></p></li><li><pre><code class="c++">int fd = open(&quot;/dev/tty&quot;, O_RDWR)// 设置非阻塞int flags = fcntl(fd, F_GETFL);flags |= O_NONBLOCK;fcntl(fd, F_SETFL, flags);</code></pre></li></ul><p><strong>stat:</strong></p><ul><li><p><code>int stat(const char *pathname, struct stat *statbuf);</code>获得文件信息。</p></li><li><p>函数参数</p><ul><li>pathname 文件名。</li><li>statbuf       传出参数。</li></ul></li><li><p>返回值：成功返回0，失败返回-1，设置errno。</p></li><li><p>lstat和stat：stat会穿透到源文件，lstat不会。</p></li></ul><p><strong>access：</strong></p><ul><li>判断文件权限和文件是否存在。具体用法百度。</li></ul><p><strong>truncate：</strong></p><ul><li>截断文件。用法百度。</li></ul><p><strong>link系列函数：</strong></p><ul><li>创建删除软硬连接，读取连接。用法百度。</li></ul><p><strong>rename：</strong></p><ul><li>重命名函数。</li></ul><p><strong>getcwd：</strong></p><ul><li>获取当前工作路径。</li></ul><p><strong>chdir：</strong></p><ul><li>改变进程工作路径。</li></ul><p><strong>mkdir、rmdir、opendir、readdir、closedir：</strong></p><ul><li>创建删除打开读关闭 dir。</li></ul><p><strong>dup2和dup:</strong></p><ul><li>主要用于重定向。</li><li><code>int dup2(int oldfd, int newfd);</code><ul><li>把newfd指向oldfd。</li><li>成功返回newfd，失败返回-1，设置errno。</li></ul></li><li><code>int dup(int oldfd);</code><ul><li>新生成一个fd指向oldfd，新生成的fd是当前可用最小的。</li><li>返回值为新的fd。</li></ul></li></ul><p><strong>execl和execlp：</strong></p><ul><li><code>int execl(const char *path, const char *arg, .../* (char  *) NULL */);</code><ul><li>执行其他程序，需要加路径。</li><li>Eg：<code>execl(&quot;./bin/ls&quot;, &quot;ls&quot;, &quot;-l&quot;, NULL);</code></li></ul></li><li><code>int execlp(const char *file, const char *arg, .../* (char  *) NULL */);</code><ul><li>执行程序，使用当前PATH环境变量，可以不用加路径。</li><li>Eg：<code>execl(&quot;ls&quot;, &quot;ls&quot;, &quot;-l&quot;, NULL);</code></li></ul></li><li>path/file 为要执行的程序。</li><li>arg参数列表<ul><li>列表最后要一个NULL结尾。</li></ul></li><li>返回值：只有失败才返回。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> GCC </tag>
            
            <tag> makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++STL</title>
      <link href="2022/02/23/STL/"/>
      <url>2022/02/23/STL/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>​        STL广义上分为：容器（container）、算法（algorithm）、迭代器（iterator）。容器和算法通过迭代器进行无缝连接。</p><p>​        STL细分为六大组件：容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器。</p><ul><li>容器：各种数据结构，如vector、list、deque、set、map等，用来存放数据。从实现角度看，STL容器是一种class template。</li><li>算法：各种常用算法，如sort、find、copy、for_each。从实现角度看，STL算法是一种function template。</li><li>迭代器：扮演了容器和算法之间的调和剂，共5种类型（输入、输出、前向、双向、随机访问）。从实现角度看，迭代器是一种将operator*，operator-&gt;，operator++，operator–等指针相关操作予以重载的class template，所有的STL容器都有自己的专属迭代器。原生指针（native pointer）也是一种迭代器。</li><li>仿函数：行为类似函数，可作为算法的某种策略。从实现角度看，仿函数是一种重载了operator()的class或者class template。</li><li>适配器：一种用来修饰容器或者仿函数迭代器接口的东西。</li><li>空间配置器：负责空间的配置与管理。从实现角度看，配置器是一个实现了动态空间配置、空间管理、空间释放的class template。</li></ul><p>​        STL六大组件的交互关系：容器通过空间配置器取得数据存储空间，算法通过迭代器存储容器中的内容，仿函数可以协助算法完成不同策略得变化，适配器可以修饰仿函数。</p><h1 id="STL优点"><a href="#STL优点" class="headerlink" title="STL优点"></a>STL优点</h1><ul><li>STL为C++一部分，不用额外安装。</li><li>STL一个重要特性是将数据和操作分离，数据由容器类别加以管理，操作则由可定制的算法定义。迭代器在两者之间充当“粘合剂”，以使算法可以和容器交互运作。</li><li>程序员不用考虑STL内部实现，直接使用。</li><li>STL具有高可重用性，高性能，高移植性，跨平台的优点。<ul><li>高可重用性：STL几乎所有代码都采用模板类和模板函实现，相比于传统的函数和类提供了更好的代码重用机会。</li><li>高性能：如map可以高效从大量数据在检索指定记录，因为采用红黑树。</li><li>高移植性：如在项目A使用STL编写模块，可以直接移植到项目B。</li></ul></li></ul><h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><ul><li>序列式容器：强调值的顺序，每个元素均有固定位置，除非用插入删除操作改变，如vector、deque、list等。</li><li>关联式容器：非线性的二叉树结构，个元素间没有严格的物理上得顺序关系，也就是说元素在容器中并没有保存元素置入容器时的逻辑顺序。关联式容器一个显著特点：在值中选择一个值作为关键字key，key起到索引的作用，方便查找。如set、multiset、map、multimap等。 </li></ul><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><ul><li>质变算法：运算过程中改变区间内元素内容。如拷贝，替换，删除等。</li><li>非质变算法：运算过程中不改变区间内元素内容。如查找，计数，遍历等。</li></ul><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>​        提供一种方法，使之能够依序遍历某个容器所含的各个元素，而又无需暴露该容器内部的表示方式。</p><table><thead><tr><th>名称</th><th>功能</th><th>支持操作</th></tr></thead><tbody><tr><td>输入迭代器</td><td>提供对数据的只读访问</td><td>只读，支持++，–，!=</td></tr><tr><td>输出迭代器</td><td>提供对数据的只写访问</td><td>只写，支持++</td></tr><tr><td>前向迭代器</td><td>提供读写操作，并向前推进迭代器</td><td>读写，支持++，==，!=</td></tr><tr><td>双向迭代器</td><td>提供读写操作，并能向前和向后操作</td><td>读写，支持++,–，==，!=</td></tr><tr><td>随机访问迭代器</td><td>提供读写操作，并能以跳跃的方式访问容器的任意数据，功能最强。</td><td>读写，支持++，–，[n]，-n，&lt;，&lt;=，&gt;，&gt;=, ==，!=</td></tr></tbody></table><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><ul><li>s[]访问和s.at()访问区别：[]访问越界会直接挂掉，at则抛出异常。</li><li>string -&gt; const char* :   <code>const char *p = s.c_str();</code> 。</li><li>const char* -&gt; string：<code>string s2(p);</code>。</li><li>C++存在const char*到string的隐式类型转换，不存在从string到const char*的隐式类型转换。</li></ul><h1 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h1><ul><li><p>vector所谓的动态增加大小，并不是在原有空间之后虚接新空间，而是找一块更大空间，将原数据拷贝，然后释放原空间。所以一旦引起空间配置，则原有的迭代器失效。</p></li><li><p>利用swap收缩空间：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;    <span class="comment">// &gt;10000</span></span><br><span class="line">    cout &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// = 10000</span></span><br><span class="line">    </span><br><span class="line">    v.<span class="built_in">resize</span>(<span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;    <span class="comment">// &gt;10000  和之前一样</span></span><br><span class="line">    cout &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// = 3</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 巧用swap</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;(v).<span class="built_in">swap</span>(v);<span class="comment">// v初始化匿名对象，交换两个指针，然后释放掉匿名对象（那个大的就被释放了）</span></span><br><span class="line">    cout &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;    <span class="comment">// = 3  </span></span><br><span class="line">    cout &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// = 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>reserve(int len);</code>容器预留len个元素长度，预留位置不初始化，元素不可访问。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(p != &amp;v[<span class="number">0</span>]) &#123;  <span class="comment">// 查看开辟10万个数据重新开辟多少次空间。</span></span><br><span class="line">            p = &amp;v[<span class="number">0</span>];</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; num &lt;&lt; endl; <span class="comment">// &gt;1,好多次</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 改进：</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    v1.<span class="built_in">reserve</span>(<span class="number">100000</span>);</span><br><span class="line">    <span class="keyword">int</span> *p1 = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(p1 != &amp;v[<span class="number">0</span>]) &#123;  <span class="comment">// 查看开辟10万个数据重新开辟多少次空间。</span></span><br><span class="line">            p1 = &amp;v[<span class="number">0</span>];</span><br><span class="line">            num1++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; num1 &lt;&lt; endl; <span class="comment">//  = 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>s[]访问和s.at()访问区别：[]访问越界会直接挂掉，at则抛出异常。</p></li></ul><h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><ul><li>没有迭代器，不提供遍历功能。</li></ul><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><ul><li><p>双向循环链表。</p></li><li><p>不支持随机访问。</p></li><li><p>所有不支持随机访问的迭代器，不可以用系统提供的算法，但是这个类内部会提供。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="keyword">int</span>&gt; L&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(L.<span class="built_in">begin</span>(), L.<span class="built_in">end</span>());  <span class="comment">// 报错</span></span><br><span class="line">L.<span class="built_in">sort</span>();</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程和线程</title>
      <link href="2022/02/22/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%EF%BC%88%EF%BC%89/"/>
      <url>2022/02/22/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%EF%BC%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>​        进程是操作系统中最重要的抽象概念之一，是资源分配的基本单位，是独立运行的基本单位。</p><p>​        进程的经典定义就是一个执行中程序的实例。系统中的每个程序（程序就是编译好的二进制文件）都运行在某个进程的上下文（context）中。上下文是由程序正确运行所需的状态组成。这个状态包括存放在内存中的程序代码和数据，他的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。</p><p>进程一般由以下部分组成：</p><ul><li>进程控制块PCB，是进程存在的唯一标志，包含进程标识符PID、进程当前状态、程序、数据地址、进程优先级、CPU现场保护区（用于进程切换）、占有的资源清单等等。</li><li>程序段。</li><li>数据段。</li></ul><h2 id="进程和程序"><a href="#进程和程序" class="headerlink" title="进程和程序"></a>进程和程序</h2><ul><li>程序是编译好的二进制文件。</li><li>进程是运行着的程序。从程序员角度，进程是运行一系列指令的过程。从操作系统角度，进程是资源分配的基本单位，是独立运行的基本单位。</li><li>区别：<ul><li>程序占用磁盘，不占用系统资源。</li><li>进程占用内存，占用系统资源。</li><li>一个程序可以对应多个进程，一个进程只能对应一个程序。</li><li>程序没有生命周期，进程有。</li></ul></li></ul><h2 id="简述进程间通信方法"><a href="#简述进程间通信方法" class="headerlink" title="简述进程间通信方法"></a>简述进程间通信方法</h2><p>​        每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程A把数据从用户空间拷到内核缓冲区，进程B再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信。</p><p>​        不同进程间的通信本质：进程之间可以看到一份公共资源；而提供这份资源的形式或者提供者不同，造成了通信方式的不同。</p><p>​        进程间通信主要包括管道、系统IPC（包括消息队列、信号量、信号、共享内存等）以及套接字socket。</p><h2 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h2><ul><li>IPC：Inter Process Communication进程间通信，通过内核提供的缓冲区进行数据交换的机制。</li><li>常见通信方式：单工（广播），半双工（对讲机），全双工（打电话）。</li><li>IPC通信方式：<ul><li>pipe             管道–只支持有血缘关系的进程间通信，半双工通信。</li><li>fifo               有名管道–不同进程间也可以通信。</li><li>mmap          文件映射（共享）IO–速度最快。</li><li>本地socket  最稳定。</li><li>信号              携带信息量最小。</li><li>共享内存    </li><li>消息队列</li></ul></li></ul><h2 id="进程的状态与状态转换"><a href="#进程的状态与状态转换" class="headerlink" title="进程的状态与状态转换"></a>进程的状态与状态转换</h2><p>进程在运行时有三种基本状态：就绪态、运行态和阻塞态。（五态模型还有新建态和终止态）。</p><ul><li>运行态：进程占有处理器正在运行的状态。进程已获得CPU，其程序正在执行。在单处理机系统中，只有一个进程处于执行状态；在多处理机系统中，则有多个进程处于执行状态。</li><li>就绪态：进程具备运行条件，等待系统分配处理器以便运行的状态。当进程已分配到除CPU以外的所有必要资源后，只要再获得CPU，便可立即执行，进程这时的状态称为就绪态。在一个系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列。</li><li>阻塞态：又称为等待态或睡眠态，指进程不具备运行条件，正在等待某个时间完成的状态。</li></ul><p>各状态之间的转换：</p><p><img src="https://images2015.cnblogs.com/blog/1093890/201701/1093890-20170129214630706-1507620973.png" alt="进程状态转换"></p><ul><li>就绪→执行：处于就绪状态的进程，当进程调度程序为之分配了处理机后，该进程便由就绪状态转变成运行状态。</li><li>执行→就绪：处于运行态程序在执行过程中，因分配给他的一个时间片用完而不得不让出CPU，遇是进程从运行态转变成就绪态。</li><li>执行→阻塞：正在执行的进程因等待某种事件发生而无法继续执行时，便从执行状态变成阻塞态。</li><li>阻塞→就绪：处于阻塞态的进程，若等待的事件已经发生，于是进程由阻塞状态转变为就绪态。</li></ul><h2 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h2><p>​        管道是一种最基本的IPC机制，作用域有血缘关系的进程之间，完成数据传递。调用pipe系统函数即可创建一个管道，有如下特质：</p><ul><li>其本质是一个伪文件（实为一个内核缓冲区）。</li><li>有两个文件描述符引用，一个表示读端，一个表示写端，</li><li>规定数据从管道的写端流入管道，从读端流出。</li></ul><p><strong>管道原理：</strong>管道实为内核使用环形队列机制，借助内核缓冲区实现。</p><p><strong>管道局限性：</strong></p><ul><li>数据自己读不能自己写，如果需要双向通信需要创建多根管道。 </li><li>数据一旦被读走，便不在管道中存在，不可反复读取。</li><li>由于管道采用半双工通信方式，因此数据只能在一个方向流动。</li><li>只能在有公共祖先的进程间使用管道。</li></ul><p><strong>管道函数：</strong></p><ul><li><p><code> int pipe(int pipefd[2]);</code></p><ul><li>pipefd 读写文件描述符，0代表读，1代表写。</li><li>返回值：失败-1，成功0。</li></ul></li><li><p>读管道 ：</p><ul><li>写端 全部关闭 – read读到0，相当于读到文件末尾。</li><li>写端没有全部关闭。<ul><li>有数据  – read读到数据。</li><li>无数据  – read阻塞，fcntl函数可以更改非阻塞。</li></ul></li></ul></li><li><p>写管道：</p><ul><li>读端全部关闭  –  产生一个信号SIGPIPE，程序异常终止。</li><li>读端未全部关闭。<ul><li>管道已满  –  write阻塞。</li><li>管道未满  –  write正常写入。</li></ul></li></ul></li></ul><ul><li>long fpathconf(int fd, int name);<ul><li>计算管道大小。</li><li>name 设置为  _PC_PIPE_BUF。</li></ul></li></ul><h2 id="FIFO通信"><a href="#FIFO通信" class="headerlink" title="FIFO通信"></a>FIFO通信</h2><p>​        FIFO有名管道，实现无血缘关系进程通信。</p><ul><li>创建一个管道的伪文件。<ul><li>mkfifo myfifo 命令创建。</li><li><code>int mkfifo(const char *pathname, mode_t mode);</code> 函数创建。</li></ul></li><li>内核会针对fifo文件开辟一个缓冲区，操作fifo文件–实际上就是文件读写，可以操作缓冲区，实现进程间通信。</li></ul><h2 id="mmap通信"><a href="#mmap通信" class="headerlink" title="mmap通信"></a>mmap通信</h2><p>​        mmap共享映射区，可以无血缘关系进程通信。</p><ul><li><code>void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);</code><ul><li>创建映射区。</li><li>addr     传NULL。</li><li>length  映射区长度。</li><li>prot：<ul><li>PROT_READ   可读 。</li><li>PROT_WRITE  可写。</li><li>MAP_ANON     可以创建匿名映射，不用再建立一个文件，这时候fd设为-1。这个宏在有些Unix系统没有，匿名映射只能实现有血缘关系的进程通信。</li></ul></li><li>flag：<ul><li>MAP_SHARED 共享的，对内存的修改会影响到源文件。</li><li>MAP_PRIVATE 私有的，修改不反应到磁盘实际文件，是一个copy-on-write（写时复制）的映射方式。</li></ul></li><li>fd  文件描述符。</li><li>offeset  偏移量。</li><li>返回值：<ul><li>成功返回可用的内存首地址。</li><li>失败返回MAP_FAILED。</li></ul></li></ul></li><li><code>int munmap(void *addr, size_t length);</code><ul><li>释放映射区。</li><li>addr 传mmap返回值。</li><li>length mmap创建的长度。</li><li>返回值：<ul><li>失败返回-1。</li><li>成功返回0。</li></ul></li></ul></li></ul><p><img src="https://s2.loli.net/2022/03/08/W9iZmHUJXEIGMRO.png" alt="QQ截图20220308132738.png"></p><h2 id="进程如何通过共享内存通信"><a href="#进程如何通过共享内存通信" class="headerlink" title="进程如何通过共享内存通信"></a>进程如何通过共享内存通信</h2><h2 id="进程调度的时机"><a href="#进程调度的时机" class="headerlink" title="进程调度的时机"></a>进程调度的时机</h2><ul><li>当前运行的进程运行结束。</li><li>当前运行的进程由于某种原因阻塞。</li><li>执行完系统调用等系统程序后返回用户进程。</li><li>在使用抢占调度的系统中，具有更高优先级的进程就绪时。</li><li>分时系统中，分给当前进程的时间片用完。</li></ul><h2 id="不能进行进程调度的情况"><a href="#不能进行进程调度的情况" class="headerlink" title="不能进行进程调度的情况"></a>不能进行进程调度的情况</h2><h2 id="进程的调度策略"><a href="#进程的调度策略" class="headerlink" title="进程的调度策略"></a>进程的调度策略</h2><h2 id="进程调度策略的基本设计指标"><a href="#进程调度策略的基本设计指标" class="headerlink" title="进程调度策略的基本设计指标"></a>进程调度策略的基本设计指标</h2><h2 id="孤儿进程和僵尸进程"><a href="#孤儿进程和僵尸进程" class="headerlink" title="孤儿进程和僵尸进程"></a>孤儿进程和僵尸进程</h2><ul><li>孤儿进程：父亲死了 ，子进程被init进程领养。父进程退出，子进程还在运行的这些子进程都是孤儿进程，孤儿进程将会被init进程(1号进程)收养，并由 init进程对他们完成状态收集工作。</li><li>僵尸进程：子进程死了，父进程没有回收子进程的资源（PCB）。进程使用fork创建子进程，如果子进程退出，而父进程没有盗用wait或者 waitpid获取子进程状态信息，那么子进程的进程描述符依然保存在系统中的这些进程为僵尸进程。</li><li>如何回收僵尸进程：<ul><li>kill 父进程，init领养子进程后，自动回收。</li><li>wait和waitpid</li></ul></li></ul><h2 id="进程同步的方法"><a href="#进程同步的方法" class="headerlink" title="进程同步的方法"></a>进程同步的方法</h2><h2 id="进程API"><a href="#进程API" class="headerlink" title="进程API"></a>进程API</h2><p><strong>fork:</strong></p><ul><li><code>pid_t fork();</code> </li><li>创建一个新的进程。fork函数将运行着的程序分成2个（几乎）完全一样的进程，每个进程都启动一个从代码的同一位置开始执行的线程。子进程使用相同的pc（程序计数器），相同的CPU寄存器，在父进程中使用的相同打开文件。</li><li>返回值：<ul><li>失败 -1。</li><li>成功，两次返回。<ul><li>父进程返回子进程id。</li><li>子进程返回0。</li></ul></li></ul></li><li>父子进程的数据：读时共享，写时复制。</li></ul><p><strong>getpid，getppid：</strong></p><ul><li><code>pid_t getpid();</code>获得进程id。</li><li><code>pid_t getppid()</code>获得父进程id。</li></ul><p><strong>wait:</strong></p><ul><li><p>回收子进程，知道子进程死亡原因。</p></li><li><p>作用：</p><ul><li>阻塞等待。</li><li>回收子进程资源。</li><li>查看死亡原因。</li></ul></li><li><p><code>pid_t wait(int *wstatus);</code></p><ul><li>没有子进程退出会阻塞。</li><li>wstatus 传出参数，告知死亡原因，具体看百度。</li><li>返回值：<ul><li>成功返回终止的子进程ID。</li><li>失败返回-1。</li></ul></li></ul></li><li><p><code>pid_t waitpid(pid_t pid, int *wstatus, int options);</code></p><ul><li><p>pid </p><p><img src="https://s2.loli.net/2022/03/07/latG6nAJriKVXLy.png" alt="QQ截图20220307111516.png"></p></li><li><p>wstatus 传出参数，告知死亡原因，具体看百度。</p></li><li><p>options</p><ul><li>设置0和wait差不多。</li><li>设置WNOHANG 如果没有子进程退出立刻返回。</li></ul></li><li><p>返回值：</p><ul><li>如果设置了WNOHANG，如果没有子进程退出，返回0。如果有子进程退出，返回PID。</li><li>失败返回-1（没有子进程）。</li></ul></li></ul></li></ul><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><h2 id="为什么需要线程"><a href="#为什么需要线程" class="headerlink" title="为什么需要线程"></a>为什么需要线程</h2><h2 id="线程同步的方法"><a href="#线程同步的方法" class="headerlink" title="线程同步的方法"></a>线程同步的方法</h2><h2 id="线程和进程的区别和联系"><a href="#线程和进程的区别和联系" class="headerlink" title="线程和进程的区别和联系"></a>线程和进程的区别和联系</h2><ul><li></li></ul><h2 id="进程和线程的基本API"><a href="#进程和线程的基本API" class="headerlink" title="进程和线程的基本API"></a>进程和线程的基本API</h2><h2 id="进程同步和线程同步的区别"><a href="#进程同步和线程同步的区别" class="headerlink" title="进程同步和线程同步的区别"></a>进程同步和线程同步的区别</h2><h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><p><strong>特点：</strong>简单，不能带大量信息，满足特定条件发生。</p><p><strong>信号的机制：</strong>进程B发送给进程A，内核产生信号，内核处理。</p><p><strong>信号产生：</strong></p><ul><li>按键产生 crtl+c crtl+z  crtl+\。</li><li>调用函数  kill  raise   abort。</li><li>定时器  alarm， setitimer。</li><li>命令产生  kill。</li><li>硬件异常  段错误，浮点型错误，总线错误，SIGPIPE。</li></ul><p><strong>信号状态：</strong></p><ul><li>产生。</li><li>递答  信号到达并且处理完。</li><li>未决  信号被阻塞。</li></ul><p><strong>信号默认处理方式：</strong></p><ul><li>忽略。</li><li>执行默认动作。</li><li>捕获。</li></ul><p><strong>信号四要素：</strong></p><ul><li>编号</li><li>事件</li><li>名称</li><li>默认处理动作：忽略、终止、终止+core、暂停、继续。</li></ul><h2 id="什么是信号"><a href="#什么是信号" class="headerlink" title="什么是信号"></a>什么是信号</h2><h2 id="如何编写正确且安全的信号处理函数"><a href="#如何编写正确且安全的信号处理函数" class="headerlink" title="如何编写正确且安全的信号处理函数"></a>如何编写正确且安全的信号处理函数</h2>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
            <tag> OS </tag>
            
            <tag> 进程 </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存泄露</title>
      <link href="2022/02/22/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
      <url>2022/02/22/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h1><p>​        内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是<a href="http://baike.baidu.com/view/330120.htm">应用程序</a>分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。</p><h1 id="内存是如何泄露的？"><a href="#内存是如何泄露的？" class="headerlink" title="内存是如何泄露的？"></a>内存是如何泄露的？</h1><ul><li>堆区数据未被释放。</li></ul><h1 id="C-中的内存泄露该如何避免？"><a href="#C-中的内存泄露该如何避免？" class="headerlink" title="C++ 中的内存泄露该如何避免？"></a>C++ 中的内存泄露该如何避免？</h1><ul><li>避免在堆区开辟数据。</li><li>使用智能指针，而不是手动管理内存。</li><li>使用 std::string 来替代 char*。</li><li>善用 RAII（Resource Acquisition Is Initialization）思想：在类的构造函数中分配资源，在类的析构函数中释放资源。</li></ul><h1 id="如果发生了内存泄露，该如何定位问题代码？"><a href="#如果发生了内存泄露，该如何定位问题代码？" class="headerlink" title="如果发生了内存泄露，该如何定位问题代码？"></a>如果发生了内存泄露，该如何定位问题代码？</h1><ul><li>使用工具软件BoundsChecker，BoundsChecker是一个运行时错误检测工具，它主要定位程序运行时期发生的各种错误。</li><li>调试运行DEBUG版程序，运用以下技术：CRT(C run-time libraries)、运行时函数调用堆栈、内存泄漏时提示的内存分配序号(集成开发环境OUTPUT窗口)，综合分析内存泄漏的原因，排除内存泄漏。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 面经 </tag>
            
            <tag> 内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件读写</title>
      <link href="2022/02/22/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/"/>
      <url>2022/02/22/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/</url>
      
        <content type="html"><![CDATA[<h1 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h1><ul><li>头文件<code>#include&lt;fstream&gt;</code></li></ul><h2 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// 以输出方式打开文件</span></span><br><span class="line">    <span class="comment">//  ofstream ofs(&quot;./test.txt&quot;, ios::out | ios::trunc);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 也可以后期指定打开方式</span></span><br><span class="line">    ofstream ofs;</span><br><span class="line">    ofs.<span class="built_in">open</span>(<span class="string">&quot;./test.txt&quot;</span>, ios::out | ios::trunc);</span><br><span class="line">    <span class="keyword">if</span>(!ofs.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;open fail&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ofs&lt;&lt;<span class="string">&quot;goudan&quot;</span>&lt;&lt;endl;</span><br><span class="line">    ofs&lt;&lt;<span class="string">&quot;11&quot;</span>&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// 以输出方式打开文件</span></span><br><span class="line">    <span class="comment">//  ifstream ifs(&quot;./test.txt&quot;, ios::in);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 也可以后期指定打开方式</span></span><br><span class="line">    ifstream ifs;</span><br><span class="line">    ifs.<span class="built_in">open</span>(<span class="string">&quot;./test.txt&quot;</span>, ios::out | ios::trunc);</span><br><span class="line">    <span class="keyword">if</span>(!ifs.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;open fail&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第一种方式</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span>(ifs&gt;&gt;buf) &#123; <span class="comment">// 按行读取</span></span><br><span class="line">cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第二种方式</span></span><br><span class="line">    <span class="keyword">char</span> buf2[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span>(ifs.<span class="built_in">eof</span>()) &#123;<span class="comment">// eof读到文件尾</span></span><br><span class="line">ifs.<span class="built_in">getline</span>(buf2, <span class="built_in"><span class="keyword">sizeof</span></span>(buf2));</span><br><span class="line">        cout &lt;&lt; buf2 &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第三种方式，不推荐，按单个字符读取</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">while</span>(c = ifs.<span class="built_in">get</span>() != EOF) &#123; <span class="comment">// EOF文件尾</span></span><br><span class="line">        cout &lt;&lt; c;</span><br><span class="line">    &#125;</span><br><span class="line">    ifs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 文件操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>输入输出流</title>
      <link href="2022/02/22/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/"/>
      <url>2022/02/22/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="标准输入流"><a href="#标准输入流" class="headerlink" title="标准输入流"></a>标准输入流</h1><ul><li><code>cin.get(一个参数)</code>缓冲区中读取一个字符。</li><li><code> cin.get(两个参数)</code>读取字符串，不读换行符。</li><li><code>cin.getline()</code>读取字符串，读取换行符并扔掉。</li><li><code>cin.ignore(N)</code>忽略N个字符。</li><li><code>cin.peek()</code>偷窥，偷看一个字符然后放回缓冲区 。</li><li><code>cin.putback(c)</code>把字符c放回缓冲区。</li><li><code>cin.fail()</code>看标志位，0正常，1不正常。</li><li><code>cin.clear()</code>重置标志位。</li><li><code>cib.sync()</code>清空缓冲区。</li></ul><h1 id="标准输出流"><a href="#标准输出流" class="headerlink" title="标准输出流"></a>标准输出流</h1><ul><li><code>cout.flush</code>刷新缓冲区，Linux有效。</li><li><code>cout.put()</code> 向缓冲区写字符。</li><li><code>cout.write()</code>从缓冲区写num个字节到当前输出流中。</li></ul><p><img src="https://s2.loli.net/2022/02/22/H1IZo4N5h6X7Dji.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++异常</title>
      <link href="2022/02/21/C++%E5%BC%82%E5%B8%B8/"/>
      <url>2022/02/21/C++%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><ul><li>基本思想：将问题检测和问题处理相分离。</li><li>try试图执行try{}中的内容。</li><li>在可能出现异常的地方抛出异常 eg： throw -1； </li><li>try下面catch捕获异常。</li><li>catch(捕获类型)   …代表所有其他类型。</li><li>如果不能处理异常，继续向上抛出  thow；</li><li>如果没有任何处理异常的地方，那么程序调用terminate函数终止程序 。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myDevide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="number">-1</span>;  <span class="comment">// 抛出int异常</span></span><br><span class="line">        <span class="comment">// throw 3.14;  抛出double异常</span></span><br><span class="line">        <span class="comment">// throw &quot;a&quot;;</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="built_in">myDevide</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">int</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;int error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">double</span>) &#123;</span><br><span class="line">        <span class="comment">// throw;  如果加上这个，则异常向上反馈，最后只输出 main double error</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;double error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(...) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;other error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">test01</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">double</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;main double error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h1><h2 id="自己写类"><a href="#自己写类" class="headerlink" title="自己写类"></a>自己写类</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;自定义 error&quot;</span> &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myDevide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">MyException</span>();  <span class="comment">// 匿名对象    </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="built_in">myDevide</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(MyException e) &#123;</span><br><span class="line">e.<span class="built_in">prinError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承系统中自带的"><a href="#继承系统中自带的" class="headerlink" title="继承系统中自带的"></a>继承系统中自带的</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyOutOfRangeException</span> :</span> <span class="keyword">public</span> exception &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyOutOfRangeException</span>(string errorInfo) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_ErrorInfo = errorInfo;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">MyOutOfRangeException</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> cont <span class="keyword">char</span>* <span class="title">what</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_ErrorInfo.<span class="built_in">c_str</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    string m_ErrorInfo;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h1 id="栈解旋"><a href="#栈解旋" class="headerlink" title="栈解旋"></a>栈解旋</h1><ul><li>从try开始到throw抛出异常前，所有栈上的对象都会被释放，这个过程称为栈解旋。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;自定义 error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myDevide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 栈解旋</span></span><br><span class="line">        <span class="comment">// 从try开始到throw抛出异常前，所有栈上的对象都会被释放，这个过程称为栈解旋。</span></span><br><span class="line">        Person p1;</span><br><span class="line">        Person p2;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">MyException</span>();  <span class="comment">// 匿名对象    </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="built_in">myDevide</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(MyException e) &#123;</span><br><span class="line">e.<span class="built_in">prinError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">p1构造</span></span><br><span class="line"><span class="comment">p2构造</span></span><br><span class="line"><span class="comment">p2析构</span></span><br><span class="line"><span class="comment">p1析构</span></span><br><span class="line"><span class="comment">自定义 error</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="异常接口声明"><a href="#异常接口声明" class="headerlink" title="异常接口声明"></a>异常接口声明</h1><ul><li>抛出特定类型异常。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该代码不能在VS里运行，可以在QT和linux运行。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="title">throw</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span>)</span>  </span>&#123;<span class="comment">// throw(int)只能抛出int类型异常 throw()不抛出任何类型异常</span></span><br><span class="line"><span class="keyword">throw</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">int</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;int error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="异常变量的生命周期"><a href="#异常变量的生命周期" class="headerlink" title="异常变量的生命周期"></a>异常变量的生命周期</h1><ul><li>如果<code>catch(MyException e)</code> 会多开销一份数据，调用拷贝构造。</li><li>如果<code>catch(MyException *e)</code>，如果不new会提前释放对象，new需要自己释放delete。</li><li>推荐<code>catch(MyException &amp;e)</code>，只一份数据。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyException</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;MyException moren gouzao&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">MyException</span>(<span class="keyword">const</span> MyException &amp;e) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;MyException kaobei gouzao&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;自定义 error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">MyException</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;MyException xigou&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">MyException</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">doWork</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(MyException &amp;e) &#123; <span class="comment">// MyException e会多开销一份数据</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;catch error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">输出catch(MyException e)情况：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">MyException moren gouzao</span></span><br><span class="line"><span class="comment">MyException kaobei gouzao</span></span><br><span class="line"><span class="comment">catch error</span></span><br><span class="line"><span class="comment">MyException xigou</span></span><br><span class="line"><span class="comment">MyException xigou</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注：编译器会做优化，不会立刻将匿名对象释放掉，所以可以改为 catch(MyException &amp;e)减少开销。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="异常的多态使用"><a href="#异常的多态使用" class="headerlink" title="异常的多态使用"></a>异常的多态使用</h1><ul><li>利用多态实现<code>printError()</code>同一个接口调用。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseException</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">printError</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NullPointException</span> :</span> <span class="keyword">public</span> BaseException  &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt;  <span class="string">&quot;Null Point Error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">NullPointException</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">doWork</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(BaseException &amp;e) &#123;</span><br><span class="line">        e.<span class="built_in">printError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="系统标准异常使用"><a href="#系统标准异常使用" class="headerlink" title="系统标准异常使用"></a>系统标准异常使用</h1><ul><li>头文件<code>#include&lt;stdexcept&gt;</code>。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">if</span>(age &lt; <span class="number">0</span> || age &gt; <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;年龄越界！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span>  </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="number">1000</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(out_of_range &amp;e) &#123;</span><br><span class="line">        cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;  <span class="comment">// 年龄越界！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++类型转换</title>
      <link href="2022/02/20/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
      <url>2022/02/20/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="静态类型转换（static-cast）"><a href="#静态类型转换（static-cast）" class="headerlink" title="静态类型转换（static_cast）"></a>静态类型转换（static_cast）</h1><ul><li><p>写法<code>static_cast&lt;目标类型&gt;(原始对象)</code>。</p></li><li><p>可以进行基础类型转换。</p></li><li><p>父与子的class可以转换。</p></li><li><p>没有父子关系的class不可以转换。</p></li></ul><h1 id="动态类型转换（dynamic-cast）"><a href="#动态类型转换（dynamic-cast）" class="headerlink" title="动态类型转换（dynamic_cast）"></a>动态类型转换（dynamic_cast）</h1><ul><li><p>写法<code>dynamic_cast&lt;目标类型&gt;(原始对象)</code>。</p></li><li><p>不可以转换基础数据类型。</p></li><li><p>父子间可以转换。</p><ul><li>一般父转子，不可以。</li><li>子转父，可以。</li><li>如果发生多态，都可以。</li></ul></li></ul><h1 id="常量转换（const-cast）"><a href="#常量转换（const-cast）" class="headerlink" title="常量转换（const_cast）"></a>常量转换（const_cast）</h1><ul><li><p>写法<code>const_cast&lt;目标类型&gt;(原始对象)</code>。</p></li><li><p>用来修改类型的const属性。</p><ul><li>常量指针和非常量指针相互转换，并且仍然指向原来对象。</li><li>常量引用和非常量引用相互转换，并且仍然指向原来对象。</li></ul></li></ul><p>​    <font color=red><strong>注意：不能对非指针和非引用的变量使用const_cast操作符去移除他的const。</strong></font></p><h1 id="重新解释转换（reinterpret-cast）"><a href="#重新解释转换（reinterpret-cast）" class="headerlink" title="重新解释转换（reinterpret_cast）"></a>重新解释转换（reinterpret_cast）</h1><ul><li><p>写法<code>reinterpret_cast&lt;目标类型&gt;(原始对象)</code>。</p></li><li><p>什么都可以转，最不安全，不推荐。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 类型转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++模板</title>
      <link href="2022/02/18/C++%E6%A8%A1%E6%9D%BF/"/>
      <url>2022/02/18/C++%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h1><p>​        函数模板实际上是建立一个通用函数，其函数类型和形参类型不具体制定用一个虚拟的类型来代表，这个通用函数就是函数模板。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型参数化，泛型编程</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span>  <span class="comment">// 告诉编译器，T是一个通用类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap</span><span class="params">(T &amp;a, T &amp;b)</span> </span>&#123;</span><br><span class="line">    T tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// typename和class二者没啥区别,等价</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 自动类型推导</span></span><br><span class="line">    <span class="built_in">mySwap</span>(a, b);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 显式指定类型</span></span><br><span class="line">    mySwap&lt;<span class="keyword">int</span>&gt;(a, b);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 模板必须指定出T才可以使用。</span></span><br><span class="line">    <span class="built_in">func</span>();  <span class="comment">// 报错</span></span><br><span class="line">    func&lt;<span class="keyword">int</span>&gt;(); <span class="comment">// 正常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数模板和普通函数区别以及调用规则"><a href="#函数模板和普通函数区别以及调用规则" class="headerlink" title="函数模板和普通函数区别以及调用规则"></a>函数模板和普通函数区别以及调用规则</h1><p><strong>区别:</strong></p><ul><li>函数模板不能进行隐式类型转换，普通函数可以。</li></ul><p><strong>调用规则：</strong></p><ul><li>c++编译器优先考虑普通函数。</li><li>可以通过空模板实参列表的语法限定编译器只能通过模板匹配。</li><li>函数模板可以向普通函数一样被重载。</li><li>如果函数模板可以产生一个更好的匹配，优先使用函数模板。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt; </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPlus</span><span class="params">(T &amp;a, T &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPlus01</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">myPlus</span>(a, c); <span class="comment">// 报错，不能执行</span></span><br><span class="line">    <span class="built_in">myPlus2</span>(a, c); <span class="comment">// 可以执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数和函数模板的调用规则</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt; </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(T &amp;a, T &amp;b)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;函数模板print&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt; </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(T &amp;a, T &amp;b, T &amp;c)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;重载函数模板print&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;普通函数print&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果出现重载，优先使用普通函数调用，如果普通函数只声明没有实现，会出现错误</span></span><br><span class="line"><span class="built_in">myPrint</span>(a, b); <span class="comment">// 普通函数print</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果想强制使用模板，可以使用空参数列表</span></span><br><span class="line">    myPrint&lt;&gt;(a, b);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 函数模板可以发生重载</span></span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">30</span>;</span><br><span class="line">    <span class="built_in">myPrint</span>(a, b, c);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果函数模板可以产生更好的匹配，优先使用函数模板</span></span><br><span class="line">    <span class="keyword">char</span> d = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">    <span class="keyword">char</span> e = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line"><span class="built_in">myPrint</span>(d, e); <span class="comment">// 调用函数模板</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="模板机制"><a href="#模板机制" class="headerlink" title="模板机制"></a>模板机制</h1><ul><li>模板不是万能的，不能适用所有的数据类型。</li><li>函数模板通过具体类型产生不同的函数。</li><li>编译器对函数模板进行<strong>两次</strong>编译，在声明地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译（替换后代码称为模板函数）。</li></ul><h1 id="模板局限性及解决"><a href="#模板局限性及解决" class="headerlink" title="模板局限性及解决"></a>模板局限性及解决</h1><ul><li>模板不能解决所有的类型。</li><li>如果出现不能解决的类型，可以通过第三代具体化进行解决。</li><li>语法<code>template &lt;&gt; 返回值 函数名&lt;具体类型&gt;(参数)&#123;&#125;</code>       返回值和函数名必须和模板一致。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="keyword">int</span> age) : <span class="built_in">mName</span>(name), <span class="built_in">mAge</span>(age)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    string mName;</span><br><span class="line">    <span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCompare</span><span class="params">(T &amp;a, T &amp;b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a == b) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过第三代具体化自定义数据类型解决问题</span></span><br><span class="line"><span class="comment">// 如果具体化能够优先匹配，那么选择具体化</span></span><br><span class="line"><span class="comment">// 语法template &lt;&gt; 返回值 函数名&lt;具体类型&gt;(参数)      返回值和函数名必须和模板一致</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">bool</span> myCompare&lt;Person&gt;(Person &amp;a, Person &amp;b) &#123;</span><br><span class="line"><span class="keyword">if</span>(a.mAge == b.mAge) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;jerry&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="built_in">myCompare</span>(p1, p2);  <span class="comment">// 如果没具体化自定义实现会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h1><ul><li>写法：<code>template&lt;class T, ...&gt;</code> 紧跟着类。</li><li>相比于函数模板，类模板可以有默认类型参数。</li><li>函数模板可以进行自动类型推导，类模板不可以。</li><li>成员函数一开始不会创建，在运行时才会创建。</li></ul><p><strong>类模板做函数的参数的三种方式：</strong></p><ul><li>显式指定类型</li><li>xxxxxxxxxx #include<stdexcept>​class Person {public:    Person(int age) {        if(age &lt; 0 || age &gt; 200) {            throw out_of_range(“年龄越界！”);        }    }        int m_Age;};​void test01()  {    try {        Person p(1000);    }    catch(out_of_range &amp;e) {        cout &lt;&lt; e.what() &lt;&lt; endl;  // 年龄越界！    }}c++</li><li>整体模板化</li></ul><p><strong>查看类型名称的方式：</strong><code>typeid(T1).name</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">NameType</span>, <span class="keyword">class</span> <span class="title">AgeType</span> =</span> <span class="keyword">int</span>&gt;  <span class="comment">// 类模板可以有默认类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(NameType name, Agetype age) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;age:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    NameType m_Name;</span><br><span class="line">    AgeType m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 类模板不支持自动类型推导</span></span><br><span class="line">    <span class="comment">// Person p(&quot;goudan&quot;, 100);   会出错</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">Person&lt;string, <span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;goudan&quot;</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传参方式</span></span><br><span class="line"><span class="comment">// 1.指定传入类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork1</span><span class="params">(Person&lt;string, <span class="keyword">int</span>&gt; &amp;p)</span> </span>&#123;</span><br><span class="line">    p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.参数模板化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T1, class T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork2</span><span class="params">(Person&lt;T1, T2&gt; &amp;p)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 如何查看类型</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(T1).name &lt;&lt; endl;</span><br><span class="line">    p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.整体模板化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork3</span><span class="params">(T &amp;p)</span> </span>&#123;</span><br><span class="line">p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person&lt;string, <span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;goudan&quot;</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="built_in">doWork1</span>(p);</span><br><span class="line">    <span class="built_in">doWork2</span>(p);</span><br><span class="line">    <span class="built_in">doWork3</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类模板碰到继承的问题"><a href="#类模板碰到继承的问题" class="headerlink" title="类模板碰到继承的问题"></a>类模板碰到继承的问题</h1><ul><li>基类如果是模板类，必须让子类告诉编译器基类中的T是什么类型。否则无法分配内存，编译不通过。</li><li>利用参数列表<code>class Child : public Base&lt;int&gt;</code> </li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// child继承base必须告诉base中T的类型，否则无法分配内存</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Base&lt;<span class="keyword">int</span>&gt; &#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// child2 也是模板类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child2</span> :</span> <span class="keyword">public</span> Base&lt;T2&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T1 m_B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Child2&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt; c2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>类模板类外实现成员函数：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">NameType</span>, <span class="keyword">class</span> <span class="title">AgeType</span>&gt;</span>  <span class="comment">// 类模板可以有默认类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(NameType name, Agetype age); </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    NameType m_Name;</span><br><span class="line">    AgeType m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">NameType</span>, <span class="keyword">class</span> <span class="title">AgeType</span>&gt;</span></span><br><span class="line">Person&lt;NameType, AgeType&gt;::<span class="built_in">Person</span>(NameType name, Agetype age) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">NameType</span>, <span class="keyword">class</span> <span class="title">AgeType</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> Person&lt;NameType, AgeType&gt;::<span class="built_in">showPerson</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color=red><strong>注意：类模板不要用分文件编写，如果用正常的分文件编写会出现问题，因为类模板成员函数一开始不会创建，在运行时才会创建，导致包含.h头文件，不会创建函数实现，无法解析外部命令，所以在检查#include“Person.h”不会有问题，但是到链接阶段会链接不到成员函数，可以改成#include“Person.cpp”（但是一般不这么做，一般解决方案为：把实现和声明放在一个文件下，改名为hpp文件，hpp一般为模板）</strong></font></p><h1 id="类模板碰到友元函数"><a href="#类模板碰到友元函数" class="headerlink" title="类模板碰到友元函数"></a>类模板碰到友元函数</h1><p><strong>友元函数类内实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">printPerson</span><span class="params">(Person&lt;T1, T2&gt; &amp;p)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; p.m_Name &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(T1 name, T2 age) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;age:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 m_Name;</span><br><span class="line">    T2 m_Age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>友元函数类外实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 让编译器看到printPErson,否则编译器看不到他的声明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 让编译器看到Person类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span><span class="class"><span class="keyword">class</span> <span class="title">Person</span>;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span><span class="function"><span class="keyword">void</span> <span class="title">printPerson</span><span class="params">(Person&lt;T1, T2&gt; &amp;p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="comment">// 友元函数类外实现，利用空参数列表&lt;&gt;告诉编译器这是模板函数声明，否则是普通函数声明</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> printPerson&lt;&gt;(Person&lt;T1, T2&gt; &amp;p);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(T1 name, T2 age) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;age:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 m_Name;</span><br><span class="line">    T2 m_Age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T1, class T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPerson</span><span class="params">(Person&lt;T1, T2&gt; &amp;p)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; p.m_Name &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++多态</title>
      <link href="2022/01/17/C++%E5%A4%9A%E6%80%81/"/>
      <url>2022/01/17/C++%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><ul><li><p>C++支持编译时多态（静态多态）和运行时多态（动态多态）。重载–静态多态。虚函数和继承–动态多态。</p></li><li><p>静态多态和动态多态的区别就是函数地址是早绑定（静态连编，编译阶段绑定好地址）还是晚绑定（动态联编，运行时绑定好地址）。</p></li><li><p>什么叫多态？</p><ul><li>父类的引用或指针指向子类对象。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;   <span class="comment">// 改为 virtual void speak()</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;animal speak&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cat</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;  <span class="comment">// 子类中的 virtual 可写可不写</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;cat speak&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数func里， speak函数的地址早就绑定好了，在编译阶段就确定了地址</span></span><br><span class="line"><span class="comment">// 如果像调用cat的speak，不能提前绑定好函数地址，所以需要在运行的时候再去确定函数地址</span></span><br><span class="line"><span class="comment">// 动态联编写法：把speak（）在父类声明为虚函数，就发生了多态</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Animal &amp;animal)</span> </span>&#123;</span><br><span class="line">    animal.<span class="built_in">speak</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Cat cat;</span><br><span class="line">    <span class="built_in">func</span>(cat);  <span class="comment">// animal speak;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="多态内部原理"><a href="#多态内部原理" class="headerlink" title="多态内部原理"></a>多态内部原理</h1><ul><li>Animal 内部结构<ul><li><p>Animal 内部存在一个vfptr（virtual function pointer）虚函数表指针。</p></li><li><p>虚函数表指针指向虚函数表。</p></li><li><p>当Cat中没有写speak函数时，Cat的vfptr指向Animal speak函数，如下图：</p></li><li><p><img src="https://s2.loli.net/2022/01/18/XW46U1CHu3JRas8.png" alt="image.png"></p></li><li><p>当Cat中重写了speak函数后，Cat的vfptr指向自己的cat speak函数（对象创建的时候，调用构造函数，将所有的虚函数指针都指向自己的虚函数表，这个操作我们看不到），如下图：</p></li><li><p><img src="https://s2.loli.net/2022/01/18/u7mxhFrbGjA6kvI.png" alt="image.png"></p></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(Animal) &lt;&lt; endl;  <span class="comment">// 没加virtual时是1，加了以后是4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>深入剖析内部调用</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Animal * animal = <span class="keyword">new</span> Cat;</span><br><span class="line">    <span class="comment">// (*(int *)*(int *)animal) 为函数地址</span></span><br><span class="line">    ((<span class="built_in"><span class="keyword">void</span></span>(*)()) (*(<span class="keyword">int</span> *)*(<span class="keyword">int</span> *)animal))();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h1><ul><li>如果父类有纯虚函数，子类继承父类，子类必须将其实现，否则子类也是一个抽象类。</li><li>如果父类有纯虚函数，那么父类不能实例化对象。</li><li>如果类有了纯虚函数，通常称为抽象类。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;   <span class="comment">// 虚函数</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;animal speak&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 纯虚函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h1><ul><li>虚析构解决问题：是为了delete基类指针指向派生类时防止子类的数据不会被释放造成内存泄露。</li><li>纯虚析构：<ul><li>纯虚析构，需要声明，还需要实现，类内声明，类外实现。</li><li>如果类中出现纯虚析构，那么这个类也算抽象类。</li><li>抽象类不能实例化对象。</li></ul></li><li>虚析构和纯虚析构区别：纯虚析构的类不能实例化对象。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Animal speak&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 普通析构 不会调用子类的析构，所以可能导致释放不干净</span></span><br><span class="line">    <span class="comment">// 利用虚析构解决该问题</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Animal xigou&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 纯虚析构</span></span><br><span class="line">    <span class="comment">// 纯虚析构，需要声明，还需要实现，类内声明，类外实现</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal::~<span class="built_in">Animal</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Animal chunxu&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cat</span>(<span class="keyword">const</span> <span class="keyword">char</span> * name) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;mName = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(name) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;name, name);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Cat speak&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">Cat</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Cat xigou&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;mName != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;mName;</span><br><span class="line">            <span class="keyword">this</span>-&gt;mName = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>* mName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Animal * cat = <span class="keyword">new</span> <span class="built_in">Cat</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    animal-&gt;<span class="built_in">speak</span>();   <span class="comment">// Cat speak</span></span><br><span class="line">    <span class="keyword">delete</span> animal;  <span class="comment">// 父类析构函数没加virtual：Animal xigou</span></span><br><span class="line">    <span class="comment">// 父类改成虚析构后： Cat xigou</span></span><br><span class="line">    <span class="comment">//   Animal xigou</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 多态 </tag>
            
            <tag> 抽象类 </tag>
            
            <tag> 纯虚函数 </tag>
            
            <tag> 虚函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++继承</title>
      <link href="2022/01/15/C++%E7%BB%A7%E6%89%BF/"/>
      <url>2022/01/15/C++%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><ul><li>解决代码的复用。</li><li>语法： class 子类 ： 继承方式  父类</li></ul><h1 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h1><ul><li>三种：public、private、protected</li></ul><p><img src="https://s2.loli.net/2022/01/16/x3k79EPCJQdefIL.png" alt="QQ截图20220116151208.png"></p><ul><li>子类会继承父类的所有内容，包括私有属性，只是被编译器隐藏起来，访问不到私有成员。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>()&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(Son) &lt;&lt; endl;   <span class="comment">// 输出16；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="继承中的构造和析构函数"><a href="#继承中的构造和析构函数" class="headerlink" title="继承中的构造和析构函数"></a>继承中的构造和析构函数</h1><ul><li>子类会继承父类的成员属性和成员函数，但是子类不会继承父类的构造函数和析构函数。只有父类自己知道如何构造和析构自己的属性，而子类不知道。另外operator=也不会继承下来。</li><li>子类创建对象时，会先调用父类的构造，然后调用自身的构造。</li><li>析构顺序和构造顺序正好相反。</li><li>当父类的构造函数有参数时，需要在子类初始化列表（参数列表）中显式调用父类的构造函数。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base2</span>(<span class="keyword">int</span> a) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;有参构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son2</span> :</span> <span class="keyword">public</span> Base2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Son2() &#123;&#125;   // 报错，不存在无参构造</span></span><br><span class="line">    <span class="built_in">Son2</span>(<span class="keyword">int</span> a) : <span class="built_in">Base2</span>(a) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="继承中的同名处理"><a href="#继承中的同名处理" class="headerlink" title="继承中的同名处理"></a>继承中的同名处理</h1><ul><li>如果子类和父类拥有同名的属性和函数，子类不会覆盖父类成员，加作用域就可调父类的。</li><li>如果子类与父类的成员函数名称相同，子类会把父类的<strong>所有</strong>同名版本都隐藏掉，想调用必须加作用域。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123;</span><br><span class="line">        m_A = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base func&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Son</span>() &#123;</span><br><span class="line">        m_A = <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Son func&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Son S1;</span><br><span class="line">    cout &lt;&lt; s1.m_A &lt;&lt; endl;  <span class="comment">// cout 200</span></span><br><span class="line">    cout &lt;&lt; s1.Base::m_A &lt;&lt;endl;  <span class="comment">// cout 100</span></span><br><span class="line"></span><br><span class="line">    s1.<span class="built_in">func</span>();</span><br><span class="line">    s1.Base::<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="继承中静态成员的处理"><a href="#继承中静态成员的处理" class="headerlink" title="继承中静态成员的处理"></a>继承中静态成员的处理</h1><ul><li>静态成员属性，子类可以继承下来。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Base::m_A = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; Son::m_A &lt;&lt;endl;  <span class="comment">// cout 10;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base func&quot;</span> &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base func(int)&quot;</span> &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Base::m_A = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Son func&quot;</span> &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Son::m_A = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; Son::m_A &lt;&lt;endl;  <span class="comment">// cout 20;</span></span><br><span class="line">    cout &lt;&lt; Base::m_A &lt;&lt;endl;  <span class="comment">// cout 10;</span></span><br><span class="line"></span><br><span class="line">    Son::<span class="built_in">func</span>();      <span class="comment">// Son func</span></span><br><span class="line">    Base::<span class="built_in">func</span>();    <span class="comment">// Base func</span></span><br><span class="line">    Son::Base::<span class="built_in">func</span>(<span class="number">10</span>);    <span class="comment">// Base func(int)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h1><ul><li>多继承中很容易引发二义性问题</li><li>语法 ： class Son : public Base1, public Base2 {}</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base1</span>() &#123;</span><br><span class="line">        m_A = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base2</span>() &#123;</span><br><span class="line">        m_A = <span class="number">20</span>;</span><br><span class="line">    &#125;A</span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_C;</span><br><span class="line">    <span class="keyword">int</span> m_D;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(Son) &lt;&lt; endl;     <span class="comment">// 16</span></span><br><span class="line"></span><br><span class="line">    Son s1;</span><br><span class="line">    <span class="comment">// s1.m_A;        // 二义性 error</span></span><br><span class="line">    cout &lt;&lt; s1.Base1::m_A &lt;&lt; endl;  <span class="comment">// 10</span></span><br><span class="line">    cout &lt;&lt; s1.Base2::m_A &lt;&lt; endl;  <span class="comment">// 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="菱形继承和虚继承"><a href="#菱形继承和虚继承" class="headerlink" title="菱形继承和虚继承"></a>菱形继承和虚继承</h1><ul><li>菱形继承存在部分数据重复继承两份的问题，为解决该问题，采用虚继承的方式。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tuo</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SheepTuo</span> :</span> <span class="keyword">public</span> Sheep, <span class="keyword">public</span> Tuo &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SheepTuo st;</span><br><span class="line">    st.Sheep::m_Age = <span class="number">10</span>;</span><br><span class="line">    st.Tuo::m_Age = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">// 存在两份数据，造成资源浪费</span></span><br><span class="line">    cout &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;   <span class="comment">// 10</span></span><br><span class="line">    cout &lt;&lt; st.Tuo::m_Age &lt;&lt; endl;     <span class="comment">// 20;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用虚继承解决：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tuo</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SheepTuo</span> :</span> <span class="keyword">public</span> Sheep, <span class="keyword">public</span> Tuo &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 虚继承后操作一份共享数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SheepTou st;</span><br><span class="line">    st.Sheep::m_Age = <span class="number">10</span>;</span><br><span class="line">    st.Tuo::m_Age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;   <span class="comment">// 20</span></span><br><span class="line">    cout &lt;&lt; st.Tuo::m_Age &lt;&lt; endl;     <span class="comment">// 20;</span></span><br><span class="line">    cout &lt;&lt; st.m_Age &lt;&lt; endl;         <span class="comment">// 此时可以直接访问，没有二义性的情况了，只有一份m_Age</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/01/16/TdmLwOuqiYxXVaM.png" alt="QQ截图20220116203008.png"></p><h1 id="向上类型转换和向下类型转换"><a href="#向上类型转换和向下类型转换" class="headerlink" title="向上类型转换和向下类型转换"></a>向上类型转换和向下类型转换</h1><ul><li>基类转派生类。<ul><li>向下类型转换   安全的。</li></ul></li><li>派生类转基类。<ul><li>向上类型转换  不安全。</li></ul></li><li>如果发生了多态。<ul><li>总是安全的。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 继承 </tag>
            
            <tag> 父类子类转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四旋翼仿真控制模块</title>
      <link href="2022/01/15/%E5%9B%9B%E6%97%8B%E7%BF%BC%E4%BB%BF%E7%9C%9F%E5%90%84%E6%A8%A1%E5%9D%97%E6%A2%B3%E7%90%86/"/>
      <url>2022/01/15/%E5%9B%9B%E6%97%8B%E7%BF%BC%E4%BB%BF%E7%9C%9F%E5%90%84%E6%A8%A1%E5%9D%97%E6%A2%B3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="PositionControl"><a href="#PositionControl" class="headerlink" title="PositionControl"></a>PositionControl</h1><p>​        以下模块参照PX4源码。</p><h2 id="positionControl"><a href="#positionControl" class="headerlink" title="_positionControl"></a>_positionControl</h2><p>所需数据：_pos_sp 和 _pos 和 _gain_pos_p 和 _lim_vel_horizontal</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> PositionControl::_positionControl() &#123;</span><br><span class="line">    <span class="comment">// P-position controller  对位置进行p比例控制</span></span><br><span class="line">    Vector3f vel_sp_position = (_pos_sp - _pos).<span class="built_in">emult</span>(_gain_pos_p);</span><br><span class="line">    <span class="comment">// Position and feed-forward velocity setpoints or position states being NAN results in them not having an influence位置和前馈速度设定点或位置状态为 NAN 导致它们没有影响</span></span><br><span class="line">    _vel_sp += vel_sp_position;</span><br><span class="line">    <span class="comment">// 确保没有NAN</span></span><br><span class="line">    <span class="comment">// ControlMath::setZeroIfNanVector3f(vel_sp_position); </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过优先考虑沿方向的速度分量来约束水平速度</span></span><br><span class="line">    <span class="comment">// 前馈项上的期望位置设定值。</span></span><br><span class="line">    _vel_sp.<span class="built_in">xy</span>() = ControlMath::<span class="built_in">constrainXY</span>(vel_sp_position.<span class="built_in">xy</span>(), (_vel_sp - vel_sp_position).<span class="built_in">xy</span>(), _lim_vel_horizontal);  <span class="comment">// _lim_vel_horizontal水平速度限制</span></span><br><span class="line">    <span class="comment">// Constrain velocity in z-direction. 可以不考虑z轴</span></span><br><span class="line">    <span class="comment">// _vel_sp(2) = math::constrain(_vel_sp(2), -_lim_vel_up, _lim_vel_down);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="velocityControl"><a href="#velocityControl" class="headerlink" title="_velocityControl"></a>_velocityControl</h2><p>来自_positionControl： _vel_sp </p><p>所需数据： _vel 和 _gain_vel_p 和 _gain_vel_d</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> PositionControl::_velocityControl(<span class="keyword">const</span> <span class="keyword">float</span> dt) &#123;</span><br><span class="line"><span class="comment">// PID velocity control</span></span><br><span class="line">    Vector3f vel_error = _vel_sp - _vel;  <span class="comment">// 速度误差</span></span><br><span class="line">    Vector3f acc_sp_velocity = vel_error.<span class="built_in">emult</span>(_gain_vel_p) + _vel_int - _vel_dot.<span class="built_in">emult</span>(_gain_vel_d);  <span class="comment">// emult是乘 _gain_vel_p </span></span><br><span class="line">    <span class="comment">// 如果acc_sp_velocity不是NAN值，就加到期望加速度里，</span></span><br><span class="line">    _acc_sp += acc_sp_velocity； <span class="comment">// _acc_sp 期望加速度</span></span><br><span class="line"></span><br><span class="line">    _accelerationControl();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 垂直方向积分器抗饱和  感觉没用</span></span><br><span class="line"><span class="comment">//if ((_thr_sp(2) &gt;= -_lim_thr_min &amp;&amp; vel_error(2) &gt;= 0.0f) ||</span></span><br><span class="line"><span class="comment">//    (_thr_sp(2) &lt;= -_lim_thr_max &amp;&amp; vel_error(2) &lt;= 0.0f)) &#123;</span></span><br><span class="line"><span class="comment">//vel_error(2) = 0.f;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在保持水平边距的同时，优先考虑垂直控制</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> Vector2f <span class="title">thrust_sp_xy</span><span class="params">(_thr_sp)</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> thrust_sp_xy_norm = thrust_sp_xy.<span class="built_in">norm</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> thrust_max_squared = math::<span class="built_in">sq</span>(_lim_thr_max);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 确定在保持水平边距的情况下还剩下多少垂直推力  这部分应该不重要</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> allocated_horizontal_thrust = math::<span class="built_in">min</span>(thrust_sp_xy_norm, _lim_thr_xy_margin);  <span class="comment">// 分配的水平推力</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> thrust_z_max_squared = thrust_max_squared - math::<span class="built_in">sq</span>(allocated_horizontal_thrust);    <span class="comment">// 推力 z 最大平方</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 饱和最大垂直推力  感觉没用</span></span><br><span class="line">    _thr_sp(<span class="number">2</span>) = math::<span class="built_in">max</span>(_thr_sp(<span class="number">2</span>), -<span class="built_in">sqrtf</span>(thrust_z_max_squared));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 确定优先垂直控制后还剩多少水平推力</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> thrust_max_xy_squared = thrust_max_squared - math::<span class="built_in">sq</span>(_thr_sp(<span class="number">2</span>));</span><br><span class="line"><span class="keyword">float</span> thrust_max_xy = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (thrust_max_xy_squared &gt; <span class="number">0</span>) &#123;</span><br><span class="line">thrust_max_xy = <span class="built_in">sqrtf</span>(thrust_max_xy_squared);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 水平方向饱和推力</span></span><br><span class="line"><span class="keyword">if</span> (thrust_sp_xy_norm &gt; thrust_max_xy) &#123;</span><br><span class="line">_thr_sp.<span class="built_in">xy</span>() = thrust_sp_xy / thrust_sp_xy_norm * thrust_max_xy;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 水平方向使用跟踪 Anti-Windup：在饱和期间，积分器用于使输出不饱和</span></span><br><span class="line"><span class="comment">// see Anti-Reset Windup for PID controllers, L.Rundqwist, 1990</span></span><br><span class="line">    <span class="comment">// 参见 PID 控制器的防复位饱和，L.Rundqwist，1990</span></span><br><span class="line"><span class="keyword">const</span> Vector2f acc_sp_xy_limited = <span class="built_in">Vector2f</span>(_thr_sp) * (CONSTANTS_ONE_G / _hover_thrust);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> arw_gain = <span class="number">2.f</span> / _gain_vel_p(<span class="number">0</span>);</span><br><span class="line">vel_error.<span class="built_in">xy</span>() = <span class="built_in">Vector2f</span>(vel_error) - (arw_gain * (<span class="built_in">Vector2f</span>(_acc_sp) - acc_sp_xy_limited));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保积分不会得到 NAN</span></span><br><span class="line">ControlMath::<span class="built_in">setZeroIfNanVector3f</span>(vel_error);</span><br><span class="line"><span class="comment">// 更新速度控制的组成部分</span></span><br><span class="line">_vel_int += vel_error.<span class="built_in">emult</span>(_gain_vel_i) * dt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 限制推力积分</span></span><br><span class="line">_vel_int(<span class="number">2</span>) = math::<span class="built_in">min</span>(<span class="built_in">fabsf</span>(_vel_int(<span class="number">2</span>)), CONSTANTS_ONE_G) * <span class="built_in">sign</span>(_vel_int(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="accelerationControl"><a href="#accelerationControl" class="headerlink" title="_accelerationControl"></a>_accelerationControl</h2><p>最终给出期望推力</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> PositionControl::_accelerationControl()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 假设在垂直方向上由于重力产生的标准加速度用于姿态生成</span></span><br><span class="line">Vector3f body_z = <span class="built_in">Vector3f</span>(-_acc_sp(<span class="number">0</span>), -_acc_sp(<span class="number">1</span>), CONSTANTS_ONE_G).<span class="built_in">normalized</span>();</span><br><span class="line">ControlMath::<span class="built_in">limitTilt</span>(body_z, <span class="built_in">Vector3f</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>), _lim_tilt);</span><br><span class="line"><span class="comment">// 假设悬停推力产生标准重力的比例推力</span></span><br><span class="line"><span class="keyword">float</span> collective_thrust = _acc_sp(<span class="number">2</span>) * (_hover_thrust / CONSTANTS_ONE_G) - _hover_thrust;</span><br><span class="line"><span class="comment">// Project thrust to planned body attitude</span></span><br><span class="line">collective_thrust /= (<span class="built_in">Vector3f</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>).<span class="built_in">dot</span>(body_z));</span><br><span class="line">collective_thrust = math::<span class="built_in">min</span>(collective_thrust, -_lim_thr_min);</span><br><span class="line">_thr_sp = body_z * collective_thrust;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> UAV Simulation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UAV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智能指针</title>
      <link href="2022/01/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
      <url>2022/01/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><p>​        用来托管自定义类型的对象，让对象进行自动释放</p><p> <a href="%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD.md">运算符重载.md</a> 里有相关内容</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 智能指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运算符重载</title>
      <link href="2022/01/14/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
      <url>2022/01/14/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="左移运算符重载"><a href="#左移运算符重载" class="headerlink" title="左移运算符重载"></a>左移运算符重载</h1><ul><li>必须写在写在全局函数中，如果重载时想访问类的私有成员，需要将全局函数作类的友元。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;cout, Person &amp;A) &#123;</span><br><span class="line">    cout &lt;&lt; A.mA;</span><br><span class="line">    <span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="加法运算符重载"><a href="#加法运算符重载" class="headerlink" title="加法运算符重载"></a>加法运算符重载</h1><ul><li>可以在成员函数进行重载，也可以在全局函数重载。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person <span class="keyword">operator</span>+(Person &amp;A, Person&amp; B) &#123;  <span class="comment">// 全局方式  ，局部只需要把参数改下，返回this指针就行</span></span><br><span class="line">Person temp;</span><br><span class="line">    temp.mA = A.mA + B.mA;</span><br><span class="line">    temp.mB = A.mB + B.mB;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="前置递增运算符重载"><a href="#前置递增运算符重载" class="headerlink" title="前置递增运算符重载"></a>前置递增运算符重载</h1><ul><li>可以在成员函数进行重载，也可以在全局函数重载。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInteger</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyInteger</span>() &#123;</span><br><span class="line">mNum = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MyInteger&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">        <span class="keyword">this</span>.mNum++;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mNum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyInteger&amp; <span class="keyword">operator</span>++(MyInteger&amp; A) &#123;</span><br><span class="line">    A.mNum++;</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="后置递增运算符重载"><a href="#后置递增运算符重载" class="headerlink" title="后置递增运算符重载"></a>后置递增运算符重载</h1><ul><li>可以在成员函数进行重载，也可以在全局函数重载。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInteger</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyInteger</span>() &#123;</span><br><span class="line">mNum = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MyInteger <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">        MyInteger tmp = *<span class="keyword">this</span>;</span><br><span class="line">        A.mNum++;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mNum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyInteger <span class="keyword">operator</span>++(MyInteger&amp; A, <span class="keyword">int</span>) &#123;</span><br><span class="line">    MyInteger tmp = A;</span><br><span class="line">    A.mNum++;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="指针运算符重载"><a href="#指针运算符重载" class="headerlink" title="指针运算符重载"></a>指针运算符重载</h1><h2 id="智能指针实现"><a href="#智能指针实现" class="headerlink" title="智能指针实现"></a>智能指针实现</h2><p>用来托管自定义类型的对象，让对象进行自动释放，new出来的对象自动释放。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;age：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;xigou&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 智能指针</span></span><br><span class="line"><span class="comment">// 用来托管自定义类型的对象，让对象进行自动释放</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">smartPointer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">smartPointer</span>(Person *person) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;person = person;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重载-&gt;让智能指针对象像Person *p一样使用</span></span><br><span class="line">    Person * <span class="keyword">operator</span>-&gt;() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;person;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  重载*</span></span><br><span class="line">    Person&amp; <span class="keyword">operator</span>*() &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>-&gt;person;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">smartPointer</span>(Person *person) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;person != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>-&gt;person;</span><br><span class="line">            <span class="keyword">this</span>-&gt;person = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Person *person;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">smartPointer <span class="title">sp</span><span class="params">(<span class="keyword">new</span> Person(<span class="number">10</span>))</span></span>;  <span class="comment">//  开辟到栈上，自动释放</span></span><br><span class="line">    sp-&gt;<span class="built_in">showAge</span>();  <span class="comment">// sp-&gt;-&gt;showAge(),  编译器优化了写法</span></span><br><span class="line">    </span><br><span class="line">    (*sp).<span class="built_in">showAge</span>();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h1><ul><li>系统默认提供给类的赋值运算符写法是简单的值拷贝。</li><li>如果有数据在堆区，可能会有深浅拷贝问题。</li><li>如果想链式编程需要返回return *this;</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">char</span>* name) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;pName = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(name) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;pName, name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;age：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> Person &amp; p) &#123;</span><br><span class="line">        <span class="comment">// 如果原来堆区有内容，先释放掉</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>-&gt;pName != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pName;</span><br><span class="line">            thsi-&gt;pName = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;pName = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(p.pName) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;pName, p.pName);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">Person</span>() &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>-&gt;pName != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pName;</span><br><span class="line">            thsi-&gt;pName = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span>* pName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;goudan&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;gousheng&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;&quot;</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    p3 = p2 = p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="运算符重载"><a href="#运算符重载" class="headerlink" title="[]运算符重载"></a>[]运算符重载</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;myArray[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="和-关系运算符重载"><a href="#和-关系运算符重载" class="headerlink" title="==和!=关系运算符重载"></a>==和!=关系运算符重载</h1><ul><li>类似加号运算符重载</li></ul><h1 id="函数调用运算符重载"><a href="#函数调用运算符重载" class="headerlink" title="函数调用运算符重载"></a>函数调用运算符重载</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">MyPrint <span class="title">myPrint</span><span class="params">()</span></span>;</span><br><span class="line"><span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);  <span class="comment">// 仿函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="amp-amp-和"><a href="#amp-amp-和" class="headerlink" title="&amp;&amp; 和 ||"></a>&amp;&amp; 和 ||</h1><ul><li>这两个不要重载，因为无法实现它们的短路规则。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 重载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>友元</title>
      <link href="2022/01/14/%E5%8F%8B%E5%85%83/"/>
      <url>2022/01/14/%E5%8F%8B%E5%85%83/</url>
      
        <content type="html"><![CDATA[<h1 id="友元目的"><a href="#友元目的" class="headerlink" title="友元目的"></a>友元目的</h1><p>​        访问类中的私有成员属性。</p><h1 id="三种友元"><a href="#三种友元" class="headerlink" title="三种友元"></a>三种友元</h1><ul><li><p>全局函数做友元函数，在类中写<code>friend void show();</code></p></li><li><p>整个类做友元类。在类中写<code>friend class Person;</code></p><ul><li>注意事项：<ul><li>友元关系不能被继承。</li><li>友元关系是单向的，类A是类B的朋友，但是类B不一定是类A的朋友。</li><li>友元关系不具有传递性。类B是类A的朋友，类C是类B的朋友，但是类C和类A不一定是朋友。</li></ul></li></ul></li><li><p>成员函数做友元函数，在类中写<code>friend void Person::show();</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> friend </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>空指针访问成员函数</title>
      <link href="2022/01/14/%E7%A9%BA%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/"/>
      <url>2022/01/14/%E7%A9%BA%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<ul><li>如果成员函数没有用到this，那么空指针可以直接访问。</li><li>如果成员函数用的this指针，需要加if判断，如果this为空，直接return。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;show&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shouAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; mAge &lt;&lt;  endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>() &#123;</span><br><span class="line">Person *p1 = <span class="literal">NULL</span>;</span><br><span class="line">    p1-&gt;<span class="built_in">show</span>();    <span class="comment">// 正常运行</span></span><br><span class="line">    p1-&gt;<span class="built_in">shouAge</span>();<span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存对齐</title>
      <link href="2022/01/14/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"/>
      <url>2022/01/14/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</url>
      
        <content type="html"><![CDATA[<h1 id="结构体内存对齐方式"><a href="#结构体内存对齐方式" class="headerlink" title="结构体内存对齐方式"></a>结构体内存对齐方式</h1><p>​        结构体大小不是个数据成员之和，而是按照一定的对齐数进行对齐存储，最后结构体的大小也是按照一定的对齐数进行对齐。</p><p><strong>对齐规则：</strong></p><ul><li><p>第一个成员在与结构体变量偏移量为0的地址。</p></li><li><p>char 偏移量必须为sizeof(char)即1的倍数 。</p></li><li><p>int 偏移量必须为sizeof(int)即4的倍数 。</p></li><li><p>float 偏移量必须为sizeof(float)即4的倍数 。</p></li><li><p>double 偏移量必须为sizeof(double)即8的倍数 。</p></li><li><p>short 偏移量必须为sizeof(short)即2的倍数 。</p></li><li><p> 结构体总的大小为默认对齐数（该结构中占用最大空间的类型所占用的字节数）的整数倍，所以在为最后一个成员变量申请空间后，还会根据需要自动填充空缺的字节。 </p></li></ul><p><strong>注意：</strong>当内存中的变量变换了顺序后，那么该结构体对象或者该类的对象所占内存空间也会发生变化。</p><p><strong>内存对齐计算方法：</strong></p><ul><li><p>看变量所在偏移地址是否为变量大小的整数倍。</p></li><li><p>看对齐后的总大小是否为最长变量的整数倍。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> dda;    <span class="comment">//偏移量为0，满足对齐方式，dda占用1个字节；</span></span><br><span class="line">    <span class="keyword">double</span> dda1; <span class="comment">//下一个可用的地址的偏移量为1，不是sizeof(double)=8的倍数，需要补足7个字节才能使偏移量变为8（满足对齐方式），因此VC自动填充7个字节，dda1存放在偏移量为8的地址上，它占用8个字节。</span></span><br><span class="line">    <span class="keyword">int</span> type;    <span class="comment">//下一个可用的地址的偏移量为16，是sizeof(int)=4的倍数，满足int的对齐方式，所以不需要VC自动填充，type存放在偏移量为16的地址上，它占用4个字节。</span></span><br><span class="line">    <span class="comment">//共占20个字节，不是默认偏移量（8）的整数倍，需要进行字节填充，最终占24个字节</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStruct1</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> d1;<span class="comment">//偏移量0，满足对齐方式，d1占用8个字节</span></span><br><span class="line">    <span class="keyword">char</span> d2;<span class="comment">//偏移量为8，满足对其方式（是1的倍数），占用1个字节</span></span><br><span class="line">    <span class="keyword">int</span> d3;<span class="comment">//偏移量为9，不满足对其方式（不是4的倍数），需要补3个字节，9+3+4=16</span></span><br><span class="line">    <span class="comment">//最终，占16个字节，是默认偏移量（8）的整数倍，不用补充字节</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(MyStruct) &lt;&lt; endl;  <span class="comment">// 24</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(MyStruct1) &lt;&lt; endl; <span class="comment">// 16</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="内存对齐原因"><a href="#内存对齐原因" class="headerlink" title="内存对齐原因"></a>内存对齐原因</h1><ul><li>平台的移植性好，并不是所有的硬件平台都能存放任意地址的数据，某些平台只能在某些地址访问特定类型的数据，否则会出现异常。</li><li>CPU处理效率高：CPU并不是把内存看成以字节为单位，而是以块为单位，CPU在读取内存的时候是一块一块读取的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 面经 </tag>
            
            <tag> 内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>this指针</title>
      <link href="2022/01/13/this%E6%8C%87%E9%92%88/"/>
      <url>2022/01/13/this%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<ul><li><p>this指针指向被调用的成员函数所属的对象。</p></li><li><p>this是一种隐含指针，它隐含于每个类的非静态成员函数中，静态成员函数内部没有this指针，因此静态成员函数不能操作非静态成员变量。</p></li><li><p>当形参和成员变量同名时，可用this指针区分。</p></li><li><p>在类的非静态成员函数中返回对象本身，可使用 return *this。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> this </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>static</title>
      <link href="2022/01/13/static/"/>
      <url>2022/01/13/static/</url>
      
        <content type="html"><![CDATA[<h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><ul><li>static作用于局部变量，改变局部变量的生存周期，使得该变量存在于定义后直到程序运行结束。</li><li>static作用于全局变量和函数，改变了全局变量作用域，使得全局变量只能在定义它的文件中使用，在源文件中不具有全局可见性。</li><li>static作用于类的成员变量和成员函数，使得类变量或者类成员函数和类有关，可以不定义类的对象就可以通过类访问这些静态成员。类的静态成员函数中只能访问静态成员变量或者静态成员函数，不能将静态成员函数定义成虚函数。</li></ul><h2 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h2><ul><li>静态成员变量，属于某个类，所有成员共享，即一个类不管创建多少对象，他们都共用一个静态数据。</li><li>静态变量，在编译阶段就分配空间，对象还没创建时就已经分配了空间。</li><li>静态数据成员不属于某个对象，在为对象分配空间中不包括静态成员所占空间。</li><li><font color=red>静态成员变量必须在类中声明，类外定义。</font></li><li>静态成员变量也有权限。</li></ul><h2 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h2><ul><li>静态成员函数可以在类内实现。</li><li>静态成员函数不可以访问普通的成员变量，可以访问静态成员变量</li><li>静态成员函数也有权限。</li><li>普通成员函数可以访问静态成员变量和静态成员函数。</li><li>静态成员函数不能是虚函数 。</li></ul><p><strong>为什么静态成员函数不能是虚函数：</strong></p><ul><li>静态成员函数不属于类中的任何一个对象和实例，属于类共有的函数，因此不能通过this指针访问，因为this指针指向的是每一个对象和实例，而虚函数的调用恰恰需要this指针。虚函数的类实例是通过this指针调用vptr指针，指向虚函数表，通过虚函数表找到需要调用的虚函数地址。this-&gt;vptr-&gt;vtabel-&gt;virtual 函数。</li></ul><h1 id="访问方式"><a href="#访问方式" class="headerlink" title="访问方式"></a>访问方式</h1><ul><li>通过对象访问</li><li>通过类名访问</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> m_Age; <span class="comment">// 类内声明</span></span><br><span class="line"><span class="keyword">int</span> m_A;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; m_A &lt;&lt; endl;  会报错，不能访问普通成员变量</span></span><br><span class="line">        cout &lt;&lt; m_other &lt;&lt; endl;  <span class="comment">// 可以访问静态成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_other;  <span class="comment">// 私有权限，类外不能访问，但是加上作用域可以在类外初始化</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Person::m_Age = <span class="number">10</span>;  <span class="comment">// 类外初始化</span></span><br><span class="line"><span class="keyword">int</span> Person::m_other = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Person p1;</span><br><span class="line">    Person p2;</span><br><span class="line">    p1.m_Age = <span class="number">20</span>;</span><br><span class="line">    p2.m_Age = <span class="number">30</span>;</span><br><span class="line">cout &lt;&lt; p1.m_Age &lt;&lt; endl;  <span class="comment">// 30</span></span><br><span class="line">    cout &lt;&lt; p2.m_Age &lt;&lt; endl;  <span class="comment">// 30</span></span><br><span class="line">cout &lt;&lt; Person::m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> static </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>explicit关键字</title>
      <link href="2022/01/12/explicit%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>2022/01/12/explicit%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<ul><li>在创建对象的时候会存在隐式类型转换，添加explicit关键字后不能进行隐式类型转换。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">MyClass p = <span class="number">10</span>;  <span class="comment">// 如果在类中添加了explicit关键字，这行报错，不能进行隐式类型转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> explicit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象的构造和析构</title>
      <link href="2022/01/12/%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84/"/>
      <url>2022/01/12/%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h1><ul><li>构造函数：没有返回值，没有void，类名相同，可以发生重载，可以有参数。</li><li>析构函数：没有返回值，没有void，函数名称：~类名，不可以重载，不可以有参数。</li><li>系统会默认调用构造函数和析构函数且只调用一次。</li><li>若程序员不提供构造和析构函数，系统默认提供空实现。</li><li>构造和析构必须写在public下才可以调用到。</li></ul><h1 id="构造函数的分类和调用"><a href="#构造函数的分类和调用" class="headerlink" title="构造函数的分类和调用"></a>构造函数的分类和调用</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li>按参数分类<ul><li>无参构造函数（默认构造函数，调用默认构造函数创建对象时不加“()”，Person p1() 会被认成函数声明）</li><li>有参构造函数</li></ul></li><li>按类型分类<ul><li>普通构造函数</li><li>拷贝构造函数（注意浅拷贝问题，参数要加const）</li></ul></li></ul><h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Person p1;      <span class="comment">// 默认构造</span></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">1</span>)</span></span>;   <span class="comment">// 有参构造</span></span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(p1)</span></span>;    <span class="comment">// 拷贝构造</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="number">100</span>);    <span class="comment">// 匿名对象，如果编译器发现匿名对象，那么在这行代码结束后就释放这个对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式法调用</span></span><br><span class="line">Person p4 = <span class="built_in">Person</span>(<span class="number">100</span>);</span><br><span class="line">Person p5 = <span class="built_in">Person</span>(p4);</span><br><span class="line"><span class="comment">// 不能用拷贝构造函数初始化匿名对象</span></span><br><span class="line"><span class="built_in">Person</span>(p5);    <span class="comment">// 如果这么写，编译器会认为成 Person p5； 对象的声明，但是可以写成右值</span></span><br><span class="line">Person p6 = <span class="built_in">Person</span>(p5);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式类型转换</span></span><br><span class="line">Person p7 = <span class="number">100</span>;  <span class="comment">// 相当于调用Person p7 = Person(100);</span></span><br><span class="line">Person p8 = p7;</span><br></pre></td></tr></table></figure><h1 id="拷贝构造函数的调用时机"><a href="#拷贝构造函数的调用时机" class="headerlink" title="拷贝构造函数的调用时机"></a>拷贝构造函数的调用时机</h1><ul><li>用已经创建好的对象来初始化新对象。</li><li>以值传递方式给函数参数传值。</li><li>以值方式返回局部对象。</li></ul><h1 id="构造函数的调用规则"><a href="#构造函数的调用规则" class="headerlink" title="构造函数的调用规则"></a>构造函数的调用规则</h1><ul><li><p>系统默认提供三个函数：默认构造函数、拷贝构造函数和析构函数。 其实四个，还有个operator=赋值运算符进行简单值传递。</p></li><li><p>当提供了有参的构造函数，那么系统不会给我们提供默认构造函数，仍提供默认的拷贝构造函数，进行简单的值拷贝。</p></li><li><p>当提供了拷贝构造函数，那么系统不会提供其他构造函数。</p></li></ul><h1 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h1><ul><li>系统默认提供的拷贝构造会进行简单的值拷贝。</li><li>如果属性里有指向堆区空间的数据，那么简单的浅拷贝会导致重复释放内存的异常。</li><li>解决上述问题需要自己提供拷贝构造函数进行深拷贝。</li></ul><h1 id="构造函数和析构函数的调用顺序（在类对象作为成员时）"><a href="#构造函数和析构函数的调用顺序（在类对象作为成员时）" class="headerlink" title="构造函数和析构函数的调用顺序（在类对象作为成员时）"></a>构造函数和析构函数的调用顺序（在类对象作为成员时）</h1><ul><li>首先对类内的类成员对象进行构造，然后在调用类的构造函数</li><li>析构的顺序正好和构造顺序相反</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">class <span class="title">Phone</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Phone</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Phone构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Phone</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Phone析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"><span class="function">class <span class="title">Game</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Game</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Game构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Game</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Game析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"><span class="function">class <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Person</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Phone phone;</span><br><span class="line">    Game game;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://s2.loli.net/2022/01/12/U6bW2kl7AvKzRyt.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 构造 </tag>
            
            <tag> 析构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++封装</title>
      <link href="2022/01/11/C++%E5%B0%81%E8%A3%85/"/>
      <url>2022/01/11/C++%E5%B0%81%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><ul><li>把变量（属性）和函数（操作）合成一个整体，封装在一个类中。</li><li>成员变量和成员函数是分开存储的。</li><li>对变量和函数进行访问控制。</li><li>空类大小为1。 </li><li>只有非静态成员变量属于对象。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="comment">// 注释为加了该行后类的大小。</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_A;         <span class="comment">// 非静态成员变量，属于对象，   大小为4</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;;  <span class="comment">// 非静态成员函数，不属于对象， 大小为4   是通过this指针区分不同对象调用</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_B;  <span class="comment">// 静态成员变量，不属于对象，   大小为4</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;&#125;; <span class="comment">// 静态成员函数，不属于对象 大小4</span></span><br><span class="line">    <span class="keyword">double</span> m_C;      <span class="comment">// 12 错误  大小为16， double占8，但是因为字节对齐，int占4个补齐8个</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="class和struct"><a href="#class和struct" class="headerlink" title="class和struct"></a>class和struct</h1><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul><li><p>struct和class其实一样，区别是默认权限不同，struct默认public，class默认private。</p></li><li><p>class可以使用模板，struct不可以。</p></li></ul><h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><ul><li>private：私有权限，类内可以访问，类外不可访问，子类也不可访问。</li><li>public：共有权限，类内外都可以访问。</li><li>protected：保护权限，类内可访问，当前类的子类可以访问，类外不可访问。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 封装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四旋翼建模</title>
      <link href="2021/11/30/%E5%9B%9B%E6%97%8B%E7%BF%BC%E5%BB%BA%E6%A8%A1/"/>
      <url>2021/11/30/%E5%9B%9B%E6%97%8B%E7%BF%BC%E5%BB%BA%E6%A8%A1/</url>
      
        <content type="html"><![CDATA[<p><font color=red><em><strong>以下内容源于知乎，参考链接如下</strong></em></font></p><p><a href="https://zhuanlan.zhihu.com/p/332625724">https://zhuanlan.zhihu.com/p/332625724</a></p><p>先给出四旋翼建模和底层飞控的整体结构图：</p><p><img src="https://pic2.zhimg.com/80/v2-b0c8a97ed2d7865cab0865dd9fd80e29_1440w.png" alt="img"></p><p>上层控制器给出底层的控制指令，例如轨迹规划、协同控制算法等都算是上层控制器。</p><h2 id="1-坐标系"><a href="#1-坐标系" class="headerlink" title="1. 坐标系"></a><strong>1. 坐标系</strong></h2><h2 id="1-1-坐标系定义"><a href="#1-1-坐标系定义" class="headerlink" title="1.1 坐标系定义"></a><strong>1.1 坐标系定义</strong></h2><p>坐标系定义是最基础的前提，因为所有的公式变量都是以坐标系为前提的。</p><p>对于四旋翼模型来说，需要两个坐标系：</p><ul><li>全局坐标系/大地坐标系/惯性坐标系，符号表示： <img src="https://www.zhihu.com/equation?tex=%5CSigma%5E%5Cmathrm%7Bg%7D" alt="[公式]">  - （NED北东地)</li><li>机体坐标系，符号表示： <img src="https://www.zhihu.com/equation?tex=%5CSigma%5E%5Cmathrm%7Bb%7D" alt="[公式]">   - （前右下)</li></ul><p>全局坐标系是固连在大地上的；机体坐标系是固连到四旋翼机体上的，所以如果有很多个四旋翼，也就有很多个机体坐标系。</p><p>全局坐标系的原点一般来说是定义在飞机起飞点附近，在近距离的飞行时，可以忽略地球的曲率。机体坐标系的原点定义是飞机的重心位置。</p><p>全局坐标系的x,y,z轴的正方向分别是北东地（NED），所以无人机向上飞，其z轴坐标是负数。</p><p>机体坐标系的 x,y,z 轴的正方向分别是前右下，也就是飞机的正前方是x轴的正方向。</p><p>按照以上定义，如果全局坐标系的原点设在起飞点，无人机起飞前的初始位置的摆放是正前方对应北向，那么初始时，这两个坐标系是重合的。</p><h2 id="1-2-坐标变换"><a href="#1-2-坐标变换" class="headerlink" title="1.2 坐标变换"></a><strong>1.2 坐标变换</strong></h2><p>首先定义3个旋转矩阵：</p><p><img src="https://s2.loli.net/2022/01/10/72nOzGvLXJqNhoy.png" alt="旋转矩阵.png"></p><p>分别是绕x,y,z轴旋转 <img src="https://www.zhihu.com/equation?tex=%5Ctheta" alt="[公式]"> 角的旋转矩阵。</p><ul><li><p>全局到机体坐标变换公式为：<img src="https://www.zhihu.com/equation?tex=P%5Eb=R%5E%7Bg2b%7D(P%5Eg-T_%7Bb%7D%5Eg)" alt="[公式]"></p><p>其中，</p></li><li><ul><li><img src="https://www.zhihu.com/equation?tex=P%5Eg" alt="[公式]"> 是全局坐标系下的点的坐标，</li><li><img src="https://www.zhihu.com/equation?tex=P%5Eb" alt="[公式]">  是同样的点在机体坐标系下的坐标；</li><li><img src="https://www.zhihu.com/equation?tex=R%5E%7Bg2b%7D=R_xR_yR_z" alt="[公式]"> </li><li>飞机角度为， <img src="https://www.zhihu.com/equation?tex=%5Ctheta_x=roll,+%5Ctheta_y=pitch,%5Ctheta_z=yaw" alt="[公式]"> </li><li><img src="https://www.zhihu.com/equation?tex=T_b%5Eg" alt="[公式]"> 为飞机全局坐标系下的位置。</li></ul></li><li><p>机体到全局坐标变换公式为： <img src="https://www.zhihu.com/equation?tex=P%5Eg=R%5E%7Bb2g%7DP%5Eb+T_b%5Eg" alt="[公式]"></p></li><li><ul><li>其中， <img src="https://www.zhihu.com/equation?tex=R%5E%7Bb2g%7D=(R%5E%7Bg2b%7D)%5E%7B-1%7D=R_zR_yR_x" alt="[公式]"> </li><li>飞机角度为 <img src="https://www.zhihu.com/equation?tex=%5Ctheta_x=-roll,+%5Ctheta_y=-pitch,%5Ctheta_z=-yaw" alt="[公式]"></li></ul></li></ul><p>坐标变换有两种变换方法：先平移后旋转；先旋转后平移。</p><p>上面全局到机体的变换是先平移后旋转的方式，而机体到全局的变换是先旋转后平移的方式。两种方式都可以。</p><p>注意上面的变换中，从全局到机体和从机体到全局的变换是互逆的，两个旋转矩阵也是互逆的。但是如果两种变换都是用同样的方式（比如先旋转后平移），那么两个旋转矩阵就不是互逆的了。</p><h2 id="1-3-坐标变换的通俗解释"><a href="#1-3-坐标变换的通俗解释" class="headerlink" title="1.3 坐标变换的通俗解释"></a><strong>1.3 坐标变换的通俗解释</strong></h2><p>这一节是一个非常通俗的坐标变换的解释，对坐标变换比较熟悉的读者就不需要看了。</p><p>可能刚开始接触坐标系转换的同学对各种旋转矩阵搞得很头疼，其实只要搞明白源头，搞明白为什么要进行坐标系变换，搞明白坐标系变换的本质，就不难理解了。</p><p>其实说白了，<strong>坐标系变换就是用不同的方式来表示同一个点</strong>。让我们首先通俗的讲一下这个事情，我想表示二维平面中某一个点，这时我可以用手指或者画一个箭头指向这个点，那你就知道了我想表达的这个点了。但是如果有很多点怎么办，我如果对每一个点都画个箭头，那么就太乱了，这时，坐标系就出现了。我可以首先建立一个坐标，确定了原点所在的位置和两个轴的方向，然后我把这个坐标系告诉你，这样咱俩都知道了同一个坐标系，以后再相互表达某些点的时候，只需要讲这些点的坐标就可以了，你可以根据坐标，在提前商量好的坐标系中快速地找到这些点。但是，如果你和我都有自己喜欢的坐标系，而且这两个坐标系不一样，不是同一个坐标系，那么我将某个点的坐标告诉你，你在你喜欢的坐标系上是无法准确找到这个点的，这时就需要坐标变换了。所以<strong>坐标变换就是用不同的坐标系去表达同一个点</strong>。</p><h2 id="2-四旋翼建模"><a href="#2-四旋翼建模" class="headerlink" title="2. 四旋翼建模"></a><strong>2. 四旋翼建模</strong></h2><h2 id="2-1-四旋翼的状态量"><a href="#2-1-四旋翼的状态量" class="headerlink" title="2.1 四旋翼的状态量"></a><strong>2.1 四旋翼的状态量</strong></h2><p>首先我们使用到的四旋翼的状态量有18个量：</p><ul><li>位置（全局坐标系）： <img src="https://www.zhihu.com/equation?tex=%5Cbold%7Bp%7D%5E%5Cmathrm%7Bg%7D=%5Bx,y,z%5D%5ET" alt="[公式]"> </li><li>速度（全局坐标系）： <img src="https://www.zhihu.com/equation?tex=%5Cbold%7Bv%7D%5E%5Cmathrm%7Bg%7D+=+%5Bv_x,v_y,v_z%5D%5ET" alt="[公式]"></li><li>加速度（全局坐标系）： <img src="https://www.zhihu.com/equation?tex=%5Cbold%7Ba%7D%5E%5Cmathrm%7Bg%7D=%5Ba_x,a_y,a_z%5D%5ET" alt="[公式]"> </li><li>姿态角： <img src="https://www.zhihu.com/equation?tex=%5CTheta+=%5B%5Cphi,%5Ctheta,%5Cpsi%5D%5ET" alt="[公式]"> , (roll, pitch, yaw)</li><li>机体旋转角速度： <img src="https://www.zhihu.com/equation?tex=%5Cbold%7B%5Comega%7D%5Eb=%5Bp,q,r%5D%5ET" alt="[公式]"> </li><li>机体旋转角加速度： <img src="https://www.zhihu.com/equation?tex=%5Cbold%7B%5Cdot%7B%5Comega%7D%7D%5Eb=%5B%5Cdot%7Bp%7D,%5Cdot%7Bq%7D,%5Cdot%7Br%7D%5D%5ET" alt="[公式]"> </li></ul><p>其中姿态角是机体坐标系相对于全局坐标系的三个欧拉角，机体角速度和机体角加速度都是机体坐标系下的。</p><h2 id="2-2-四旋翼6自由度模型-动力学模型与运动学模型"><a href="#2-2-四旋翼6自由度模型-动力学模型与运动学模型" class="headerlink" title="2.2 四旋翼6自由度模型 - 动力学模型与运动学模型"></a><strong>2.2 四旋翼6自由度模型 - 动力学模型与运动学模型</strong></h2><p>四旋翼非线性建模分为运动学模型和动力学模型两部分。6自由度模型的意思是四旋翼有6个自由度，分别是3个方向的移动和3个方向的转动。下面将6自由度模型的公式罗列出来，本文不进行细节方面详细的讲解，只讲明白怎么使用。</p><ul><li>运动学模型</li></ul><p><img src="https://s2.loli.net/2022/02/22/75BdQeb2DAxTisF.png" alt="image.png"></p><ul><li>动力学模型</li></ul><p><img src="https://s2.loli.net/2022/02/22/UhOFkGaCST2Xxdn.png" alt="image.png"></p><ul><li><p>其中符号的解释：</p><p>$$<br>p^g 和v^g 分别是飞机的全局位置和全局速度；<br>W是表示姿态角速率与机体角速度之间关系的矩阵；<br>$$</p><p><img src="https://s2.loli.net/2022/02/22/2KdeagCY8kDPrpo.png" alt="image.png"></p></li></ul><p>应避免 cosθ=0 ​的情况发生。<br>反过来可以得到：​ <img src="https://www.zhihu.com/equation?tex=%5Cbold%7B%5Comega%7D%5Eb=%5Cbold%7BW%7D%5E%7B-1%7D%5Cdot%7B%5CTheta%7D" alt="[公式]"><br>$$<br>θ是姿态角速率，w^b 是机体角速度<br>$$</p><p>$$<br>e^3 = [0,0,1]^T 表示单位列向量；<br>$$</p><p>$$<br>f是四个电机的拉力总和，方向沿机体坐标系z轴负方向；<br>$$</p><p>$$<br>J是四旋翼的惯性矩阵，J=diag(J_x,J_y,J_z)<br>$$</p><p>$$<br>G_a表示陀螺力矩，一般忽略不计；<br>$$</p><p>$$<br>\tau=[\tau_x,\tau_y,\tau_z]表示螺旋桨在机体轴上产生的外力矩。<br>$$</p><h2 id="2-3-四旋翼6自由度模型的使用"><a href="#2-3-四旋翼6自由度模型的使用" class="headerlink" title="2.3 四旋翼6自由度模型的使用"></a><strong>2.3 四旋翼6自由度模型的使用</strong></h2><p>有了6自由度模型，输入飞机的整体拉力（ f ）和3个方向的力矩（ τ ），再f加上上一时刻四旋翼的状态，就可以计算出下一时刻四旋翼的状态量（位置、速度、加速度、姿态角、机体角速率、机体角加速度)。</p><p>从写代码的计算过程来看，先使用动力学模型两个公式，输入拉力和力矩（ f , τ  ），计算飞机的加速度（ v’ ）和角加速度(ω’^b)，然后再使用运动学模型的两个公式，更新其他状态量。</p><h2 id="2-4-四旋翼电机模型"><a href="#2-4-四旋翼电机模型" class="headerlink" title="2.4 四旋翼电机模型"></a><strong>2.4 四旋翼电机模型</strong></h2><p>电机模型是用来对电机建模的，因为电机的响应非常快，所以可以忽略电机的延迟，等效认为对电机的转速指令能够瞬间达到。</p><p>四旋翼分为X型和十字型，分析过程相似，本文使用X型四旋翼来推导，</p><ul><li>四个电机的id号定义如下：(向上为前进方向)</li></ul><p><img src="https://pic2.zhimg.com/80/v2-1e5ef3aa664fe35bcddcbbff2e27a45d_1440w.jpg" alt="img"></p><ul><li><p>力、力矩与电机转速的转换如下：</p><p> <img src="https://s2.loli.net/2022/02/22/29pPwJF5frOHykY.png" alt="image.png"></p></li></ul><p>其中， l 为机体中心到任一电机的距离， Cτ 为拉力系数， C_M 为扭矩系数。    </p><h2 id="3-四旋翼底层飞控"><a href="#3-四旋翼底层飞控" class="headerlink" title="3. 四旋翼底层飞控"></a><strong>3. 四旋翼底层飞控</strong></h2><h2 id="3-1-四旋翼底层飞控结构图"><a href="#3-1-四旋翼底层飞控结构图" class="headerlink" title="3.1 四旋翼底层飞控结构图"></a><strong>3.1 四旋翼底层飞控结构图</strong></h2><p>一般四旋翼的底层飞控都是用PID控制器，我这里在内环姿态回路用了LQR控制器，底层控制器整体结构图如下：</p><p><img src="https://pic2.zhimg.com/80/v2-66e3d3bea01271615f2e0c07bd21ab25_1440w.jpg" alt="img"></p><h2 id="3-2-简化的线性模型"><a href="#3-2-简化的线性模型" class="headerlink" title="3.2 简化的线性模型"></a><strong>3.2 简化的线性模型</strong></h2><p>在设计控制器之前，首先要对6自由度非线性模型进行线性化，这样设计出来控制器以后，可以先用线性化的模型计算控制器的收敛性，以此判断控制设计的好不好。最后再用设计好的控制器去控制非线性模型。</p><ul><li><p>假设条件：</p></li><li><ul><li><p>动力学模型忽略 <img src="https://www.zhihu.com/equation?tex=-%5Cbold%7B%5Comega%7D%5Eb%5Ctimes(%5Cbold%7BJ%7D%5Ccdot%5Cbold%7B%5Comega%7D%5Eb)+%5Cbold%7BG%7D_a" alt="[公式]"> </p></li><li><p>俯仰角和滚转角都非常小：</p></li><li><ul><li> <img src="https://www.zhihu.com/equation?tex=%5Csin(%5Cphi)%5Capprox+%5Cphi" alt="[公式]"></li><li> <img src="https://www.zhihu.com/equation?tex=%5Ccos(%5Cphi)%5Capprox+1" alt="[公式]"></li><li> <img src="https://www.zhihu.com/equation?tex=%5Csin(%5Ctheta)%5Capprox+%5Ctheta" alt="[公式]"></li><li> <img src="https://www.zhihu.com/equation?tex=%5Ccos(%5Ctheta)%5Capprox+1" alt="[公式]"></li></ul></li><li><p>总拉力约等于四旋翼的重力： <img src="https://www.zhihu.com/equation?tex=f%5Capprox+mg" alt="[公式]"></p></li><li><p>此时，运动学模型中的 <img src="https://www.zhihu.com/equation?tex=%5Cbold%7BW%7D%5Capprox%5Cbold%7BI%7D_3" alt="[公式]"></p></li><li><p>此时，动力学模型中的 <img src="https://www.zhihu.com/equation?tex=%5Cbold%7BR%7D%5E%7Bb2g%7D%5Cbold%7Be%7D_3%5Capprox+%5Cleft%5B%5Cbegin%7Bmatrix%7D+%5Ctheta%5Ccos%5Cpsi+%5Cphi%5Csin%5Cpsi+%5C%5C+%5Ctheta%5Csin%5Cpsi-%5Cphi%5Ccos%5Cpsi+%5C%5C+1+%5Cend%7Bmatrix%7D%5Cright%5D" alt="[公式]"></p></li></ul></li></ul><p>最终，忽略高阶项，原始模型解耦为三个线性模型：水平位置通道模型、高度通道模型、姿态模型</p><ul><li><p>水平位置通道模型： <img src="https://s2.loli.net/2022/02/22/JIEMSCgb46ZY7fA.png" alt="image.png"></p><p>其中，     <img src="https://s2.loli.net/2022/02/22/MdJD4T1IXFOuV8x.png" alt="image.png"> </p></li><li><p>高度通道模型： <img src="https://s2.loli.net/2022/02/22/Ln92yV6XBsmFA7k.png" alt="image.png"></p></li><li><p>姿态模型： <img src="https://s2.loli.net/2022/02/22/yGmuEPFZJRWv5L3.png" alt="image.png"></p></li></ul><h2 id="3-3-外环PID控制器"><a href="#3-3-外环PID控制器" class="headerlink" title="3.3 外环PID控制器"></a><strong>3.3 外环PID控制器</strong></h2><p>外环PID分为水平和垂直两个解耦的控制器。</p><p><strong>外环水平通道PID控制器</strong></p><p>外环水平通道控制器有三种情况：输入指令可以是，位置、速度、加速度。</p><ul><li><p>输入：期望水平方向的指令（三选一）位置、速度、加速度， <img src="https://www.zhihu.com/equation?tex=(p_h)_%7Bcmd%7D=%5Bx_%7Bcmd%7D,y_%7Bcmd%7D%5D%5ET" alt="[公式]"> <img src="https://www.zhihu.com/equation?tex=(%5Cbold%7Bv%7D_h)_%7Bcmd%7D=%5B(v_x)_%7Bcmd%7D,(v_y)_%7Bcmd%7D%5D%5ET" alt="[公式]"> , <img src="https://www.zhihu.com/equation?tex=(a_h)_%7Bcmd%7D=%5B(a_x)_%7Bcmd%7D,(a_y)_%7Bcmd%7D%5D%5ET" alt="[公式]"> </p></li><li><p>输出（给内环）：期望俯仰和滚转姿态角 <img src="https://www.zhihu.com/equation?tex=%5Cphi_%7Bdes%7D,%5Ctheta_%7Bdes%7D" alt="[公式]"> </p></li><li><p>控制器设计：</p></li><li><ul><li><p>位置控制：</p></li><li><ul><li><img src="https://www.zhihu.com/equation?tex=(%5Cbold%7Bv%7D_h)_%7Bdes%7D=%5Cbold%7BK%7D_%7Bp_h%7D%5Cleft((%5Cbold%7Bp%7D_h)_%7Bcmd%7D-%5Cbold%7Bp%7D_h%5Cright)" alt="[公式]"> , P控制器， 其中 <img src="https://www.zhihu.com/equation?tex=(%5Cbold%7Bv%7D_h)_%7Bdes%7D" alt="[公式]"> 要限幅</li><li><img src="https://www.zhihu.com/equation?tex=(%5Cbold%7Ba%7D_h)_%7Bdes%7D=(%5Cbold%7BK%7D_%7B%5Cbold%7Bv%7D_hp%7D%5Cbold%7Be%7D_%7B%5Cbold%7Bv%7D_h%7D+%5Cbold%7BK%7D_%7B%5Cbold%7Bv%7D_hi%7D%5Cint%5Cbold%7Be%7D_%7B%5Cbold%7Bv%7D_h%7D+%5Cbold%7BK%7D_%7B%5Cbold%7Bv%7D_hd%7D%5Cdot%7B%5Cbold%7Be%7D%7D_%7B%5Cbold%7Bv%7D_h%7D)" alt="[公式]"> , PID控制器，一般用PI即可，其中 <img src="https://www.zhihu.com/equation?tex=(%5Cbold%7Ba%7D_h)_%7Bdes%7D" alt="[公式]"> 要限幅</li><li><img src="https://www.zhihu.com/equation?tex=(%5Cbold%7B%5CTheta%7D_h)_%7Bdes%7D=g%5E%7B-1%7D%5Cbold%7BA%7D_%5Cpsi%5E%7B-1%7D(-%5Cbold%7Ba%7D_h)_%7Bdes%7D" alt="[公式]"> , 其中 <img src="https://www.zhihu.com/equation?tex=(%5Cbold%7B%5CTheta%7D_h)_%7Bdes%7D" alt="[公式]"> 要限幅。</li><li>其中 <img src="https://www.zhihu.com/equation?tex=%5Cbold%7BK%7D_%7Bp_h%7D,%5Cbold%7BK%7D_%7B%5Cbold%7Bv%7D_hp%7D,%5Cbold%7BK%7D_%7B%5Cbold%7Bv%7D_hi%7D,%5Cbold%7BK%7D_%7B%5Cbold%7Bv%7D_hd%7D%5Cin+R%5E%7B2%5Ctimes2%7D" alt="[公式]"> 是系数;<img src="https://www.zhihu.com/equation?tex=%5Cbold%7Be%7D_%7B%5Cbold%7Bv%7D_h%7D=(%5Cbold%7Bv%7D_h)_%7Bdes%7D-%5Cbold%7Bv%7D_h" alt="[公式]"></li></ul></li><li><p>速度控制：</p></li><li><ul><li><img src="https://www.zhihu.com/equation?tex=+(%5Cbold%7Ba%7D_h)_%7Bdes%7D=(%5Cbold%7BK%7D_%7B%5Cbold%7Bv%7D_hp%7D%5Cbold%7Be%7D_%7B%5Cbold%7Bv%7D_h%7D+%5Cbold%7BK%7D_%7B%5Cbold%7Bv%7D_hi%7D%5Cint%5Cbold%7Be%7D_%7B%5Cbold%7Bv%7D_h%7D+%5Cbold%7BK%7D_%7B%5Cbold%7Bv%7D_hd%7D%5Cdot%7B%5Cbold%7Be%7D%7D_%7B%5Cbold%7Bv%7D_h%7D)" alt="[公式]"> , PID控制器，一般用PI即可，其中 <img src="https://www.zhihu.com/equation?tex=(%5Cbold%7Ba%7D_h)_%7Bdes%7D" alt="[公式]"> 要限幅</li><li><img src="https://www.zhihu.com/equation?tex=(%5Cbold%7B%5CTheta%7D_h)_%7Bdes%7D=-g%5E%7B-1%7D%5Cbold%7BA%7D_%5Cpsi%5E%7B-1%7D(%5Cbold%7Ba%7D_h)_%7Bdes%7D" alt="[公式]"> , 其中 <img src="https://www.zhihu.com/equation?tex=(%5Cbold%7B%5CTheta%7D_h)_%7Bdes%7D" alt="[公式]"> 要限幅。</li><li>其中， <img src="https://www.zhihu.com/equation?tex=%5Cbold%7BK%7D_%7B%5Cbold%7Bv%7D_hp%7D,%5Cbold%7BK%7D_%7B%5Cbold%7Bv%7D_hi%7D,%5Cbold%7BK%7D_%7B%5Cbold%7Bv%7D_hd%7D%5Cin+R%5E%7B2%5Ctimes2%7D" alt="[公式]"> 是系数; <img src="https://www.zhihu.com/equation?tex=%5Cbold%7Be%7D_%7B%5Cbold%7Bv%7D_h%7D=(%5Cbold%7Bv%7D_h)_%7Bcmd%7D-%5Cbold%7Bv%7D_h" alt="[公式]"> </li></ul></li><li><p>加速度控制：</p></li><li><ul><li><img src="https://www.zhihu.com/equation?tex=(%5Cbold%7B%5CTheta%7D_h)_%7Bdes%7D=-g%5E%7B-1%7D%5Cbold%7BA%7D_%5Cpsi%5E%7B-1%7D(%5Cbold%7Ba%7D_h)_%7Bcmd%7D" alt="[公式]"> , 其中 <img src="https://www.zhihu.com/equation?tex=(%5Cbold%7B%5CTheta%7D_h)_%7Bdes%7D" alt="[公式]"> 要限幅。</li></ul></li></ul></li><li><p>限幅：</p></li><li><ul><li>输入限幅： <img src="https://www.zhihu.com/equation?tex=%7C%7C(%5Cbold%7Bv%7D_h)_%7Bdes%7D%7C%7C%5Cle+%5Cmax+v_h" alt="[公式]"> </li><li>输出限幅： <img src="https://www.zhihu.com/equation?tex=%5Cphi_%7Bdes%7D,%5Ctheta_%7Bdes%7D%5Cle+%5Cmax+%5Ctheta" alt="[公式]"> </li></ul></li></ul><p><strong>外环高度通道PID控制器</strong></p><ul><li><p>输入：期望高度 <img src="https://www.zhihu.com/equation?tex=z_%7Bdes%7D" alt="[公式]"> </p></li><li><p>输出：拉力 <img src="https://www.zhihu.com/equation?tex=f_%7Bdes%7D" alt="[公式]"> </p></li><li><p>控制器设计： <img src="https://www.zhihu.com/equation?tex=f_%7Bdes%7D=m(g+k_%7Bv_zp%7De_%7Bv_z%7D+k_%7Bv_zi%7D%5Cint+e_%7Bv_z%7D)" alt="[公式]"></p><p>其中， ![[公式]](<a href="https://www.zhihu.com/equation?tex=k_%7Bv_zp%7Dk_%7Bv_zi%7D">https://www.zhihu.com/equation?tex=k_%7Bv_zp%7Dk_%7Bv_zi%7D</a> 是系数)   <img src="https://www.zhihu.com/equation?tex=e_%7Bv_z%7D=v_z-(v_z)_%7Bdes%7D%E6%98%AF%E9%80%9F%E5%BA%A6%E5%B7%AE" alt="[公式]"><br>其中， <img src="https://www.zhihu.com/equation?tex=(v_z)_%7Bdes%7D=-k_z(z-z_%7Bdes%7D)" alt="[公式]"> </p></li><li><p>限幅： <img src="https://www.zhihu.com/equation?tex=(v_z)_%7Bdes%7D%5Cle%5Cmax+z_v" alt="[公式]"> <img src="https://www.zhihu.com/equation?tex=f_%7Bdes%7D%5Cle%5Cmax+f" alt="[公式]"> </p></li></ul><h2 id="3-4-内环LQR控制器"><a href="#3-4-内环LQR控制器" class="headerlink" title="3.4 内环LQR控制器"></a><strong>3.4 内环LQR控制器</strong></h2><p><strong>输入输出</strong></p><ul><li>输入1（外环）：期望的俯仰滚转角， <img src="https://www.zhihu.com/equation?tex=%5Cphi_%7Bdes%7D,%5Ctheta_%7Bdes%7D" alt="[公式]"> </li><li>输入2：期望的偏航角 <img src="https://www.zhihu.com/equation?tex=%5Cpsi_%7Bdes%7D" alt="[公式]"> </li><li>输出：力矩， <img src="https://www.zhihu.com/equation?tex=%5Cbold%7B%5Ctau%7D_%7Bdes%7D" alt="[公式]"> </li></ul><p><strong>控制器设计</strong></p><ul><li><p>状态方程：</p><p><img src="https://s2.loli.net/2022/02/22/atgihfRAVu7x5Pe.png" alt="image.png"><br><img src="https://www.zhihu.com/equation?tex=%5Cdot%7Bx%7D=Ax+Bu" alt="[公式]"></p></li><li><p>其中， <img src="https://www.zhihu.com/equation?tex=x=%5B%5Cphi,%5Ctheta,%5Cpsi,p,q,r%5D%5ET" alt="[公式]"> </p><p><img src="https://www.zhihu.com/equation?tex=u=%5B%5Ctau_x,%5Ctau_y,%5Ctau_z%5D%5ET" alt="[公式]"> </p><p><img src="https://s2.loli.net/2022/02/22/8A1pEbxilICcTFe.png" alt="image.png"> </p><p><img src="https://www.zhihu.com/equation?tex=B=%5Cleft%5B%5Cbegin%7Bmatrix%7D%5Cbold%7B0%7D%5C%5C+%5Cbold%7BJ%7D%5E%7B-1%7D%5Cend%7Bmatrix%7D%5Cright%5D" alt="[公式]"></p></li><li><p>两个矩阵的参数选择： <img src="https://www.zhihu.com/equation?tex=Q=diag%5C%7B8,8,2,+2,+2,+0.1%5C%7D" alt="[公式]"> , <img src="https://www.zhihu.com/equation?tex=R=diag%5C%7B1,1,1%5C%7D" alt="[公式]"> </p></li><li><p>求中间矩阵 <img src="https://www.zhihu.com/equation?tex=P" alt="[公式]"> ，解方程： <img src="https://www.zhihu.com/equation?tex=A%5ETP+PA+Q-PBR%5E%7B-1%7DB%5ETP=0" alt="[公式]"> </p></li><li><p>解出系数矩阵 <img src="https://www.zhihu.com/equation?tex=K" alt="[公式]"> :  <img src="https://www.zhihu.com/equation?tex=K=R%5E%7B-1%7DB%5ETP" alt="[公式]"> </p></li><li><p>最后的解为：<br><img src="https://www.zhihu.com/equation?tex=%5Cbold%7B%5Ctau%7D_%7Bdes%7D=-K(x-x_%7Bdes%7D)" alt="[公式]"></p></li><li><p>限幅： <img src="https://www.zhihu.com/equation?tex=%5Cphi_%7Bdes%7D,%5Ctheta_%7Bdes%7D+%5Cle+%5Cmax%5Ctheta" alt="[公式]"> ,  <img src="https://www.zhihu.com/equation?tex=%5Ctau_%7Bdes%7D%5Cle+%5Cmax+%5Ctau" alt="[公式]"></p></li></ul><h2 id="4-四旋翼参数参考"><a href="#4-四旋翼参数参考" class="headerlink" title="4. 四旋翼参数参考"></a><strong>4. 四旋翼参数参考</strong></h2><p>下面列举的参数是我再仿真中用的参数，可以用来参考。</p><ul><li>参考3dr Robotics</li></ul><table><thead><tr><th>参数</th><th>数据 值/范围</th></tr></thead><tbody><tr><td>质量（kg）</td><td>1.4</td></tr><tr><td>轴距 (m)</td><td>0.56</td></tr><tr><td>转动惯量 (x,y,z) (kg/m^2)</td><td>[0.05,0.05,0.24]</td></tr><tr><td>滚转和俯仰角</td><td>-30 ~ 30</td></tr><tr><td>拉力 (N)</td><td>0 ~ 43.5</td></tr><tr><td>力矩 (x,y) (N.m)</td><td>-6.25 ~ 6.25</td></tr><tr><td>力矩 z</td><td>-2.25 ~ 2.25</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> UAV Simulation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UAV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>namespcae</title>
      <link href="2021/11/25/namespcae/"/>
      <url>2021/11/25/namespcae/</url>
      
        <content type="html"><![CDATA[<h1 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h1><ul><li>namespace用于解决命名冲突问题</li><li>namespace必须放在全局作用域下</li><li>命名空间下可以放变量、结构体、类、函数</li><li>命名空间可以嵌套命名空间</li><li>命名空间是开放的，可以随时往原来的命名空间添加内容</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A &#123;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> A &#123;  <span class="comment">// 此命名空间会和上面的命名空间合并</span></span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>无名/匿名命名空间相当与写了static，只能在当前文件内使用</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"><span class="keyword">int</span> m_A = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> m_B = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 相当于写了static int m_A; static int m_B;</span></span><br></pre></td></tr></table></figure><ul><li>命名空间可以起别名</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> veryLongName &#123;</span><br><span class="line">    <span class="keyword">int</span> m_A = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> test01 &#123;</span><br><span class="line"><span class="keyword">namespace</span> veryShortName = veryLongName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> namespace </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++面向对象</title>
      <link href="2021/11/25/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>2021/11/25/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p>面向对象编程的思想核心：功能分解，自上而下，逐层细化<font color=red>（程序=数据结构+算法）</font></p><h1 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h1><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>把客观事物封装成抽象的类。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>表达的是类之间的关系，对象可以继承另一个对象的特征和能力。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>一个接口，多种方法，程序在运行时才决定调用的方法。父类的指针或引用指向子类对象。</p><h1 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h1><ul><li><strong>面向过程：</strong>以事件为中心的编程思想，编程时把解决问题的步骤分析出来，然后用函数把这些步骤实现，在一步一步的具体步骤中按顺序调用函数。</li><li><strong>面向对象：</strong>把所有的事务看作对象，每个对象都有自己的属性和行为，对象和对象之间可以通过方法来交互，对象的抽象称为类。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="2021/11/24/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>2021/11/24/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>​        单例模式是一种软件设计模式，在它的核心结构中只包含一个被称为单例的特殊类，单例模式可以保证系统中一个类只有一个实例且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。如果希望系统中某个类的对象只能存在一个，用单例模式。</p><h1 id="静态成员实现单例模式"><a href="#静态成员实现单例模式" class="headerlink" title="静态成员实现单例模式"></a>静态成员实现单例模式</h1><ul><li>目的：为了让类中只有一个实例，实例不需要自己释放。</li><li>将默认构造和拷贝构造私有化。</li><li>内部维护一个对象指针。</li><li>私有化唯一指针。</li><li>对外提供getInstance方法来访问这个指针。</li><li>保证类中只能实例化唯一一个对象。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChairMan</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 构造函数进行私有化</span></span><br><span class="line">    <span class="built_in">ChairMan</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;creat ChairMan&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数也需要私有化</span></span><br><span class="line">    <span class="built_in">ChairMan</span>(<span class="keyword">const</span> ChairMan&amp;c)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> ChairMan * singleMan;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 提供get方法访问主席</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> ChairMan* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleMan;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ChairMan * ChairMan:;singleMan = <span class="keyword">new</span> ChairMan;  <span class="comment">// 静态变量编译阶段就创建</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ChairMan* cm1 = ChairMan::getInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果为：</span></span><br><span class="line"><span class="comment">// creat ChairMan</span></span><br><span class="line"><span class="comment">// main函数调用</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 单例模式 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>inline函数</title>
      <link href="2021/11/24/%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"/>
      <url>2021/11/24/%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="内联函数的引出–宏函数的缺陷"><a href="#内联函数的引出–宏函数的缺陷" class="headerlink" title="内联函数的引出–宏函数的缺陷"></a>内联函数的引出–宏函数的缺陷</h1><ul><li><p>第一个问题在c中也会出现的，宏看起来像一个函数调用，但是有一些隐藏的难以发现的错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MyAdd(int a, int b) a+b</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">MyAdd</span>(a, b) &lt;&lt; endl;  <span class="comment">// 输出30；</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">MyAdd</span>(a, b) * <span class="number">10</span> &lt;&lt; endl;  <span class="comment">// 预期结果300，但是输出210； </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MyCompare(int a, int b) a &gt; b ? a : b</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">MyCompare</span>(a, b); <span class="comment">// 输出 20；</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">MyCompare</span>(++a, b); <span class="comment">// 预期21，输出22；</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>第二个问题是C++特有的，预处理器不能访问类的成员，所以预处理宏不能用作类的成员函数。</p></li><li><p>宏函数没有作用域。</p></li></ul><h1 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h1><ul><li>内联函数是一个真正的函数。</li><li>内联函数的声明和实现都需要加inline，否则会被认为成普通函数处理。</li><li>内联函数相当于空间换时间。</li><li>类内部的成员函数，默认前面会加inline关键字，即如果函数定义在类内部，自动成为内联函数<font color=blue>（同样受到最后一条的限制）</font>。</li><li>注意即使加了inline也不一定会变成内联函数，以下情况不会变成inline：<ul><li>不能存在任何形式的循环语句；</li><li>不能存在过多的条件判断语句；</li><li>函数体不能过于庞大；</li><li>不能对函数进行取址操作；</li></ul></li></ul><p><font color=red>内联函数只是相当于给了编译器一个建议，但是编译器不一定会接受。</font></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> inline </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="2021/11/13/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>2021/11/13/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>并查集主要用于解决一些<strong>元素分组</strong>的问题。它管理一系列<strong>不相交的集合</strong>，并支持两种操作：</p><ul><li><strong>合并</strong>（Union）：把两个不相交的集合合并为一个集合。</li><li><strong>查询</strong>（Find）：查询两个元素是否在同一个集合中。</li></ul><p>元素之间具有<strong>传递性</strong>的关系以及<strong>只考虑连通性</strong>不考虑距离时，可考虑使用并查集。</p><h1 id="并查集的简介与实现"><a href="#并查集的简介与实现" class="headerlink" title="并查集的简介与实现"></a>并查集的简介与实现</h1><p><font color=red>/<em><strong>以下内容源于知乎，原文链接在末尾</strong></em>/</font></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>并查集的重要思想在于，<strong>用集合中的一个元素代表集合</strong>。我曾看过一个有趣的比喻，把集合比喻成<strong>帮派</strong>，而代表元素则是<strong>帮主</strong>。接下来我们利用这个比喻，看看并查集是如何运作的。</p><p><img src="https://pic4.zhimg.com/v2-09fa3fa35e5411444b327d9cb9a31057_r.jpg"></p><p>最开始，所有大侠各自为战。他们各自的帮主自然就是自己。<em>（对于只有一个元素的集合，代表元素自然是唯一的那个元素）</em></p><p>现在1号和3号比武，假设1号赢了（这里具体谁赢暂时不重要），那么3号就认1号作帮主<em>（合并1号和3号所在的集合，1号为代表元素）</em>。</p><p><img src="https://pic4.zhimg.com/v2-3bf6c1a6ecf87fa93f4dbab2012446c7_r.jpg" alt="img"></p><p>xxxxxxxxxx class ChairMan {private:    // 构造函数进行私有化    ChairMan() {        cout &lt;&lt; “creat ChairMan” &lt;&lt; endl;    }​    // 拷贝构造函数也需要私有化    ChairMan(const ChairMan&amp;c){}​    static ChairMan * singleMan;​public:    // 提供get方法访问主席    static ChairMan* getInstance() {        return singleMan;    }};​ChairMan * ChairMan:;singleMan = new ChairMan;  // 静态变量编译阶段就创建​void test01() {    ChairMan* cm1 = ChairMan::getInstance;}​int main() {    cout &lt;&lt; “main函数调用” &lt;&lt; endl;    test01();    return 0;}​// 输出结果为：// creat ChairMan// main函数调用c++</p><p><img src="https://pic4.zhimg.com/80/v2-be12a6c795572d2acd77dcd49de35127_720w.jpg"></p><p>现在我们假设4、5、6号也进行了一番帮派合并，江湖局势变成下面这样：</p><p><img src="https://pic1.zhimg.com/80/v2-3c353bc781c7f3553079d541a9cfdc28_720w.jpg" alt="img"></p><p>现在假设2号想与6号比，跟刚刚说的一样，喊帮主1号和4号出来打一架（帮主真辛苦啊）。1号胜利后，4号认1号为帮主，当然他的手下也都是跟着投降了。</p><p><img src="https://pic3.zhimg.com/80/v2-6362d8b13705d5ba17b19cdeee453022_720w.jpg" alt="img"></p><p>好了，比喻结束了。如果你有一点图论基础，相信你已经觉察到，这是一个<strong>树</strong>状的结构，要寻找集合的代表元素，只需要一层一层往上访问<strong>父节点</strong>（图中箭头所指的圆），直达树的<strong>根节点</strong>（图中橙色的圆）即可。根节点的父节点是它自己。我们可以直接把它画成一棵树：</p><p><img src="https://pic2.zhimg.com/80/v2-cca3ddf5806a221201ed78caf1d27041_720w.jpg" alt="img"></p><p>用这种方法，我们可以写出最简单版本的并查集代码。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fa[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        fa[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如有编号为1, 2, 3, …, n的n个元素，我们用一个数组fa[]来存储每个元素的父节点（因为每个元素有且只有一个父节点，所以这是可行的）。一开始，我们先将它们的父节点设为自己。</p><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x] == x)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们用递归的写法实现对代表元素的查询：一层一层访问父节点，直至根节点（根节点的标志就是父节点是本身）。要判断两个元素是否属于同一个集合，只需要看它们的根节点是否相同即可。</p><h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fa[find(i)] = find(j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合并操作也是很简单的，先找到两个集合的代表元素，然后将前者的父节点设为后者即可。当然也可以将后者的父节点设为前者，这里暂时不重要。本文末尾会给出一个更合理的比较方法。</p><h2 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h2><p>​    最简单的并查集效率是比较低的。例如，来看下面这个场景：</p><p><img src="https://pica.zhimg.com/v2-49b5dd7af650192373e96d29f9c4b8cf_720w.jpg?source=3af55fa1" alt="img"><img src="https://pica.zhimg.com/80/v2-49b5dd7af650192373e96d29f9c4b8cf_720w.jpg?source=3af55fa1" alt="img"></p><p>​    现在我们要merge(2,3)，于是从2找到1，fa[1]=3，于是变成了这样：</p><p><img src="https://pica.zhimg.com/v2-6f85fc7c5578aa20400ac56f0da31e37_720w.jpg?source=3af55fa1" alt="img"><img src="https://pica.zhimg.com/80/v2-6f85fc7c5578aa20400ac56f0da31e37_720w.jpg?source=3af55fa1" alt="img"></p><p>​    然后我们又找来一个元素4，并需要执行merge(2,4)：</p><p><img src="https://pic2.zhimg.com/v2-1d3ef8a42d424cbec76135ce8a494ff7_720w.jpg?source=3af55fa1" alt="img"><img src="https://pic2.zhimg.com/80/v2-1d3ef8a42d424cbec76135ce8a494ff7_720w.jpg?source=3af55fa1" alt="img"></p><p>​        从2找到1，再找到3，然后fa[3]=4，于是变成了这样：</p><p><img src="https://pica.zhimg.com/v2-23c367515ace6fc0603692dfd865849f_720w.jpg?source=3af55fa1" alt="img"><img src="https://pica.zhimg.com/80/v2-23c367515ace6fc0603692dfd865849f_720w.jpg?source=3af55fa1" alt="img"></p><p>​    大家应该有感觉了，这样可能会形成一条长长的<strong>链</strong>，随着链越来越长，我们想要从底部找到根节点会变得越来越难。</p><p>​    怎么解决呢？我们可以使用<strong>路径压缩</strong>的方法。既然我们只关心一个元素对应的<strong>根节点</strong>，那我们希望每个元素到根节点的路径尽可能短，最好只需要一步，像这样：</p><p><img src="https://pic3.zhimg.com/v2-c2f835398a3e54d8209bf5e034ac6820_720w.jpg?source=3af55fa1" alt="img"><img src="https://pic3.zhimg.com/80/v2-c2f835398a3e54d8209bf5e034ac6820_720w.jpg?source=3af55fa1" alt="img"></p><p>​    其实这说来也很好实现。只要我们在查询的过程中，<strong>把沿途的每个节点的父节点都设为根节点</strong>即可。下一次再查询时，我们就可以省很多事。这用递归的写法很容易实现：</p><h3 id="合并（路径压缩）"><a href="#合并（路径压缩）" class="headerlink" title="合并（路径压缩）"></a>合并（路径压缩）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == fa[x])</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        fa[x] = find(fa[x]);  <span class="comment">//父节点设为根节点</span></span><br><span class="line">        <span class="keyword">return</span> fa[x];         <span class="comment">//返回父节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    以上代码常常简写为一行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == fa[x] ? x : (fa[x] = find(fa[x]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    注意赋值运算符=的优先级没有三元运算符?:高，这里要加括号。</p><p>​    路径压缩优化后，并查集的时间复杂度已经比较低了，绝大多数不相交集合的合并查询问题都能够解决。然而，对于某些时间卡得很紧的题目，我们还可以进一步优化。</p><hr><h2 id="按秩合并"><a href="#按秩合并" class="headerlink" title="按秩合并"></a>按秩合并</h2><p>​    有些人可能有一个误解，以为路径压缩优化后，并查集始终都是一个<strong>菊花图</strong>（只有两层的树的俗称）。但其实，由于路径压缩只在查询时进行，也只压缩一条路径，所以并查集最终的结构仍然可能是比较复杂的。例如，现在我们有一棵较复杂的树需要与一个单元素的集合合并：</p><p><img src="https://pic3.zhimg.com/v2-d3ff42bb79a6bc751f47daf3fc70e0d9_720w.jpg?source=3af55fa1" alt="img"><img src="https://pic3.zhimg.com/80/v2-d3ff42bb79a6bc751f47daf3fc70e0d9_720w.jpg?source=3af55fa1" alt="img"></p><p>​    假如这时我们要merge(7,8)，如果我们可以选择的话，是把7的父节点设为8好，还是把8的父节点设为7好呢？</p><p>​    当然是后者。因为如果把7的父节点设为8，会使树的<strong>深度</strong>（树中最长链的长度）加深，原来的树中每个元素到根节点的距离都变长了，之后我们寻找根节点的路径也就会相应变长。虽然我们有路径压缩，但路径压缩也是会消耗时间的。而把8的父节点设为7，则不会有这个问题，因为它没有影响到不相关的节点。</p><p><img src="https://pica.zhimg.com/v2-96fbb25365b43f0a109bec6d55b3b899_720w.jpg?source=3af55fa1" alt="img"><img src="https://pica.zhimg.com/80/v2-96fbb25365b43f0a109bec6d55b3b899_720w.jpg?source=3af55fa1" alt="img"></p><p>​    这启发我们：我们应该把简单的树往复杂的树上合并，而不是相反。因为这样合并后，到根节点距离变长的节点个数比较少。</p><p>​    我们用一个数组rank[]记录每个根节点对应的树的深度（如果不是根节点，其rank相当于以它作为根节点的<strong>子树</strong>的深度）。一开始，把所有元素的rank（<strong>秩</strong>）设为1。合并时比较两个根节点，把rank较小者往较大者上合并。</p><p>路径压缩和按秩合并如果一起使用，时间复杂度接近 <img src="https://www.zhihu.com/equation?tex=O(n)" alt="[公式]"> ，但是很可能会破坏rank的准确性。</p><h3 id="初始化（按秩合并）"><a href="#初始化（按秩合并）" class="headerlink" title="初始化（按秩合并）"></a>初始化（按秩合并）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">        rank[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并（按秩合并）"><a href="#合并（按秩合并）" class="headerlink" title="合并（按秩合并）"></a>合并（按秩合并）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = find(i), y = find(j);    <span class="comment">//先找到两个根节点</span></span><br><span class="line">    <span class="keyword">if</span> (rank[x] &lt;= rank[y])</span><br><span class="line">        fa[x] = y;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fa[y] = x;</span><br><span class="line">    <span class="keyword">if</span> (rank[x] == rank[y] &amp;&amp; x != y)</span><br><span class="line">        rank[y]++;                   <span class="comment">//如果深度相同且根节点不同，则新的根节点的深度+1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    为什么深度相同，新的根节点深度要+1？如下图，我们有两个深度均为2的树，现在要merge(2,5)：</p><p><img src="https://pic1.zhimg.com/v2-de356190829600f438058e8615c7a5ac_720w.jpg?source=3af55fa1" alt="img"><img src="https://pic1.zhimg.com/80/v2-de356190829600f438058e8615c7a5ac_720w.jpg?source=3af55fa1" alt="img"></p><p>​    这里把2的父节点设为5，或者把5的父节点设为2，其实没有太大区别。我们选择前者，于是变成这样：</p><p><img src="https://pic3.zhimg.com/v2-a829932f008f000440942cb8df393662_720w.jpg?source=3af55fa1" alt="img"><img src="https://pic3.zhimg.com/80/v2-a829932f008f000440942cb8df393662_720w.jpg?source=3af55fa1" alt="img"></p><p>​        显然树的深度增加了1。另一种合并方式同样会让树的深度+1。</p><p><a href="https://zhuanlan.zhihu.com/p/93647900/">点我！！这是原文！！！！！！！！！！</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PX4、ROS、Gazebo安装</title>
      <link href="2021/11/03/PX4%E3%80%81ROS%E3%80%81Gazebo%E5%AE%89%E8%A3%85/"/>
      <url>2021/11/03/PX4%E3%80%81ROS%E3%80%81Gazebo%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="安装指南"><a href="#安装指南" class="headerlink" title="安装指南"></a>安装指南</h1><h2 id="前置步骤"><a href="#前置步骤" class="headerlink" title="前置步骤"></a>前置步骤</h2><h3 id="ubuntu换源："><a href="#ubuntu换源：" class="headerlink" title="ubuntu换源："></a>ubuntu换源：</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure><ul><li>以下几个源任选</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#  阿里镜像源</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 清华镜像源</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>更新</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update &amp;&amp; sudo apt-get upgrade</span><br></pre></td></tr></table></figure><h3 id="科学上网"><a href="#科学上网" class="headerlink" title="科学上网"></a>科学上网</h3><p>主机全局代理+虚拟机nat模式+虚拟机代理</p><h2 id="正式步骤"><a href="#正式步骤" class="headerlink" title="正式步骤"></a>正式步骤</h2><h3 id="ROS-MAVROS-Gazebo"><a href="#ROS-MAVROS-Gazebo" class="headerlink" title="ROS+MAVROS+Gazebo"></a>ROS+MAVROS+Gazebo</h3><ol><li><p>获取快速安装脚本，可能出现网络问题，自行百度，科学上网多试几次，换手机网可行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/PX4/Devguide/master/build_scripts/ubuntu_sim_ros_melodic.sh</span><br></pre></td></tr></table></figure></li><li><p>在脚本目录下运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash ubuntu_sim_ros_melodic.sh</span><br></pre></td></tr></table></figure><p>在运行过程中报错</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error downloading <span class="string">&#x27;install_geographiclib_datasets.sh&#x27;</span>. Sorry but I cannot proceed further :(</span><br></pre></td></tr></table></figure><p><a href="https://gitee.com/MrZhaosx/geographic-lib">https://gitee.com/MrZhaosx/geographic-lib</a></p><p>将链接中三个文件夹下载拷贝到 <strong>/usr/share/GeographicLib</strong> 文件夹下面，不能直接拖拽，先放到桌面用命令行sudo操作</p><p>然后运行 </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./install_geographiclib_datasets.sh</span><br></pre></td></tr></table></figure></li></ol><h3 id="PX4"><a href="#PX4" class="headerlink" title="PX4"></a>PX4</h3><ol><li><p>下载PX4源码</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/PX4/PX4-Autopilot.git --recursive</span><br></pre></td></tr></table></figure></li><li><p>运行ubuntu.sh，如果需要nuttx把–no-nuttx去除即可</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash ./PX4-Autopilot/Tools/setup/ubuntu.sh --no-nuttx</span><br></pre></td></tr></table></figure></li><li><p>重启</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> UAV Simulation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gazebo </tag>
            
            <tag> PX4 </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gazebo问题汇总</title>
      <link href="2021/09/24/Gazebo%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
      <url>2021/09/24/Gazebo%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="问题描述1"><a href="#问题描述1" class="headerlink" title="问题描述1"></a>问题描述1</h1><p><img src="https://i.loli.net/2021/09/24/FWRNOJ7iPm6Et5U.png" alt="image.png"></p><h1 id="解决方案1"><a href="#解决方案1" class="headerlink" title="解决方案1"></a>解决方案1</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unset LIBGL_ALWAYS_INDIRECT</span><br></pre></td></tr></table></figure><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>gazebo在Ardupilot下模型加载慢</p><p><img src="https://i.loli.net/2021/09/24/gRT3DWJmY69CUnt.png" alt="image.png"></p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>提前下载模型后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /usr/share/gazebo/setup.sh</span><br></pre></td></tr></table></figure><h1 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h1><p>运行roslaunch 文件报错</p><p><img src="https://i.loli.net/2021/09/24/vJWqMsb6Gx5CitL.png" alt="image.png"></p><h1 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br><span class="line">把自己创建的catwin那个注释掉</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> UAV Simulation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gazebo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红黑树</title>
      <link href="2021/08/23/%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%88%EF%BC%89/"/>
      <url>2021/08/23/%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><ul><li>每个节点不是红色就是黑色。</li><li>根节点是黑色的。</li><li>红色节点的子节点必须是黑色（不能有连续的红节点）。</li><li>从根节点到NULL的任何路径所含的黑色节点数目相同。</li><li>叶子节点是黑色的NULL节点（不是二叉树中的叶节点，是其子节点NULL）。</li></ul><p><img src="https://i.loli.net/2021/08/23/9tClpNzVPEginvd.png" alt="image.png"></p><p><strong>为什么有了二叉查找树/平衡树还需要红黑树</strong></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 红黑树 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>map, set</title>
      <link href="2021/08/23/map%EF%BC%8Cset/"/>
      <url>2021/08/23/map%EF%BC%8Cset/</url>
      
        <content type="html"><![CDATA[<h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p>​    map是关键字-值对的集合，又名关联数组。无重复关键字。</p><h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><p>​    set是关键字的简单集合。无重复关键字。</p><h1 id="map和set的区别"><a href="#map和set的区别" class="headerlink" title="map和set的区别"></a>map和set的区别</h1><ul><li><p>相同点：map和set都是 C++的关联容器，底层都是红黑树实现的。</p></li><li><p>元素：map的元素是key-value（键值-实值）对，关键字起到索引的作用，值表示与索引相关联的数据；set的元素是键值，没有实值。</p></li><li><p>迭代器：map的迭代器既不是const也不是mutable，map允许修改value实值，不允许修改key键值；set迭代器是const的，不允许修改键值。其原因在于map和 set是根据关键字来保证其有序性的，如果允许修改键值，那么首先要删除该键，调节平衡，然后再插入修改后的键值，调节平衡，这样一来破坏了map和set的结构，导致iterator失效。</p></li><li><p>下标操作：map支持下标操作，用关键字作为下标访问关键字对应的值，如果关键字不存在，它会自动将该关键字插入；set不支持下标操作。</p></li></ul><h1 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h1><p>​    用哈希函数组织的无序map。</p><h1 id="unordered-set"><a href="#unordered-set" class="headerlink" title="unordered_set"></a>unordered_set</h1><p>​    用哈希函数组织的无序set。</p><h1 id="unordered-map和map的区别"><a href="#unordered-map和map的区别" class="headerlink" title="unordered_map和map的区别"></a>unordered_map和map的区别</h1><ul><li>底层实现不同：<ul><li>unordered_map底层实现是一个哈希表，元素无序。</li><li>map底层实现是红黑树，其内部所有的元素都是有序的，因此对map的所有操作，其实都是对红黑树的操作。</li></ul></li><li>优缺点：<ul><li>unordered_map：查找效率高；但是建立哈希表比较耗费时间。</li><li>map：内部元素有序，查找和删除操作又是logn的时间复杂度；但是维护红黑树的存储结构需要占用一定的内存空间。</li></ul></li><li>适用情况：<ul><li>对于要求内部元素有序的用map，对于要求查找效率的用unordered_map。</li></ul></li></ul><h1 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a>multimap</h1><p>​    关键字可重复出现的map。</p><h1 id="multiset"><a href="#multiset" class="headerlink" title="multiset"></a>multiset</h1><p>​    关键字可重复出现的set。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> map </tag>
            
            <tag> set </tag>
            
            <tag> unordered_map </tag>
            
            <tag> unordered_set </tag>
            
            <tag> multiset </tag>
            
            <tag> multimap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迭代和递归</title>
      <link href="2021/08/13/%E8%BF%AD%E4%BB%A3%E5%92%8C%E9%80%92%E5%BD%92/"/>
      <url>2021/08/13/%E8%BF%AD%E4%BB%A3%E5%92%8C%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>​    重复调用函数自身实现循环称为递归。典型问题：斐波那契数列，阶乘（n!）。</p><p>​    构成递归需具备的条件：</p><ol><li>子问题需与原问题为同样的事，且更为简单。</li><li>不能无限制的调用本身，需要有出口。</li></ol><h1 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h1><p>​    迭代法是一种不断用变量的旧值递推新值的过程，典型问题：斐波那契数列，背包问题。</p><h1 id="二者关系与区别"><a href="#二者关系与区别" class="headerlink" title="二者关系与区别"></a>二者关系与区别</h1><p>​    从概念上讲，递归就是指程序调用自身的编程思想，即一个函数调用本身；迭代是利用已知的变量值，根据递推公式不断演进得到新变量值的编程思想。简单的说，递归是重复调用函数自身实现循环。迭代时函数内某段代码实现循环。</p><p>​    迭代与普通循环的区别：迭代时，循环代码中参与运算的变量同时是保存结果的变量，当前保存的结果作为下一次循环计算的初始值。</p><p>​    递归与普通循环的区别：递归是有去无回，而递归是有去有回。</p><p>xxxxxxxxxx class ChairMan {private:    // 构造函数进行私有化    ChairMan() {        cout &lt;&lt; “creat ChairMan” &lt;&lt; endl;    }​    // 拷贝构造函数也需要私有化    ChairMan(const ChairMan&amp;c){}​    static ChairMan * singleMan;​public:    // 提供get方法访问主席    static ChairMan* getInstance() {        return singleMan;    }};​ChairMan * ChairMan:;singleMan = new ChairMan;  // 静态变量编译阶段就创建​void test01() {    ChairMan* cm1 = ChairMan::getInstance;}​int main() {    cout &lt;&lt; “main函数调用” &lt;&lt; endl;    test01();    return 0;}​// 输出结果为：// creat ChairMan// main函数调用c++</p><p>​    </p><p><a href="https://blog.csdn.net/gaoyu1253401563/article/details/82384958?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control">参考链接1</a>          <a href="https://blog.csdn.net/qq_40817827/article/details/89950325">参考链接2</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 迭代 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git权限管理</title>
      <link href="2021/07/28/git%E6%9D%83%E9%99%90/"/>
      <url>2021/07/28/git%E6%9D%83%E9%99%90/</url>
      
        <content type="html"><![CDATA[<p>​    运行Ardupilot出现permission denied错误解决方案：    git config core.filemode false + chmod</p><h3 id="忽略文件权限"><a href="#忽略文件权限" class="headerlink" title="忽略文件权限"></a>忽略文件权限</h3><p>​    有很多时候我们并不需要过多关注文件权限，特别是部署时会重置文件权限的情况，在开发时由于各环境不同，总是有文件权限的冲突，此时，我们可以忽略文件变更追踪。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config core.filemode <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>可以禁止 <code>Git</code> 跟踪文件权限。</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存管理</title>
      <link href="2021/07/23/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>2021/07/23/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="C-memory-primitives"><a href="#C-memory-primitives" class="headerlink" title="C++ memory primitives"></a>C++ memory primitives</h1><table><thead><tr><th>分配</th><th>释放</th><th>类属</th><th>可否重载</th></tr></thead><tbody><tr><td>malloc()</td><td>free()</td><td>C函数</td><td>不可</td></tr><tr><td>new</td><td>delete</td><td>C++表达式（expressions）</td><td>不可</td></tr><tr><td>::operator new()</td><td>::operator delete()</td><td>C++函数</td><td>可</td></tr><tr><td>allocator<T>:: allocate()</td><td>allocator<T>:: deallocate()</td><td>C++标准库</td><td>可自由设计并搭配任何容器</td></tr></tbody></table><p>各用法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* malloc() and free() */</span></span><br><span class="line"><span class="keyword">void</span>* p1 = <span class="built_in">malloc</span>(<span class="number">512</span>);  <span class="comment">// 分配512个bytes</span></span><br><span class="line"><span class="built_in">free</span>(p1);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* new and delete expression */</span></span><br><span class="line">complex&lt;<span class="keyword">int</span>&gt;* p2 = <span class="keyword">new</span> complex&lt;<span class="keyword">int</span>&gt;; <span class="comment">// one object;</span></span><br><span class="line"><span class="keyword">delete</span> p2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* array new, array delete */</span></span><br><span class="line">Complex* pca = <span class="keyword">new</span> Complex[<span class="number">3</span>];  <span class="comment">// 这里的Complex为自己定义的；</span></span><br><span class="line"><span class="comment">// 调用三次ctor</span></span><br><span class="line"><span class="keyword">delete</span>[] pca;  <span class="comment">// 如果不加[]会导致内存泄漏</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ::operator new() and ::operator delete() */</span></span><br><span class="line"><span class="keyword">void</span>* p3 = ::<span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span>(<span class="number">512</span>); <span class="comment">// 512 bytes</span></span><br><span class="line">::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(p3)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* allocator&lt;T&gt;:: allocate() and allocator&lt;T&gt;:: deallocate() */</span></span><br><span class="line"><span class="comment">// 以下是使用c++标准库提供的allocators</span></span><br><span class="line"><span class="comment">// 不同三家的形式如下 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _MSC_VER</span></span><br><span class="line"><span class="comment">// 以下两函数都是non-static的，需要通过object调用。以下分配3个int</span></span><br><span class="line"><span class="keyword">int</span>* p4 = allocator&lt;<span class="keyword">int</span>&gt;().<span class="built_in">allocate</span>(<span class="number">3</span>, (<span class="keyword">int</span>*)<span class="number">0</span>)； <span class="comment">// 其中(int*)0 目前无用</span></span><br><span class="line">allocator&lt;<span class="keyword">int</span>&gt;().<span class="built_in">deallocate</span>(p4, <span class="number">3</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _BORLANDC_</span></span><br><span class="line"><span class="comment">// 以下两函数都是non-static的，需要通过object调用。以下分配5个int</span></span><br><span class="line"><span class="keyword">void</span>* p4 = allocator&lt;<span class="keyword">int</span>&gt;().<span class="built_in">allocate</span>(<span class="number">5</span>);</span><br><span class="line">allocator&lt;<span class="keyword">int</span>&gt;().deallocate&lt;p4, <span class="number">5</span>&gt;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _GNUC_</span></span><br><span class="line"><span class="comment">// 此为GNUC早期版本 </span></span><br><span class="line"><span class="comment">// 以下两函数都是static的，可通过全名调用。以下分配512 bytes</span></span><br><span class="line"><span class="keyword">void</span>* p4 = alloc::<span class="built_in">allocate</span>(<span class="number">512</span>);</span><br><span class="line">alloc::<span class="built_in">deallocate</span>(p4, <span class="number">512</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _GNUC_</span></span><br><span class="line"><span class="comment">// 新版GNUC</span></span><br><span class="line"><span class="comment">// 以下两函数都是non-static的，需要通过object调用。以下分配7个int</span></span><br><span class="line"><span class="keyword">void</span>* p4 = allocator&lt;<span class="keyword">int</span>&gt;().<span class="built_in">allocate</span>(<span class="number">7</span>);</span><br><span class="line">allocator&lt;<span class="keyword">int</span>&gt;().<span class="built_in">deallocate</span>((<span class="keyword">int</span>*)p4, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下两函数都是non-static的，需要通过object调用。一下分配9个int</span></span><br><span class="line"><span class="keyword">void</span>* p5 = _gnu_cxx::_pool_alloc&lt;<span class="keyword">int</span>&gt;().<span class="built_in">allocate</span>(<span class="number">9</span>);</span><br><span class="line">_gnu_cxx::_pool_alloc&lt;<span class="keyword">int</span>&gt;().<span class="built_in">deallocate</span>((<span class="keyword">int</span>*)p5, <span class="number">9</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="array-new-和-array-delete"><a href="#array-new-和-array-delete" class="headerlink" title="array new 和 array delete"></a>array new 和 array delete</h2><p><img src="https://i.loli.net/2021/07/26/xYs3LaVISlkdFDz.png" alt="image.png"></p><p>​    其中cookie会保存申请的内存的长度等信息，如果delete不加[] 会使得只释放第一或者最后一个内存块，导致内存泄漏。</p><p>​    在使用array new的时候并不能对对象进行想要的初始化，解决方法是使用palcement new。</p><p>Eg：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">A</span>() : <span class="built_in">id</span>(<span class="number">0</span>) &#123; cout&lt;&lt;<span class="string">&quot;default ctor.this=&quot;</span>&lt;&lt;<span class="keyword">this</span>&lt;&lt;<span class="string">&quot; id:&quot;</span>&lt;&lt;id&lt;&lt;endl; &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> i) : <span class="built_in">id</span>(i) &#123; cout&lt;&lt;<span class="string">&quot;ctor.this=&quot;</span>&lt;&lt;<span class="keyword">this</span>&lt;&lt;<span class="string">&quot; id:&quot;</span>&lt;&lt;id&lt;&lt;endl; &#125;</span><br><span class="line">    ~<span class="built_in">A</span>()             &#123; cout&lt;&lt;<span class="string">&quot;dtor.this=&quot;</span>&lt;&lt;<span class="keyword">this</span>&lt;&lt;<span class="string">&quot; id:&quot;</span>&lt;&lt;id&lt;&lt;endl; &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A* buf = <span class="keyword">new</span> A[<span class="number">3</span>];  <span class="comment">// 调用三次default ctor；</span></span><br><span class="line">    A* tmp = buf;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;buf = &quot;</span>&lt;&lt;buf&lt;&lt;<span class="string">&quot; tmp = &quot;</span>&lt;&lt;tmp&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span>(tmp++)<span class="built_in">A</span>(i);  <span class="comment">// ctor 3次</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;buf = &quot;</span>&lt;&lt;buf&lt;&lt;<span class="string">&quot; tmp = &quot;</span>&lt;&lt;tmp&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span>[] buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://i.loli.net/2021/07/26/bhSITMqziPGuERa.png" alt="image.png"></p><p>​    ctor的顺序和dtor顺序正好相反。</p><h2 id="new-expression-和-delete-expression"><a href="#new-expression-和-delete-expression" class="headerlink" title="new expression 和 delete expression:"></a>new expression 和 delete expression:</h2><h3 id="new-expression"><a href="#new-expression" class="headerlink" title="new expression"></a>new expression</h3> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Complex* pc =  <span class="keyword">new</span> <span class="built_in">Complex</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>编译器将其转换为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Complex *pc;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">void</span>* mem = <span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span>(<span class="built_in"><span class="keyword">sizeof</span></span>(Complex));<span class="comment">//allocate</span></span><br><span class="line">    pc = <span class="keyword">static_cast</span>&lt;Complex*&gt;(mem);               <span class="comment">// cast</span></span><br><span class="line">    pc-&gt;Complex::<span class="built_in">Complex</span>(<span class="number">1</span>, <span class="number">2</span>);                    <span class="comment">// construct</span></span><br><span class="line">    <span class="comment">// 只有编译器可以像上一行一样直接呼叫ctor；</span></span><br><span class="line">  <span class="comment">// 我们想直接调用构造函数可使用 placement new：   new(p)Complex(1, 2);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span>(std::bad_alloc) &#123;</span><br><span class="line">    <span class="comment">// 若allocation失败就不执行 constructor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="delete-expression"><a href="#delete-expression" class="headerlink" title="delete expression"></a>delete expression</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Complex* pc = <span class="keyword">new</span> <span class="built_in">Complex</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> pc;</span><br></pre></td></tr></table></figure><p>编译器转换为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pc-&gt;~<span class="built_in">Complex</span>();        <span class="comment">// 先析构</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(pc)</span></span>;   <span class="comment">// 然后释放内存</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>右值引用</title>
      <link href="2021/07/23/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"/>
      <url>2021/07/23/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h1><p>​    右值引用是为了支持移动操作，所谓右值引用就是必须绑定到右值的引用，右值引用只能绑定到一个将要销毁的对象，把即将销毁对象的内存、值等全都 “ 拿 ” 过来。</p><p>​    右值引用只能绑定右值。</p><p>Eg：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp;rr1 = <span class="number">42</span>;  <span class="comment">// 正确，字面值是右值</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr2 = rr1; <span class="comment">// 错误，表达式rr1是左值，变量是左值，即使这个变量是右值引用类型也不行</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr3 = std::<span class="built_in">move</span>(rr1); <span class="comment">// ok  ,move 将左值显式转换成右值行是，但这就意味着调用move后，除了对rr1进行赋值或者销毁外，我们将不再使用它。</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 右值引用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++程序编译过程</title>
      <link href="2021/07/21/C++%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/"/>
      <url>2021/07/21/C++%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="C-程序的编译过程（源码如何转化成二进制）"><a href="#C-程序的编译过程（源码如何转化成二进制）" class="headerlink" title="C++程序的编译过程（源码如何转化成二进制）"></a>C++程序的编译过程（源码如何转化成二进制）</h1><h2 id="编译过程分为四个步骤：编译（编译预处理、编译、优化），汇编，链接"><a href="#编译过程分为四个步骤：编译（编译预处理、编译、优化），汇编，链接" class="headerlink" title="编译过程分为四个步骤：编译（编译预处理、编译、优化），汇编，链接"></a>编译过程分为四个步骤：编译（编译预处理、编译、优化），汇编，链接</h2><ul><li><p>编译预处理：处理以 # 开头的指令。头文件展开，宏替换。</p></li><li><p>编译、优化：将源码 .cpp 文件翻译成 .s 汇编代码。在C++中，以下函数如果你没有定义但是被需要时，编译器会产生他们：默认构造函数、拷贝构造函数、析构函数、赋值运算符和一对取址运算符。</p></li><li><p>汇编：将汇编代码 .s 翻译成机器指令 .o 目标文件。目标文件以机器码的形式包含了编译单元里所有的函数和数据、导出符号表、未解决符号表、地址重定向表等。目标文件由段组成。通常一个目标文件中至少有两个段：</p><ul><li>代码段：该段中所包含的主要是程序的指令。该段一般是可读和可执行的，但一般却不可写。</li><li>数据段：主要存放程序中要用到的各种全局变量或静态的数据。一般数据段都是可读，可写，可执行的。</li></ul></li><li><p>链接：汇编程序生成的目标文件不会立即执行，可能有源文件中的函数引用了另一个源文件中定义的符号或者调用了某个库文件中的函数。链接的目的就是将这些目标文件连接成一个整体，生成一个可执行的.exe文件。C++使用链接器以确保用到的函数都只被定义一次，以及确保static objects只被定义一次，会将我们做了声明但却未曾定义的函数检测出来。</p></li></ul><p><img src="https://i.loli.net/2021/07/26/OS5yPWYLGnDjk9r.png" alt="编译过程"></p><h2 id="链接分为两种：静态和动态"><a href="#链接分为两种：静态和动态" class="headerlink" title="链接分为两种：静态和动态"></a>链接分为两种：静态和动态</h2><ul><li>静态链接：代码从其所在的静态链接库中拷贝到最终的可执行程序中，在该程序被执行时，这些代码会被装入到该进程的虚拟地址空间中。</li><li>动态链接：代码被放到动态链接库或共享对象的某个目标文件中，链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息。在程序执行时，动态链接库的全部内容会被映射到运行时相应进行的虚拟地址的空间。</li></ul><h2 id="二者优缺点"><a href="#二者优缺点" class="headerlink" title="二者优缺点"></a>二者优缺点</h2><ul><li>静态链接：<strong>浪费空间</strong>，每个可执行程序都会有目标文件的一个副本，这样如果目标文件进行了更新操作，就需要重新进行编译链接生成可执行程序（<strong>更新困难</strong>）；优点就是执行的时候运行速度快，因为可执行程序具备了程序运行的所有内容。</li><li>动态链接：节省内存、更新方便，但是动态链接是在程序运行时，每次执行任务都需要进行链接，性能会有一定的损失。</li></ul><p><strong>更为详尽的解释：<a href="https://blog.csdn.net/hycxag/article/details/82967579">https://blog.csdn.net/hycxag/article/details/82967579</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 编译 </tag>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C、C++区别</title>
      <link href="2021/05/31/C%E3%80%81C++/"/>
      <url>2021/05/31/C%E3%80%81C++/</url>
      
        <content type="html"><![CDATA[<h1 id="C和C-区别"><a href="#C和C-区别" class="headerlink" title="C和C++区别"></a>C和C++区别</h1><ul><li>C是面向用户的编程，特点是函数；C++是面向对象的编程，特点是类。<font color=blue>（特性）</font>    </li><li>C主要应用于嵌入式开发、驱动开发和硬件直接打交道的领域；C++可以应用于应用层的开发、用户界面开发等和操作系统直接打交道的领域。<font color=blue>（应用领域 ）</font></li><li>C++继承了C的底层操作特性，增加了面向对象的机制，增加而泛型编程 、异常处理、运算符重载，还增加了命名空间，避免了命名冲突。<font color=blue>（相较于C的升级）</font>    </li></ul><h1 id="C-相较于C的增强"><a href="#C-相较于C的增强" class="headerlink" title="C++相较于C的增强"></a>C++相较于C的增强</h1><ul><li>全局变量检测增强。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;  <span class="comment">// 在c语言中不会出现问题，在c++中会报错</span></span><br></pre></td></tr></table></figure><ul><li>函数的检测增强，参数类型增强，函数返回值检测增强，函数调用的参数检测异常。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getRectS</span><span class="params">(w, h)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// 在c语言中没问题，但是在c++中报错，需要增加返回值以及参数类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> test01（） &#123;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">getRectS</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>)&lt;&lt;endl; <span class="comment">// c语言没问题，但是c++中只能传递两个参数，会报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>类型转换检测增强</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span>* p = <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="number">64</span>)); <span class="comment">// malloc返回值是void*，在c语言中可以运行，c++不可</span></span><br><span class="line">    <span class="keyword">char</span>* p = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="number">64</span>)); <span class="comment">// 才可以</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>struct增强</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">plusAge</span><span class="params">()</span></span>; <span class="comment">// c语言中不可以加函数，在c中报错，c++可以</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p1</span>;</span> <span class="comment">// 在创建对象的时候c语言必须加struct关键字，c++不用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>bool类型的增强，c语言中没有bool类型，c++有， sizeof(bool) = 1，bool类型的非零值都会转换为1</li><li>三目运算符增强，c++返回的是变量，c语言返回的是值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    （a &gt; b ? a : b） = <span class="number">100</span>;  <span class="comment">// 在c语言中编译不通过，但是在c++通过，因为在c++中这行代码左边返回的是b，即b = 100，而c语言返回的是20；</span></span><br><span class="line">    cout&lt;&lt;b; <span class="comment">// 输出100；</span></span><br><span class="line">    <span class="comment">// c语言如果想实现相同的效果</span></span><br><span class="line">    *(a &gt; b ? &amp;a : &amp;b) = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>const增强，c++中不会给const分配空间，而是将m_B存入符号表中，在c中const默认为外部链接，c++中const默认为内部链接只能在当前作用域使用，要想在外部使用在定义时加extern关键字    </li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m_A = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test06</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    m_A = <span class="number">100</span>;  <span class="comment">// 全局的const不管c还是c++都不能修改，报错</span></span><br><span class="line">    <span class="keyword">const</span> m_B = <span class="number">10</span>; <span class="comment">// 在c中可以通过指针将m_B（伪常量）修改，不能初始化数组，c++中不管以什么方式都不能修改，可以初始化数组，因为没有分配内存，只有分配内存的才可以通过指针进行修改，例子见下面代码</span></span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span>*)&amp;m_B;</span><br><span class="line">    *p = <span class="number">200</span>;</span><br><span class="line">    <span class="comment">// 在c中上面两行代码相当于做了如下操作：</span></span><br><span class="line">    <span class="comment">// int tmp = m_B;   编译器临时开辟一块空间</span></span><br><span class="line">    <span class="comment">// int *p = (int*)&amp;tmp;</span></span><br><span class="line">    <span class="comment">// *p = 200；</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="string">&quot;    &quot;</span> &lt;&lt; m_B &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 输出200  10； </span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>const分配内存</p><ul><li>const在取地址得时候会分配临时内存</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> m_A = <span class="number">10</span>;  <span class="comment">// 不分配内存</span></span><br><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span>*) &amp;m_A; <span class="comment">// 分配临时内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>extern编译器也会给const变量分配内存</li><li>用变量初始化const变量会分配内存</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> b = a;  <span class="comment">// 会分配内存；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> * p =(<span class="keyword">int</span>*) &amp;b;</span><br><span class="line">*p = <span class="number">1000</span>;   <span class="comment">// 这里的b得值会被改成1000；  只有分配了内存才能通过指针对其进行修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>自定义数据类型加const也会分配内存</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">string m_Name;</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">const</span> Person p1;</span><br><span class="line"><span class="comment">// p1.m_Name = &quot;AAA&quot;;  // 报错，const变量不能直接修改，但是因为分配了内存，可以通过指针进行修改</span></span><br><span class="line">Person *p = (Person*)&amp;p1;</span><br><span class="line">p-&gt;m_Name = <span class="string">&quot;asd&quot;</span>;</span><br><span class="line">(*p).m_Age = <span class="number">19</span>;  <span class="comment">// 可以修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>引用是c++对c的重要扩充，引用就是取别名</p><ul><li>基本语法： Type &amp;别名 = 原名</li><li>引用必须初始化，初始化后不可再改为别人的别名</li><li>对数组建立引用</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span>(&amp;pArr)[<span class="number">10</span>] = arr; <span class="comment">// 方法一</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(ARRAYREF)</span>[10]</span>;</span><br><span class="line">    ARRAYREF &amp;pArr2 = arr; <span class="comment">// 方法二</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重写和重载</title>
      <link href="2021/05/31/%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E8%BD%BD/"/>
      <url>2021/05/31/%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="C-中重载和重写（覆盖）的区别"><a href="#C-中重载和重写（覆盖）的区别" class="headerlink" title="C++中重载和重写（覆盖）的区别"></a>C++中重载和重写（覆盖）的区别</h1><ul><li>对于类中函数的重载和重写而言，重载发生在同一个类内部，重写则发生在不同的类之间，子类和父类之间。</li><li>重载的函数需要与原函数有相同的函数名、不同的参数列表，不关注函数的返回值类型；重写的函数的函数名、参数列表和返回值类型都需要与原函数相同，父类中被重写的函数需要有virtual修饰。</li><li>virtual关键字：重写的函数基类中必须有virtual关键字的修饰，重载的函数可以有virtual关键字修饰也可以没有。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 重载 </tag>
            
            <tag> 重写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>new/delete和malloc/free用法及区别</title>
      <link href="2021/05/28/new%E3%80%81delete%E5%92%8Cmalloc/"/>
      <url>2021/05/28/new%E3%80%81delete%E5%92%8Cmalloc/</url>
      
        <content type="html"><![CDATA[<h1 id="new和delete的用法"><a href="#new和delete的用法" class="headerlink" title="new和delete的用法"></a>new和delete的用法</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//开辟一个空间</span></span><br><span class="line"><span class="keyword">int</span>* p1 = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> p1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开辟多个空间，通过new开辟数组，一定会调用默认构造函数，所以要提供默认构造函数，在堆区开辟数组不能调用有参构造函数，但是在栈区可以调用有参构造函数</span></span><br><span class="line"><span class="keyword">int</span>* p2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">Person pArray[<span class="number">2</span>] = &#123;<span class="built_in">Person</span>(<span class="number">1</span>), <span class="built_in">Person</span>(<span class="number">2</span>)&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">delete</span> []p2;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意事项，用void*接受new出来的指针，会出现释放问题。</span></span><br><span class="line">    <span class="keyword">void</span>* p = <span class="keyword">new</span> Person;</span><br><span class="line">    <span class="keyword">delete</span> p;   <span class="comment">// p无法释放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="malloc和free的用法"><a href="#malloc和free的用法" class="headerlink" title="malloc和free的用法"></a>malloc和free的用法</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//开辟一个空间</span></span><br><span class="line"><span class="keyword">int</span>* p1=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">if</span>(p1==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(p1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//开辟多个空间</span></span><br><span class="line"><span class="keyword">int</span>*p2=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)*<span class="number">4</span>);</span><br><span class="line"><span class="keyword">if</span>(p2==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="new和malloc的区别"><a href="#new和malloc的区别" class="headerlink" title="new和malloc的区别"></a>new和malloc的区别</h1><p>在使用的时候，new和delete搭配使用，malloc和free搭配使用，二者从功能上来看都是用来申请内存和回收内存的。</p><ul><li>属性：malloc/free是库函数，需要头文件的支持；new/delete是关键字，需要编译器的支持。</li><li>参数：new申请空间时，无需指定分配空间的大小，编译器会根据类型自行计算；malloc在申请空间时，需要确定所申请的空间大小。</li><li>返回值：new申请空间时，返回的类型是对象的指针类型，无需强制类型转换，故new是符合类型安全性的操作符。而malloc申请空间返回的是void*类型，需要进行强制类型转换，转化为对象类型的指针。</li><li>分配失败：new分配失败会抛出bad_alloc异常，malloc分配失败时返回空指针。</li><li>重载：new/delete是操作符，支持重载，只能在C++使用；malloc/free是函数，可以覆盖（重写），但不能重载，在C、C++都可以使用。</li><li>自定义类型实现：new首先调用operator new函数申请空间（底层通过malloc实现），然后调用构造函数进行初始化，最后返回自定义类型的指针；delete首先调用析构函数，然后调用operator delete释放空间（底层通过free实现）。malloc/free无法进行自定义类型对象的构造和析构。new分配一个对象，malloc分配一块内存。</li><li>内存区域：new操作符从自由存储区上为对象动态分配内存，malloc函数从堆上动态分配内存。（自由存储区 ≠ 堆）。</li></ul><p><a href="https://blog.csdn.net/weibo1230123/article/details/81980889">参考链接1</a></p><p><a href="https://www.cnblogs.com/maluning/p/7944231.html">参考链接2</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> new </tag>
            
            <tag> malloc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存分区模型</title>
      <link href="2021/05/21/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA%E6%A8%A1%E5%9E%8B/"/>
      <url>2021/05/21/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="内存分区模型"><a href="#内存分区模型" class="headerlink" title="内存分区模型"></a>内存分区模型</h1><p>目前网络上主要有两种内存分区方法：</p><h2 id="四区"><a href="#四区" class="headerlink" title="四区"></a>四区</h2><p>C++程序在执行时，将内存大方向分为四个区：</p><ul><li>代码区：存放函数体的二进制代码，由操作系统进行管理。<font color=blue>(共享、只读)</font></li><li>全局区：存放全局变量和静态变量以及常量。<font color=blue>（该区数据在程序结束后由操作系统释放）</font></li><li>栈区：由编译器自动分配释放，存放函数的参数值，局部变量等。<font color=blue>（注意函数不要返回局部变量的地址 ）</font></li><li>堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。<font color=blue>（可以把函数返回的地址保存住，用new来开辟内存）</font></li></ul><h2 id="五区"><a href="#五区" class="headerlink" title="五区"></a>五区</h2><p>分为五区：</p><ul><li>栈区：存放函数的局部变量，由编译器自动分配和释放。</li><li>堆区：动态申请的内存空间，由malloc分配的内存块，由程序员控制它的分配和释放，如果程序执行结束还没有释放，操作系统会自动回收。</li><li>自由存储区：和堆十分相似，存放由new分配的内存块，由delete释放内存。</li><li>全局区/静态区：存放全局变量和静态变量。</li><li>常量存储区：存放的是常量，不允许修改。</li></ul><p><strong>内存四区的意义：不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活性来编程。</strong></p><h2 id="堆和自由存储区的区别："><a href="#堆和自由存储区的区别：" class="headerlink" title="堆和自由存储区的区别："></a>堆和自由存储区的区别：</h2><ul><li>自由存储区是C++中通过new与delete动态分配和释放对象的抽象概念，而堆是C语言和操作系统的术语，是操作系统维护的一块动态分配内存。</li><li>new所申请的内存区域在C++中成为自由存储区，通过堆实现的自由存储，可以说new所申请的内存区域在堆上。</li><li>堆和自由存储区有区别，并非等价。使用new来分配内存，程序员也可以通过重载操作符，改用其他的内存来实现自由存储，例如全局变量做的对象池，这时自由存储区就区别于堆了。</li></ul><p><a href="https://www.cnblogs.com/QG-whz/p/5060894.html">参考链接</a></p><h1 id="堆和自由存储区定义："><a href="#堆和自由存储区定义：" class="headerlink" title="堆和自由存储区定义："></a>堆和自由存储区定义：</h1><blockquote><p>Free Store：<br>The free store is one of the two dynamic memory areas, allocated/freed by new/delete. Object lifetime can be less than the time the storage is allocated; that is, free store objects can have memory allocated without being immediately initialized, and can be destroyed without the memory being immediately deallocated. During the period when the storage is allocated but outside the object’s lifetime, the storage may be accessed and manipulated through a void* but none of the proto-object’s non-static members or member functions may be accessed, have their addresses taken, or be otherwise manipulated.</p></blockquote><blockquote><p>Heap：<br>The heap is the other dynamic memory area, allocated/freed by malloc/free and their variants. Note that while the default global new and delete might be implemented in terms of malloc and free by a particular compiler, the heap is not the same as free store and memory allocated in one area cannot be safely deallocated in the other. Memory allocated from the heap can be used for objects of class type by placement-new construction and explicit destruction. If so used, the notes about free store object lifetime apply similarly here.</p></blockquote><p>来源：<a href="http://www.gotw.ca/gotw/009.htm">http://www.gotw.ca/gotw/009.htm</a></p><p>个人理解：自由存储区就是我们所说的用new和delete动态进行内存分配和释放的区域，一般来说new的底层是通过malloc进行内存的分配，而malloc函数是从堆区上分配内存，所以在这种情况下自由存储区和堆区实际说的是一个地方，但是加入程序员通过重载等手段不通过malloc在堆区分配内存，从别的区分配，则二者就不一样了 ，如用全局变量做对象池。</p><h2 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h2><ul><li>申请方式：栈是系统自动分配的，而堆是程序员主动申请的。</li><li>申请后系统响应：分配栈空间，如果剩余空间大于申请空间则分配成功，否则分配失败栈溢出；申请堆空间，堆在内存中的呈现方式类似于链表（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序 ，将该节点从链表中删除，大多数系统会在该块空间的首地址处记录本次分配的大小，便于之后的delete语句释放内存。另外，找到的内存空间大小不一定正好等于申请空间大小，系统自动将多余部分重新放入空闲链表中。</li><li>栈在内存中是连续的一块空间（向低地址扩展）最大容量是系统预定好的，堆在内存中的空间（向高地址扩展）是不连续的。</li><li>申请效率：栈是由系统自动分配的，申请效率高但程序员无法控制；堆是由程序员主动申请的，效率低，使用起来方便但是容易产生碎片。</li><li>存放内容：栈中存放的是局部变量，函数的参数；堆中存放的内容是由程序员控制的。</li></ul><p><a href="https://blog.csdn.net/hairetz/article/details/4141043">参考链接</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 内存 </tag>
            
            <tag> 堆 </tag>
            
            <tag> 栈 </tag>
            
            <tag> 自由存储区 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>const小结</title>
      <link href="2021/05/16/const%E5%B0%8F%E7%BB%93/"/>
      <url>2021/05/16/const%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="const-分类"><a href="#const-分类" class="headerlink" title="const 分类"></a>const 分类</h1><h3 id="顶层const："><a href="#顶层const：" class="headerlink" title="顶层const："></a>顶层const：</h3><ul><li>顶层const可以表示任意的对象是常量，例如常量指针，指针本身为常量。<font color=#FF0000>顶层const作用于对象本身。</font></li></ul><h3 id="底层const："><a href="#底层const：" class="headerlink" title="底层const："></a>底层const：</h3><ul><li>底层const与指针和引用等复合类型部分有关，例如指针所指对象是常量。</li></ul><p><strong>Eg:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p1 = &amp;i;        <span class="comment">// 顶层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> c1 = <span class="number">42</span>;         <span class="comment">// 顶层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p2 = &amp;c1;       <span class="comment">// 底层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> p3 = p2; <span class="comment">// 左边底层， 右边顶层</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r = c1;         <span class="comment">// 用于声明引用的是底层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = <span class="number">42</span>;        <span class="comment">// 允许为一个常量引用绑定非常量的对象、字面值、甚至是个一般表达式</span></span><br></pre></td></tr></table></figure><h3 id="注："><a href="#注：" class="headerlink" title="注："></a><font color=red>注：</font></h3><ul><li>顶层const形参无法重载函数</li></ul><p><strong>Eg:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lookup</span><span class="params">(Phone)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Phone)</span></span>;  <span class="comment">// 等价的重复声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lookup</span><span class="params">(Phone*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lookup</span><span class="params">(Phone* <span class="keyword">const</span>)</span></span>; <span class="comment">// 等价的重复声明</span></span><br></pre></td></tr></table></figure><ul><li>底层const形参可实现函数重载</li></ul><p><strong>Eg：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lookup</span><span class="params">(Phone&amp;)</span></span>;       <span class="comment">// 作用于Phone的引用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Phone&amp;)</span></span>; <span class="comment">// 作用于Phone的常量引用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loohup</span><span class="params">(Phone*)</span></span>;       <span class="comment">// 作用于指向Phone的指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Phone*)</span></span>; <span class="comment">// 作用于指向Phone常量的指针</span></span><br></pre></td></tr></table></figure><p>当传递非常量对象或指向非常量对象的指针时，会优先选用非常量版本。</p><h1 id="const-用法"><a href="#const-用法" class="headerlink" title="const 用法"></a>const 用法</h1><ul><li><p>const修饰成员变量，定义成const常量，相较于宏常量，可进行类型检查，节省内存空间，提高了效率；const成员变量要进行初始化。</p></li><li><p>const修饰函数参数，使得传递过来的函数参数的值不能改变。</p></li><li><p>const修饰成员函数（常函数 void func() const {} ），使得成员函数不能修改任何类型的成员变量（mutable修饰的变量除外，函数参数也除外），也不能调用非const成员函数，因为非const成员函数可能会修改成员变量。</p></li><li><p>const修饰对象（常对象），只能调用常函数，不可调用普通成员函数，因为普通函数可以修改属性；同时不能对成员变量进行修改。</p></li></ul><h1 id="const注意事项"><a href="#const注意事项" class="headerlink" title="const注意事项"></a>const注意事项</h1><h2 id="const成员变量"><a href="#const成员变量" class="headerlink" title="const成员变量"></a>const成员变量</h2><ul><li><p>const成员变量只能在类内声明、定义，在构造函数初始化列表中初始化，注意在构造函数函数体内部叫赋值（经测试在声明时初始化也可，尽量不要，原因见下条）。</p></li><li><p>const成员变量只在某个对象的生存周期内是常量，对于整个类而言是可变的，因为类可以创建多个对象，不同对象的const成员变量值不同，所以不能在类的声明中初始化const成员变量，因为类的对象还没有创建，编译器不知道他的值。</p></li></ul><h2 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h2><ul><li>不能修改成员变量的值，除非有mutable修饰；只能访问成员变量。</li><li>不能调用非常量成员的函数，以防修改成员变量的值。</li></ul><h1 id="define和const的区别（编译阶段、安全性、内存占用等）"><a href="#define和const的区别（编译阶段、安全性、内存占用等）" class="headerlink" title="define和const的区别（编译阶段、安全性、内存占用等）"></a>define和const的区别（编译阶段、安全性、内存占用等）</h1><ul><li>编译阶段：define是在编译预处理阶段起作用，const是在编译阶段和程序运行阶段起作用。</li><li>安全性：define定义的宏常量没有数据类型，只是进行简单的替换，不会进行类型安全的检查；const定义的只读变量是有类型的，需要进行判断，可以避免一些低级错误。</li><li>内存占用：define定义的宏常量，在程序中使用多少次就会进行多少次替换，内存中有多个备份；const定义的只读变量在程序运行过程中只有一份。</li><li>调试：define定义的不能调试，因为在预编译阶段就进行替换了；const定义的可以进行调试。</li><li>define是没有作用域的，从声明到文件尾都是存活的，但是可以通过#undef A 来卸载宏常量A，而const是有作用域的。</li></ul><h1 id="const的优点"><a href="#const的优点" class="headerlink" title="const的优点"></a>const的优点</h1><ul><li>有数据类型，在定义时可进行安全性检查</li><li>可调试</li><li>占用较少的空间</li></ul><p>在《c和c++区别》这章也有关于const的内容</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> const </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
