<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux网络编程</title>
      <link href="2022/03/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>2022/03/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h1><h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><ul><li><p>物理层</p><ul><li>主要解决两台物理机之间的通信，通过二进制比特流的传输来实现，而进程数据表现为电流电压上的强弱，到达目的地再转化为二进制机器码。网卡、集线器在这层工作。</li></ul></li><li><p>数据链路层 – 数据的传输和错误检测。</p><ul><li>在不可靠的物理介质上提供可靠传输，接收来自物理层的位流形式的数据并封装成帧，传送到上一层；同样也将上层的数据帧拆为位流形式的数据转发到物理层。这一层在物理层提供的比特流基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路。提供物理地址寻址功能。交换机工作在这一层。ARP协议。</li></ul></li><li><p>网络层 </p><ul><li>将网络地址翻译成对应的物理地址，并确定如何将数据从发送方路由到接收方，通过路由选择算法为分组通过通信子网选择最佳路径。路由器工作在这一层。IP协议。</li></ul></li><li><p>传输层</p><ul><li>传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。TCP、UDP协议。</li></ul></li><li><p>会话层</p><ul><li>建立会话：身份验证，权限鉴定等。</li><li>保持会话：对该会话进行维护，在会话维持期间两者可以随时使用这条会话传输数据。</li><li>断开会话：当应用程序或应用层规定的超时时间到期后，OSI会话层才会释放这条对话。</li></ul></li><li><p>表示层</p><ul><li>对数据格式进行编译，对收到或发出的数据根据应用层的特征进行处理，如处理为文字、图片、音频、视频、文档等，还可以对压缩文件进行解压缩、对加密文件进行解密等。</li></ul></li><li><p>应用层</p><ul><li>提供应用层协议，如HTTP协议，FTP协议等等，方便应用程序之间进行通信。HTTP、FTP、DNS等。</li></ul></li></ul><h1 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>​        数据传输和数据解释的规则。</p><h2 id="以太网帧协议"><a href="#以太网帧协议" class="headerlink" title="以太网帧协议"></a>以太网帧协议</h2><ul><li>以太网帧协议：根据mac地址，完成数据包传输。</li></ul><h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><ul><li>ARP协议：根据IP地址获取mac地址 。</li></ul><h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><ul><li>版本：IPv4、IPv6    – 4位。</li><li>TTL：time to live。设置数据包在路由节点中的跳转上限。每经过一个节点，该值-1，减为0时路由有义务将该数据丢弃。</li><li>源IP：32位。   – 4字节。</li><li>目的IP：32位。  – 4字节。</li></ul><p><strong>IP地址：</strong>可以在网络环境中，唯一标识一台主机。</p><p><strong>端口号：</strong>可以在网络的一台主机上，唯一标识 一个进程。</p><p><strong>IP+端口号：</strong>可以在网络环境中，唯一标识一个进程。</p><h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><ul><li>源端口号：16位。                    2^16 =65536 </li><li>目的端口号：16位。 </li></ul><h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><ul><li>源端口号：16位。                    2^16 =65536 </li><li>目的端口号：16位。 </li><li>32位序号。</li><li>32位确认序号。</li><li>6个标志位。</li><li>16位窗口大小。</li></ul><p><img src="https://s2.loli.net/2022/03/20/T6L3S2sIhBwHigm.jpg" alt="20180717201939345.jpg"></p><h2 id="TCP和UDP区别"><a href="#TCP和UDP区别" class="headerlink" title="TCP和UDP区别"></a>TCP和UDP区别</h2><p>4点（面向连接？面向的数据？是否可靠？是否支持组播？）</p><ul><li><p>TCP</p><p>为面向字节流的协议（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），提供可靠的、面向连接的服务，由流量控制和拥塞控制，可以保证数据顺序，提供全双工通信，每条TCP连接只能是点对点的。</p></li><li><p>UDP</p><p>为面向报文的协议，不提供可靠交付，并且不需要连接，不保证数据顺序，尽最大可能交付，没有拥塞控制，支持一对一，一对多，多对多，多对一的交互通信。</p></li></ul><h2 id="TCP三次握手四次挥手"><a href="#TCP三次握手四次挥手" class="headerlink" title="TCP三次握手四次挥手"></a>TCP三次握手四次挥手</h2><h3 id="TCP状态机"><a href="#TCP状态机" class="headerlink" title="TCP状态机"></a>TCP状态机</h3><p>​        TCP状态机是TCP连接的变化过程。</p><p><img src="https://s2.loli.net/2022/03/24/pRYEcIVPFMJrft6.png" alt="20180608201426603.png"></p><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><img src="https://s2.loli.net/2022/03/18/9xYT67swEiCUnOz.png" alt="1"></p><ul><li>第一次握手：客户端将标志位SYN置1，随机产生一个值序列号seq=x，并将该数据包发送给服务器，客户端进入syn_sent状态，等待服务器确认。</li></ul><blockquote><p>syn_sent: 在发送连接请求后等待匹配的连接请求。</p></blockquote><ul><li>第二次握手：服务器收到数据包后由标志位SYN = 1知道客户端请求建立连接，服务器将标志位SYN和ACK置1，确认序号ack=x+1代表之前的SYN报文收到希望收到的下一个数据的第一个字节的序号为x+1，并随机产生自己的初始序列号seq=y，服务器进入syn_rcvd状态。</li></ul><blockquote><p>syn_rcvd:在收到和发送一个连接请求后等待对连接请求的确认。</p></blockquote><ul><li>第三次握手：客户都安收到确认检查后，如果正确则将标志位ACK为1，确认序号ack=y+1，序号seq为x+1，并将数据包发送给服务端，服务端检查后二者建立连接。</li></ul><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img src="https://s2.loli.net/2022/03/18/jMdevk1tni7x8Br.png" alt="2"></p><ul><li>第一次挥手：客户端发送一个FIN，用来关闭客户端到服务器的数据传送，客户端进入fin_wait_1状态。</li><li>第二次挥手：服务器收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1，服务器进入close_wait状态。此时TCP连接处于半关闭状态，即客户端没有要发的数据了，但服务器若发送数据客户端仍可以接收。</li><li>第三次挥手：服务器发送一个FIN，用来关闭服务器到客户端的数据传送，服务器进入Last_ack状态。</li><li>第四次挥手：客户端收到FIN后，客户端进入Time_wait状态，接着发送一个ACK给服务器，确认后。服务器进入closed状态，完成四次挥手。</li></ul><h3 id="为什么三次握手，两次不行？"><a href="#为什么三次握手，两次不行？" class="headerlink" title="为什么三次握手，两次不行？"></a>为什么三次握手，两次不行？</h3><ul><li>TCP进行可靠传输的关键在于维护一个序列号 ，三次握手的过程即通信双方互相告知序列号起始值，并确认对方已经收到了序列号起始值。如果只是两次握手，最多只有客户端的起始序号能被确认，服务器端的序列号得不到确认。</li><li>为防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。<ul><li>经典场景：客户端发送了第一个请求连接并且没有丢失，只是因为在网络节点中滞留时间太长。</li><li>由于TCP的客户端迟迟没收到确认报文，会选择重发，此后客户端和服务器经过两次握手完成链接，传输数据，然后关闭。</li><li>此时此前滞留的一次请求连接，网络畅通到达服务器，这个报文本该失效，但是<strong>两次握手机制会让客户端和服务器再次建立连接，会导致不必要的错误和资源浪费</strong>。</li><li>如果采用三次握手，就算失效的报文传送过来，服务端收到后回复确认报文，但客户端不会再次发出确认，由于服务器收不到确认，就知道客户端没有请求连接。</li></ul></li></ul><h3 id="为什么建立连接三次，关闭是四次挥手呢？"><a href="#为什么建立连接三次，关闭是四次挥手呢？" class="headerlink" title="为什么建立连接三次，关闭是四次挥手呢？"></a>为什么建立连接三次，关闭是四次挥手呢？</h3><p>​        建立连接时，服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，服务器收到对方的FIN报文时 ，仅仅表示对方不再发送数据，但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据后再发送FIN表示同意关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多一次。</p><h3 id="如果已经建立连接，但是客户端突然出现故障怎么办？"><a href="#如果已经建立连接，但是客户端突然出现故障怎么办？" class="headerlink" title="如果已经建立连接，但是客户端突然出现故障怎么办？"></a>如果已经建立连接，但是客户端突然出现故障怎么办？</h3><p>​        TCP设有一个保活计时器，如果客户端出现故障，服务器不会一直等下去，服务器每收到一次客户端请求就会重新复位这个计时器，时间通常为2h，若2小时没收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75s发送一次。若一连发送10个探测报文没反应，服务器就认为客户端出现故障，接着关闭连接。</p><h3 id="半连接队列"><a href="#半连接队列" class="headerlink" title="半连接队列"></a>半连接队列</h3><p>​        TCP握手中，当服务器处于SYN_RCVD状态，服务器会把此种状态下请求连接放在一个队列里，该队列称为半连接队列。</p><h3 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h3><p>​        SYN攻击即利用TCP协议缺陷，通过发送大量半连接请求，占用半连接队列，耗费CPU和内存资源。</p><p>​        TCP SYN泛洪发生在OSI第四层，通过利用TCP三次握手特性，攻击者发送大量SYN报文，当服务器返回ACK后，攻击者不会确认，此时服务器会重复发送ACK回复，浪费服务器资源，攻击者通过发送大量半连接请求，在服务器上这些TCP连接会因为挂起状态消耗CPU和内存资源，从而死机。</p><p>优化方式：</p><ul><li>缩短SYN Timeout时间，使得主机尽快释放半连接的占用。</li><li>利用SYN cookie设置，记录IP，若连续受到某个IP的重复SYN报文，从这个IP地址来的包一概丢弃。</li></ul><h3 id="为什么四次挥手？"><a href="#为什么四次挥手？" class="headerlink" title="为什么四次挥手？"></a>为什么四次挥手？</h3><p>主要原因是当服务器收到客户端的FIN数据包后，服务器可能还有数据没有发完，不会立即close。因此服务器会先将ACK返回给客户端表示收到断开请求，但是服务器仍需要时间发送剩下的数据包，待所有数据包发完，服务器才会将FIN包发给客户端，之后客户端需要收到FIN后发送ACK确认断开给服务器。</p><h3 id="为什么四次挥手后需要等待2MSL？"><a href="#为什么四次挥手后需要等待2MSL？" class="headerlink" title="为什么四次挥手后需要等待2MSL？"></a>为什么四次挥手后需要等待2MSL？</h3><ul><li>MSL是指报文最大生存时间，是任何报文在网络上存在的最长时间，超时会被丢弃。MSL单位是时间，TTL单位是经过路由跳数。MSL&gt;=TTL。</li><li>尽量保证被动关闭的一端收到它自己发送的FIN报文的ACK确认报文。有两种情况：<ul><li>ACK在网络中丢失，在2MSL会收到重传的FIN报文，并重置2MSL。保证对端可以收到自己的ACK。</li><li>假如发送的ACK在MSL时间到达对端，此时正好对端重发了FIN标志位，2MSL就能保证最后一次发的FIN标志位在网络中消失，如果不等2MSL，客户端断开后立刻重连，那么服务器在上次连接最后一次发送的FIN就可能在新的连接中到达，影响连接，2MSL主要保证了旧连接的报文不会影响新连接。</li></ul></li></ul><h3 id="TCP的accept-函数发生在第几次握手？"><a href="#TCP的accept-函数发生在第几次握手？" class="headerlink" title="TCP的accept()函数发生在第几次握手？"></a>TCP的accept()函数发生在第几次握手？</h3><ul><li>accept过程发生在三次握手之后，三次握手完成后,客户端和服务器就建立了tcp连接并可以进行数据交互了。这时可以调用accept函数获得此连接。</li><li>在Linux中， accept函数的作用是： 从已经完成连接的socket队列中取出一个socket,  如果没有已经完成连接的socket, 那么accept函数就会阻塞。</li></ul><h2 id="TCP实现可靠通信（）"><a href="#TCP实现可靠通信（）" class="headerlink" title="TCP实现可靠通信（）"></a>TCP实现可靠通信（）</h2><h2 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>​        DNS协议是基于UDP的应用层协议，他的功能是根据用户输入的域名，解析出该域名对应的IP地址，从而给客户端进行访问。</p><ul><li>一个组织的系统管理机构，维护系统内的每个主机IP和主机名的对应关系。</li><li>如果新计算机接入网络，将这个信息注册到数据库中。</li><li>用户输入域名的时候，会自动查询DNS服务器，由DNS服务器检索数据库，得到对应的IP地址。</li></ul><h3 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h3><ul><li>客户机发出查询请求，在本地host文件查找，有则直接返回。</li><li>若没有找到，会将请求发送给本地DNS服务器，通过递归查询方式进行查找，找到则返回。</li><li>没找到则本地服务器将请求发送到根域名服务器，之后使用迭代查询的方式找到目标IP信息后把查询结果返回给客户机的本地DNS服务器，最终将信息返回给客户机。</li></ul><blockquote><p>递归查询：如果主机所询问的本地域名服务器不知道被查询的域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其它根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。因此，递归查询返回的查询结果或者是所要查询的IP地址，或者是报错，表示无法查询到所需的IP地址。</p></blockquote><blockquote><p>迭代查询：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地服务器进行后续的查询。根域名服务器通常是把自己知道的顶级域名服务器的IP地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的IP地址，要么告诉本地服务器下一步应当向哪一个权限域名服务器进行查询。最后，知道了所要解析的IP地址或报错，然后把这个结果返回给发起查询的主机。</p></blockquote><p><img src="https://pic2.zhimg.com/v2-844e5d5d9424494ded2f1e97cf519951_r.jpg" alt="preview"></p><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>​        http协议是超文本传输协议。它是基于TCP协议的应用层传输协议，即客户端和服务端进行数据传输的一种规则。该协议本身HTTP是一种无状态协议。</p><p><strong>无状态：</strong>协议本身没有记忆能力。如果后续处理需要前面的信息，则其必须重传，这样可能导致每次连接传送的数据量增大。</p><h3 id="浏览器输入URL-gt-显示主页过程"><a href="#浏览器输入URL-gt-显示主页过程" class="headerlink" title="浏览器输入URL-&gt;显示主页过程"></a>浏览器输入URL-&gt;显示主页过程</h3><ul><li>进行DNS解析操作，根据DNS解析的结果查到服务器IP地址。</li><li>利用三次握手与服务器建立连接。</li><li>发送http请求。</li><li>服务器处理请求，返回给浏览器。</li><li>浏览器根据收到的静态数据进行页面渲染。</li></ul><p>用到的协议：DNS、TCP、IP、ARP、HTTP等。</p><h3 id="HTTP1-0和HTTP1-1"><a href="#HTTP1-0和HTTP1-1" class="headerlink" title="HTTP1.0和HTTP1.1"></a>HTTP1.0和HTTP1.1</h3><ul><li>长连接和短连接。<ul><li>1.0规定浏览器和服务器只保持短暂的连接，每进行一次HTTP通信就断开一次TCP连接。</li><li>1.1支持长连接（持久连接），他的特点是只要任意一端没有明确提出断开连接 ，就保持TCP连接状态。这样一个TCP连接可以进行多次请求响应的交互。同时支持管道通信，一次性发送多个request请求，可降低相应时间。</li></ul></li></ul><h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><ul><li><p>1XX：接收的信息正在处理。</p></li><li><p>2XX：请求成功。</p></li><li><p>3XX：重定向。</p></li><li><p>4XX：客户端错误。</p></li><li><p>5XX：服务端错误。</p></li><li><p>常见状态码：</p></li></ul><table><thead><tr><th align="left">状态码</th><th>含义</th></tr></thead><tbody><tr><td align="left">200（成功）</td><td>服务器已成功处理请求。通常表示服务器提供了请求的网页</td></tr><tr><td align="left">201（已接受）</td><td>请求成功并且服务器创建了新的资源。</td></tr><tr><td align="left">203（非授权信息）</td><td>服务器已成功处理了请求，但返回的信息可能来自另一来源。</td></tr><tr><td align="left">204（无内容）</td><td>服务器成功处理请求，但是没有返回任何内容，当前页面不会有任何变化。</td></tr><tr><td align="left">205（重置内容）</td><td>相比204多了一步操作,就是要清空当前文档内所有表单控件的内容。</td></tr><tr><td align="left">206（部分内容）</td><td>服务器成功处理了部分GET请求。</td></tr><tr><td align="left">301</td><td>永久重定向。</td></tr><tr><td align="left">302</td><td>临时重定向。</td></tr><tr><td align="left">304</td><td>资源没修改，用之前的缓存就行。</td></tr><tr><td align="left">400</td><td>客户端请求的报文有错误。</td></tr><tr><td align="left">401（未授权）</td><td>请求要求身份验证。对于需要登陆的网页，服务器可能返回此响应。</td></tr><tr><td align="left">403（禁止）</td><td>服务器拒绝请求。</td></tr><tr><td align="left">404</td><td>请求的资源在服务器不存在或未找到。</td></tr><tr><td align="left">500</td><td>服务器遇到错误，无法完成请求。挂代理的时候有时候会出现500 Internal Privoxy Error（内部隐私错误）。</td></tr><tr><td align="left">501（尚未实施）</td><td>服务器不具备完成请求的功能。例如服务器无法识别请求方法时。</td></tr><tr><td align="left">502（错误网关）</td><td>服务器作为网关或代理，从上游服务器收到无效响应。</td></tr><tr><td align="left">503（服务不可用）</td><td>服务器目前无法使用（由于超载和停机维护）。通常这只是暂时状态。</td></tr><tr><td align="left">504（网关超时）</td><td>服务器作为网关或代理，但是没有及时从上游服务器收到请求。</td></tr><tr><td align="left">505（HTTP版本不受支持）</td><td>服务器不支持请求中所用的HTTP协议版本。</td></tr></tbody></table><h3 id="转发和重定向的区别"><a href="#转发和重定向的区别" class="headerlink" title="转发和重定向的区别"></a>转发和重定向的区别</h3><ul><li>转发是服务器行为。服务器直接向目标地址访问URL，将相应内容读取后发给浏览器，用户浏览器地址栏URL不变，转发页面和转发到的页面可以共享request里面的数据。</li><li>重定向是利用服务器返回的状态码实现，如果服务器返回301或者302，浏览器收到新消息后会自动跳转到新的网址重新请求资源。用户的地址栏URL会改变，而且不能共享数据。</li></ul><h3 id="Get和Post区别"><a href="#Get和Post区别" class="headerlink" title="Get和Post区别"></a>Get和Post区别</h3><ul><li>Get：指定资源请求数据，刷新无害，Get请求数据会附加到URL中，传输数据的大小受到URL限制，允许发送的数据量较小，而Post请求没有大小限制。</li><li>Post：向指定资源提交要被处理的数据。刷新会导致数据的重复提交。post在发送数据前会先将请求头发送给服务器进行确认，然后才真正发送数据。Post的安全性比Get的安全性高，因为Get请求提交的数据将明文出现在URL上，而Post请求参数则被包装到请求体中，相对安全。</li></ul><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>​        超文本传输安全协议，是一种透过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但是利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。默认工作在TCP协议443端口。</p><h3 id="工作流程（）"><a href="#工作流程（）" class="headerlink" title="工作流程（）"></a>工作流程（）</h3><h2 id="HTTP和HTTPS区别"><a href="#HTTP和HTTPS区别" class="headerlink" title="HTTP和HTTPS区别"></a>HTTP和HTTPS区别</h2><ul><li>url和端口<ul><li>http：开头http://，默认80端口。</li><li>https：开头https://，默认443端口。</li></ul></li><li>安全性和资源消耗<ul><li>HTTP协议运行在TCP上，所有传输的内容都是明文，客户端和服务器都无法验证对方的身份，安全性较差。HTTPS经由HTTP进行通信，但是利用SSL/TLS来加密数据包，安全性较好。HTTP响应速度比HTTPS快，主要因为HTTP使用TCP三次握手建立连接，客户端和服务器需要交换3个包，而HTTPS除了TCP的三个包，还要加上SSL握手的9个包，所以HTTP资源消耗小。HTTPS其实就是建构在SSL/TLS上的HTTP协议。</li></ul></li></ul><h2 id="常用端口号"><a href="#常用端口号" class="headerlink" title="常用端口号"></a>常用端口号</h2><table><thead><tr><th align="center">端口</th><th align="left">服务</th></tr></thead><tbody><tr><td align="center">21</td><td align="left">FTP（文件传输协议）</td></tr><tr><td align="center">22</td><td align="left">SSH（安全外壳协议）</td></tr><tr><td align="center">23</td><td align="left">Telnet（internet远程登录服务的标准协议）</td></tr><tr><td align="center">25</td><td align="left">SMTP简单邮件传输服务</td></tr><tr><td align="center">53</td><td align="left">DNS（域名系统服务）</td></tr><tr><td align="center">80</td><td align="left">HTTP（超文本传输协议）</td></tr></tbody></table><h1 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h1><ul><li>什么是socket？<ul><li>网络通信的函数接口。</li><li>封装了传输层协议。<ul><li>TCP</li><li>UDP</li></ul></li><li>本质是一个文件描述符在指向一个套接字（该套接字内部由内核借助两个缓冲区实现。）</li></ul></li></ul><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="字节序转换函数"><a href="#字节序转换函数" class="headerlink" title="字节序转换函数"></a>字节序转换函数</h3><p><strong>inet_pton：</strong></p><ul><li><code>int inet_pton(int af, const char *src, void *dst);</code>本地字节序转网络字节序。</li><li>af: AF_INET、AF_INET6 对应ipv4、ipv6。</li><li>src：传入，本地IP地址字符串。</li><li>dst：传出，转换后的网络ip地址。</li><li>返回值：成功返回1，异常返回0，说明src传入的ip地址无效 。失败返回-1。</li></ul><p><strong>inet_ntop</strong>：</p><ul><li><code>const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);</code>网络字节序转本地字节序。</li><li>af: AF_INET、AF_INET6 对应ipv4、ipv6。</li><li>src：传入，网络IP地址字符串。</li><li>dst：传出，转换后的本地ip地址。</li><li>size：dst大小。</li><li>返回值：成功返回dst。失败返回null。</li></ul><h3 id="socket相关函数"><a href="#socket相关函数" class="headerlink" title="socket相关函数"></a>socket相关函数</h3><p><strong>socket():</strong></p><ul><li><code>int socket(int domain, int type, int protocol);</code>创建一个套接字</li><li>domain ：AF_INET、AF_INET6、AF_UNIX  对应IPv4、IPv6、本地。</li><li>type：创建套接字的传输协议，SOCK_STREAM、SOCK_DGRAM。</li><li>protocol：说明典型协议，一般传0。</li><li>返回值：成功返回一个新套接字所对应的文件描述符，失败-1，设置errno。</li></ul><p><strong>bind()：</strong></p><ul><li><p><code>int bind(int sockfd, const struct sockaddr *addr,socklen_t addrlen);</code>给socket绑定地址结构（IP+PORT）。</p></li><li><p>sockfd ：传入socket函数返回值。</p></li><li><p>addr：传入参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">addr.sin_family = AF_INET;</span><br><span class="line">addr.sin_port = <span class="built_in">htons</span>(<span class="number">8888</span>);</span><br><span class="line">arddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY); <span class="comment">// INADDR_ANY系统自动帮你取当前可用的IP</span></span><br></pre></td></tr></table></figure><ul><li><code>（struct sockaddr*）&amp;addr</code></li></ul></li><li><p>addrlen: sizeof(addr) 地址结构的大小。</p></li><li><p>返回值：成功返回0，失败-1设置errno。</p></li></ul><p><strong>listen()：</strong></p><ul><li><code>int listen(int sockfd, int backlog);</code> 设置同时与服务器建立连接的上限数。（同时进行三次握手的客户端数量）。</li><li>sockfd ：传入socket函数返回值。</li><li>backlog：上限数值。最大128。</li><li>返回值：成功返回0，失败-1设置errno。</li></ul><p><strong>accept():</strong></p><ul><li><code>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</code>阻塞等待客户端建立链接，成功返回一个与客户端成功链接的socket文件描述符。</li><li>sockfd ：传入socket函数返回值。</li><li>addr：传出参数。成功与服务器建立连接的哪个客户端的地址结构（IP+PORT）。</li><li>addrlen: 传入addr的大小，传出客户端addr的实际大小。</li><li>返回值：成功返回一个能与客户端进行数据通信的socket的文件描述符。失败返回-1，errno。</li></ul><p><strong>connect：</strong></p><ul><li><code>int connect(int sockfd, const struct sockaddr *addr,socklen_t addrlen);</code>使用现有的socket与服务器建立连接。</li><li>sockfd ：传入socket函数返回值。</li><li>addr：传入参数。服务器地址结构。</li><li>addrlen：sizeof(addr) 地址结构的大小。</li><li>返回值：成功0，失败-1errno。</li></ul><p><strong>setsockopt：</strong></p><ul><li><p><code>int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);</code>设置端口复用。</p></li><li><p>用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">setsockopt</span>(listenfd, SOL_SOCKET, SO_REUSEADDR, (<span class="keyword">void</span>*)&amp;opt, <span class="built_in"><span class="keyword">sizeof</span></span>(opt));</span><br><span class="line"><span class="comment">// 写在bind之前。</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>close\shutdown:</strong></p><ul><li><code>close(cfd);</code> 关闭套接字的文件描述符。</li><li><code>shutdown(int fd, int how);</code><ul><li>how:<ul><li>SHUT_RD 关读端</li><li>SHUT_WR 关写端</li><li>SHUT_RDWR 关读写</li></ul></li></ul></li><li>shutdown在关闭多个文件描述符引用的文件时，采用全关闭方法，close只关闭一个。</li></ul><h3 id="select函数"><a href="#select函数" class="headerlink" title="select函数"></a>select函数</h3><p><strong>select:</strong></p><ul><li><p>多路IO转接，原理：借助内核，select来监听，客户端连接、数据通信事件。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds,fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br><span class="line"><span class="comment">// nfds：监听的所有文件描述符中，最大文件描述符+1.</span></span><br><span class="line"><span class="comment">// readfds：读文件描述符监听集合。传入传出参数</span></span><br><span class="line"><span class="comment">// writefds：写文件描述符监听集合。传入传出参数NULL</span></span><br><span class="line"><span class="comment">// exceptfds：异常文件描述符监听集合。传入传出参数NULL</span></span><br><span class="line"><span class="comment">// timeout：  &gt;0 : 设置监听超时时长</span></span><br><span class="line"><span class="comment">// NULL：阻塞监听</span></span><br><span class="line"><span class="comment">// 0： 非阻塞监听，轮询</span></span><br><span class="line"><span class="comment">// 返回值：&gt;0:所有监听集合中，满足对应事件的总数。</span></span><br><span class="line"><span class="comment">//0：没有满足监听条件的文件描述符</span></span><br><span class="line"><span class="comment">//   -1：errno。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *set)</span></span>;<span class="comment">// 将一个文件描述符从监听集合中移除。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *set)</span></span>;<span class="comment">// 判断一个文件描述符是否在监听集合中。在返回1，否则返回0。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *set)</span></span>;<span class="comment">// 将待监听的文件描述符添加到监听集合中。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *set)</span></span>;        <span class="comment">// 清空文件描述符集合。</span></span><br></pre></td></tr></table></figure></li><li><p>缺点：</p><ul><li>监听上限受文件描述符限制，最大1024。</li><li>检测满足条件的fd，自己添加业务逻辑提高小，提高了编码难度。</li></ul></li><li><p>优点：</p><ul><li>跨平台，Win、Linux、macOS、Unix、类Unix等。</li></ul></li></ul><h3 id="poll函数"><a href="#poll函数" class="headerlink" title="poll函数"></a>poll函数</h3><p><strong>poll:</strong></p><ul><li><code>int poll(struct pollfd *fds, nfds_t nfds, int timeout);</code></li><li>fds：监听的文件描述符数组。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>   fd;         <span class="comment">/* file descriptor 待监听的文件描述符*/</span></span><br><span class="line">    <span class="keyword">short</span> events;     <span class="comment">/* requested events 待监听的文件描述符对应的监听事件 取值：POLLIN、POLLOUT、POLLERR*/</span>   </span><br><span class="line">    <span class="keyword">short</span> revents;    <span class="comment">/* returned events 传入时，给0。如果满足对应事件的话，返回非0-》POLLIN、POLLOUT、POLLERR*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>nfds：监听数组的，实际有效监听个数。</li><li>timeout：<ul><li>-1 ：阻塞等待。</li><li>0：立即返回。</li><li>&gt;0:超时时长，毫秒。</li></ul></li><li>返回值：返回满足对应事件的总个数。</li><li>优点：自带数组结构，可以将监听事件和返回事件集合分离，可以拓展监听上限，超出1024。</li><li>缺点：不能跨平台，只能在Linux/Unix。无法直接定位满足监听事件的文件描述符，只能for循环轮询。</li></ul><p><strong>突破1024文件描述符限制：</strong></p><p><code>cat /proc/sys/fs/file-max</code>  —-&gt; 当前计算机能打开的最大文件个数，受硬件影响。</p><p><code>ulimit -a</code> —–&gt; 当前用户下的进程，默认打开文件描述符的个数。</p><p><code>sudo vim /etc/secur/limits.conf</code>   修改soft nofile。</p><h3 id="epoll函数"><a href="#epoll函数" class="headerlink" title="epoll函数"></a>epoll函数</h3><p><strong>epoll:(本质是红黑树)</strong></p><ul><li><p><code>int epoll_create(int size); </code>  创建一颗监听红黑树。</p><ul><li>size：表示创建红黑树的监听节点数量（仅供内核参考。）</li><li>返回值：<ul><li>成功返回指向新创建的红黑树的根节点的fd。</li><li>失败errno，-1。</li></ul></li></ul></li><li><p><code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); </code> 操作监听红黑树。</p><ul><li>epfd：epoll_creat函数的返回值。epfd。</li><li>op：表示对该监听红黑树的操作。<ul><li>EPOLL_CTL_ADD  添加fd到监听红黑树。</li><li>EPOLL_CTL_MOD  修改fd在监听红黑树上的监听事件。</li><li>EPOLL_CTL_DEL    将一个fd从监听红黑树上摘下（取消监听）。</li></ul></li><li>fd：待监听的fd。</li><li>event：本质是struct epoll_event结构体 地址<ul><li>events：EPOLLIN/EPOLLOUT/EPOLLERR</li><li>data：</li></ul></li><li>返回值：成功0，失败-1 errno。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>        *ptr;</span><br><span class="line">    <span class="keyword">int</span>          fd;<span class="comment">// 对应监听事件的fd</span></span><br><span class="line">    <span class="keyword">uint32_t</span>     u32;</span><br><span class="line">    <span class="keyword">uint64_t</span>     u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span>     events;      <span class="comment">/* Epoll events */</span></span><br><span class="line">    <span class="keyword">epoll_data_t</span> data;        <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code> int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);</code> 阻塞监听。</p><ul><li>epfd：epoll_creat 函数的返回值。epfd。</li><li>events：【数组】，传出参数，传出满足监听条件fd结构体。</li><li>maxevents：数组元素的总个数。类似于buffer_size。</li><li>timeout：<ul><li>-1 阻塞</li><li>0  不阻塞</li><li>&gt;0 监听时长，单位毫秒。</li></ul></li><li>返回值：<ul><li>&gt;0：满足监听的总个数，可以用作循环上限。</li><li>0：没有满足的事件。</li><li>-1，失败，errno。</li></ul></li></ul></li><li><p>epoll可以显著提高程序在大量并发连接中只有少量活跃情况下的系统CPU利用率</p></li><li><p>优点：高效，突破1024文件描述符限制。</p></li><li><p>缺点：不能跨平台，只能Linux。</p></li></ul><h2 id="epoll事件模型"><a href="#epoll事件模型" class="headerlink" title="epoll事件模型"></a>epoll事件模型</h2><h3 id="ET模式（边沿触发）"><a href="#ET模式（边沿触发）" class="headerlink" title="ET模式（边沿触发）"></a>ET模式（边沿触发）</h3><ul><li>内核缓冲区剩余未读尽的数据不会导致epoll_wait返回。新的事件满足才会触发。需要从电平的角度分析，假如内核缓冲区里的数据只读取一半，然后剩一半，这时候对读事件来说，会一直处于高电平（可读）状态，这时候在边沿触发模式下不会导致epoll_wait返回。在设计的时候需要把内核缓冲区的数据全部读出即read函数返回EAGAIN错误，黑马的做法是增加一个用户缓冲区，把内核缓冲区数据全都读到用户缓冲区中，然后进行处理。</li><li><code>struct epoll_event event;</code></li><li><code>event.events = EPOLLIN | EPOLLET;</code></li><li>epoll的ET模式，是高效模式，但是只支持非阻塞模式 – 忙轮询。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">event.events = EPOLLIN | EPOLLET;</span><br><span class="line"><span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, cfd, &amp; event);</span><br><span class="line"><span class="keyword">int</span> flg = <span class="built_in">fcntl</span>(cfd, F_GETFL);</span><br><span class="line">flg |= O_NONBLOCK;</span><br><span class="line"><span class="built_in">fcntl</span>(cfd, F_SETFL, flg);</span><br></pre></td></tr></table></figure><h3 id="LT模式（水平触发）"><a href="#LT模式（水平触发）" class="headerlink" title="LT模式（水平触发）"></a>LT模式（水平触发）</h3><ul><li>对于读事件，内核缓冲区剩余未读尽的数据会导致epoll_wait返回，由于内核缓冲区一直处于高电平，所以epoll_wait会一直返回。</li><li>在写事件的时候，只要内核缓冲区未满，可写就会导致高电平状态，就会出现busy_loop的情况。</li><li>默认采用水平触发。</li></ul><p><img src="https://s2.loli.net/2022/04/13/jq2PMkrasnSBtE9.png" alt="image.png"></p><h2 id="epoll-反应堆模型"><a href="#epoll-反应堆模型" class="headerlink" title="epoll 反应堆模型"></a>epoll 反应堆模型</h2><ul><li>epoll的ET模式 + 非阻塞 + void*ptr。</li><li>不但要监听cfd的读事件，也要监听cfd的写事件。</li></ul><p><img src="https://s2.loli.net/2022/04/12/FH1NViKd2UxtYsh.png" alt="image.png"></p><h2 id="socket模型创建流程图"><a href="#socket模型创建流程图" class="headerlink" title="socket模型创建流程图"></a>socket模型创建流程图</h2><p><img src="https://img-blog.csdnimg.cn/20201005105410703.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDM0Nzgw,size_16,color_FFFFFF,t_70#pic_center" alt="1"></p><p>如果不使用bind绑定客户端的地址结构，系统会自动采用“隐式绑定”。</p><hr><h1 id="多路IO复用模型"><a href="#多路IO复用模型" class="headerlink" title="多路IO复用模型"></a>多路IO复用模型</h1><p>在多路复用IO模型中，会有一个线程不断去轮询多个socket的状态，只有当socket真正有读写事件时，才真正调用实际的IO读写操作。因为在多路复用IO模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket读写事件进行时，才会使用IO资源，所以它大大减少了资源占用。</p><p><img src="https://s2.loli.net/2022/04/25/iv6pY2mCSgrLITz.png" alt="image.png"></p><p><img src="https://s2.loli.net/2022/04/25/rLRUK5cNad8MHgk.png" alt="image.png"></p><h1 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h1><h2 id="大端存储-Big-Endian"><a href="#大端存储-Big-Endian" class="headerlink" title="大端存储(Big-Endian)"></a>大端存储(Big-Endian)</h2><p>数据的高字节存储在低地址中，数据的低字节存储在高地址中。网络字节序采用大端存储。</p><h2 id="小端存储-Little-Endian"><a href="#小端存储-Little-Endian" class="headerlink" title="小端存储(Little-Endian)"></a>小端存储(Little-Endian)</h2><p>数据的高字节存储在高地址中，数据的低字节存储在低地址中 。主机字节序采用小端存储。</p><p><strong>uint31_t  htonl(uint31_t hostlong)：</strong>本地字节序转网络字节序函数。（转IP）。</p><p><strong>uint16_t  htons(uint16_t hostshort)：</strong>本地字节序转网络字节序函数。（转port）。</p><p><strong>uint31_t ntohl(uint31_t netlong)：</strong>网络字节序转本地字节序函数。（IP）</p><p><strong>uint16_t ntohl(uint16_t netlong)：</strong>网络字节序转本地字节序函数。（port）</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OS小知识点</title>
      <link href="2022/03/04/OS%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>2022/03/04/OS%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="MMU（内存管理单元）"><a href="#MMU（内存管理单元）" class="headerlink" title="MMU（内存管理单元）"></a>MMU（内存管理单元）</h1><p><img src="https://s2.loli.net/2022/03/04/1L35G4UghYlkuc8.png" alt="QQ截图20220304133224.png"></p><p><img src="https://s2.loli.net/2022/03/04/Pg6hLpMdvDy9Bzu.png" alt="MMU.png"></p><p>MMU作用：</p><ul><li>虚拟内存与物理内存映射。</li><li>设置修改内存访问级别。</li></ul><h1 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h1><p>​        操作系统是管理计算机硬件和软件资源的计算机程序，提供一个计算机用户与计算机硬件系统之间的接口。</p><p>​        向上对用户程序提供接口，向下接管硬件资源。</p><p>​        操作系统本质也是一个软件，作为最接近硬件的系统软件，负责处理器管理、存储器管理、设备管理、文件管理和提供用户接口。</p><h1 id="操作系统有哪些分类"><a href="#操作系统有哪些分类" class="headerlink" title="操作系统有哪些分类"></a>操作系统有哪些分类</h1><ul><li>批处理操作系统</li><li>分时操作系统</li><li>实时操作系统</li><li>通用操作系统：兼顾批操作和分时功能，如Windows，Linux，MacOS等。</li></ul><h1 id="内核态和用户态"><a href="#内核态和用户态" class="headerlink" title="内核态和用户态"></a>内核态和用户态</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>​        为了避免操作系统和关键数据被用户程序破坏，将处理器执行状态分为内核态和用户态。</p><ul><li>内核态是操作系统管理程序执行时所处的状态，能够执行包含特权指令在内的一切指令，能够访问系统内所有的存储空间。</li><li>用户态是用户程序执行时处理器所处的状态，不能执行特权指令，只能访问用户地址空间。</li><li>用户程序运行在用户态，操作系统内核运行在内核态。</li></ul><h2 id="如何转换"><a href="#如何转换" class="headerlink" title="如何转换"></a>如何转换</h2><p>​        处理器从用户态切换到内核态的方法有三种：系统调用（软中断）、异常（内中断）和外部中断（硬中断）。</p><ul><li><p>系统调用</p><ul><li>是操作系统的最小功能单位，是操作系统提供的用户接口，系统调用本身是一种软中断。</li><li>这是处于用户态的进程主动请求切换到内核态的一种方式。用户态的进程通过系统调用申请使用操作系统提供的系统调用例程来处理任务。而系统调用的机制，其核心仍是使用了操作系统为用户特别开发的一个中断机制来实现，即软中断。</li></ul></li><li><p>异常</p><ul><li>也叫内中断，是由错误引起。</li><li>当CPU执行运行在用户态下的程序时，发生了某些事先不可知的异常，如文件损坏、缺页故障等，这时会触发由当前运行的进程切换到处理此异常的内核相关程序中，也就是转到内核态。</li></ul></li><li><p>外部中断</p><ul><li>是通过两根信号线来通知处理器外设的状态变化，是硬中断。</li><li>当外围设备完成用户请求的操作后，会向CPU发出相应中断信号，这时CPU会暂停执行下一条即将执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换过程自然也就发生了由用户态到内核态的转换。比如硬盘读写操作完成时，系统会切换到硬盘读写的中断处理程序中执行后续操作。</li></ul></li></ul><h1 id="并发和并行的区别"><a href="#并发和并行的区别" class="headerlink" title="并发和并行的区别"></a>并发和并行的区别</h1><ul><li>并发：指宏观上看起来两个程序在同时运行，比如单核CPU的多任务，但是微观上两个程序指令是交织进行，在单个周期内只运行一个指令。这种并发并不能提高计算机性能，只能提高效率（降低某个进程的响应时间）。</li><li>并行：指严格意义上的同时运行，比如多核CPU，两个程序分别运行在两个核上，两者互不影响，单个周期内每个程序都运行了自己的指令，也就是执行了两条指令。这样说来并行的确的提高了计算机效率，所以目前的CPU都是朝着多核方向发展。</li></ul><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>死锁是指多个进程在执行过程中，因争夺资源而造成的互相等待的现象。</p><ul><li>锁了又锁，自己加了一次锁后，又锁一次。</li><li>交叉锁</li></ul><h2 id="如何产生"><a href="#如何产生" class="headerlink" title="如何产生"></a>如何产生</h2><p>产生死锁的四个条件：</p><ul><li>互斥条件：进程对分配到的资源不允许其他进程访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源。</li><li>请求和保持条件：进程获得一定的资源后，又对其他资源发出请求，但是该资源可能被其他进程占有，此时请求阻塞，但该进程不会释放自己已经占有的资源。</li><li>不可抢占条件，进程已获得的资源，在未完成使用之前，不可以剥夺，只能在使用后自己释放。</li><li>循环等待条件：进程发生死锁后，必然存在一个进程-资源之间的环形链。</li></ul><h2 id="防止死锁"><a href="#防止死锁" class="headerlink" title="防止死锁"></a>防止死锁</h2>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++小知识点</title>
      <link href="2022/02/27/C++%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>2022/02/27/C++%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h1><ul><li>指针所指向的内存空间在程序运行过程中可以改变，而引用所绑定的对象一旦绑定就不能改变（是否可变）。</li><li>指针本身在内存中占有内存空间，引用相当于变量别名，而在内存中不占内存空间（是否占内存）。</li><li>指针可以为空，但是引用必须绑定对象（是否可空）。</li><li>指针可以有多级，但是引用只能一级（是否能多级）。</li></ul><h1 id="sizeof和strlen区别"><a href="#sizeof和strlen区别" class="headerlink" title="sizeof和strlen区别"></a>sizeof和strlen区别</h1><ul><li><p>strlen 是函数，sizeof 是运算符。</p></li><li><p>strlen 测量的是字符的实际长度，以’\0’ 结束（不包含’\0’ ）。而sizeof 测量的是字符的分配大小，如果未分配大小，则遇到’\0’ 结束（包含’\0’ ，也就是strlen测量的长度加1），如果已经分配内存大小，返回的就是分配的内存大小。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[] = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> str1[<span class="number">100</span>] = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"> </span><br><span class="line">cout &lt;&lt; <span class="built_in">strlen</span>(str) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(str) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(str1) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190929145538553.png" alt="img"></p><h1 id="不能声明为虚函数的函数"><a href="#不能声明为虚函数的函数" class="headerlink" title="不能声明为虚函数的函数"></a>不能声明为虚函数的函数</h1><p><strong>1，普通函数（非成员函数）</strong>：定义虚函数的主要目的是为了重写达到多态，所以普通函数声明为虚函数没有意义，因此编译器在编译时就绑定了它。<br><strong>2，静态成员函数</strong>：静态成员函数对于每个类都只有一份代码，所有对象都可以共享这份代码，他不归某一个对象所有，所以它也没有动态绑定的必要。,<br><strong>3，内联成员函数</strong>：内联函数本就是为了减少函数调用的代价，所以在代码中直接展开。但虚函数一定要创建虚函数表，这两者不可能统一。另外，内联函数在编译时被展开，而虚函数在运行时才动态绑定。<br><strong>4，构造函数</strong>：这个原因很简单，主要从语义上考虑。因为构造函数本来是为了初始化对象成员才产生的，然而虚函数的目的是为了在完全不了解细节的情况下也能正确处理对象，两者根本不能“ 好好相处 ”。因为虚函数要对不同类型的对象产生不同的动作，如果将构造函数定义成虚函数，那么对象都没有产生，怎么完成想要的动作？？</p><p><strong>5，友元函数</strong>：当我们把一个函数声明为一个类的友元函数时，它只是一个可以访问类内成员的普通函数，并不是这个类的成员函数，自然也不能在自己的类内将它声明为虚函数。</p><p>注意：友元本身可以是虚函数！！<br>如果一个类的友元函数是另一个类成员函数，那么它在自己的类内可以被声明为虚函数。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>适配器</title>
      <link href="2022/02/25/%E9%80%82%E9%85%8D%E5%99%A8/"/>
      <url>2022/02/25/%E9%80%82%E9%85%8D%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h1><h2 id="函数适配器"><a href="#函数适配器" class="headerlink" title="函数适配器"></a>函数适配器</h2><p><strong>一元转二元：</strong></p><ul><li>bind2nd 绑定第二个参数。</li><li>继承binary_function&lt;参数类型1, 参数类型2, 返回值类型&gt;。</li><li>const修饰operator()。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrint</span>:</span> <span class="keyword">public</span> binary_fuction&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">void</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> start)</span>  <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; num+start &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; a&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    cin&lt;&lt;start;</span><br><span class="line">    for_each(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">MyPront</span>(), start));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="取反适配器"><a href="#取反适配器" class="headerlink" title="取反适配器"></a>取反适配器</h2><p>一元取反：</p><ul><li>not1()。</li><li>继承unary_function&lt;参数类型1,  返回值类型 &gt;。</li><li>const修饰。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreaterFive</span>:</span> <span class="keyword">public</span> unary_function&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt; <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 一元取反</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">not1</span>(<span class="built_in">GreatrerFive</span>()));  <span class="comment">//  找不大于5的 返回0。</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数指针适配器"><a href="#函数指针适配器" class="headerlink" title="函数指针适配器"></a>函数指针适配器</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyPrint03</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; v+ start &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tets03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">ptr_fun</span>(<span class="built_in">MyPrint03</span>()), <span class="number">100</span>)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="成员函数适配器"><a href="#成员函数适配器" class="headerlink" title="成员函数适配器"></a>成员函数适配器</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">int</span> age) : <span class="built_in">mAge</span>(age) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; mAge &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;Person&gt; p;</span><br><span class="line">    p.<span class="built_in">push_back</span>(<span class="built_in">Person</span>(<span class="number">1</span>));</span><br><span class="line">    p.<span class="built_in">push_back</span>(<span class="built_in">Person</span>(<span class="number">2</span>));</span><br><span class="line">    p.<span class="built_in">push_back</span>(<span class="built_in">Person</span>(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    for_each(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>(), <span class="built_in">mem_fun_ref</span>(&amp;Person::showAge));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 适配器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>仿函数、谓词和lambda表达式</title>
      <link href="2022/02/25/%E4%BB%BF%E5%87%BD%E6%95%B0%E3%80%81%E8%B0%93%E8%AF%8D%E5%92%8Clambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>2022/02/25/%E4%BB%BF%E5%87%BD%E6%95%B0%E3%80%81%E8%B0%93%E8%AF%8D%E5%92%8Clambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="函数对象（仿函数）"><a href="#函数对象（仿函数）" class="headerlink" title="函数对象（仿函数）"></a>函数对象（仿函数）</h1><p>​        重载函数调用操作符的类，其对象称为函数对象，即其行为类似函数的对象，又称为仿函数。重载了“（）”使其可以向函数一样调用。</p><p><strong>注意 ：</strong></p><ul><li>函数对象（仿函数）是一个类，不是一个函数。</li><li>函数对象（仿函数）重载了“（）”使其可以向函数一样调用。</li></ul><p><strong>分类：</strong></p><ul><li>一元仿函数：一个参数。</li><li>二元仿函数：两个参数。</li></ul><h1 id="内建仿函数"><a href="#内建仿函数" class="headerlink" title="内建仿函数"></a>内建仿函数</h1><ul><li>头文件：<code>#include&lt;functional&gt;</code></li><li>取反仿函数：<code>template&lt;class T&gt; T negate&lt;T&gt;</code></li><li>加法仿函数：<code>template&lt;class T&gt; T plus&lt;T&gt;</code> </li><li>大于仿函数：<code>template&lt;class T&gt; bool greater&lt;T&gt;</code></li><li>小于仿函数：<code>template&lt;class T&gt; bool less&lt;T&gt;</code></li><li>….</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">negate&lt;<span class="keyword">int</span>&gt; n;</span><br><span class="line">cout &lt;&lt; <span class="built_in">n</span>(<span class="number">10</span>) &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    plus&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">plus</span>(<span class="number">1</span>,<span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; a &#123;<span class="number">1</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());  <span class="comment">// 7 7 6 4 3 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h1><p>​        谓词就是一个判断式，是一个返回bool类型的函数，或者也可以是函数对象（仿函数）。一个参数是一元谓词，两个参数是二元谓词。</p><h1 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h1><ul><li>写法：<code>[捕获列表](参数列表) &#123; 函数内容 &#125;</code>。</li><li>捕获列表是lambda所在函数中定义的局部变量的列表。</li><li>捕获作用：若某算法的可调用表达式是一元谓词但是需要多个参数时则可用捕获。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 仿函数 </tag>
            
            <tag> 谓词 </tag>
            
            <tag> lambda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础知识点</title>
      <link href="2022/02/24/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>2022/02/24/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><table><thead><tr><th>命令</th><th>执行操作</th></tr></thead><tbody><tr><td>history</td><td>查看历史命令</td></tr><tr><td>ls</td><td>查看文件目录    -l 显示详细信息    -a 显示隐藏目录    -R递归显示子目录信息</td></tr><tr><td>cd</td><td>更改目录</td></tr><tr><td>pwd</td><td>查看当前的工作目录</td></tr><tr><td>mkdir</td><td>创建目录</td></tr><tr><td>tree</td><td>目录成树状显示</td></tr><tr><td>rmdir</td><td>删除目录，只能删非空目录</td></tr><tr><td>which</td><td>显示对应命令所在的路径</td></tr><tr><td>touch</td><td>创建文件，如果不存在创建，如果存在则只更改访问时间</td></tr><tr><td>rm</td><td>删除文件或者目录  -r 递归删除子目录    rm -rf * 强制删除目录下所有内容</td></tr><tr><td>cp</td><td>拷贝文件或者目录</td></tr><tr><td>mv</td><td>移动文件或者目录</td></tr><tr><td>cat</td><td>直接显示文件信息</td></tr><tr><td>more和less</td><td>分屏显示文件信息</td></tr><tr><td>head</td><td>head -n file 显示文件头n行，不加-n默认10行</td></tr><tr><td>tail</td><td>tail -n file 显示文件后n行；tail -f file 查看文件尾部内容，不退出，用于追踪日志</td></tr><tr><td>du</td><td>-h 查看文件占用空间</td></tr><tr><td>ln</td><td>建立硬连接   ln hello hello.hard1   见下图 ；  ln -s hello hello.hard3  建立软连接</td></tr><tr><td>unlink</td><td>删除软硬连接</td></tr><tr><td>chmod</td><td>改变文件权限</td></tr><tr><td>chown</td><td>改变文件所属权限  sudo chown   用户：组  文件名|目录</td></tr><tr><td>find</td><td>find dir [opt] 内容     opt：-name  -type  -size        按名字、类型、大小找文件</td></tr><tr><td>grep</td><td>过滤信息</td></tr><tr><td>xargs</td><td>将前一目录的输出分成小块输入给后面的命令</td></tr><tr><td>zip</td><td>zip -r zipname.zip filename1 filename2 …   压缩文件  -r递归子目录</td></tr><tr><td>unzip</td><td>unzip zipname.zip  解压文件</td></tr><tr><td>tar</td><td>tar zcvf zipname.tar.gz filename1 filename2 …  压缩文件 <br />tar zxvf zipname.tar.gz  解压文件</td></tr><tr><td>rar</td><td>rar a -r rarname（可以无后缀） filename1 filename2 …  压缩文件<br />rar x rarname.rar 解压文件</td></tr><tr><td>ps</td><td>ps aux 查看进程信息<br />ps ajk  也是查看进程信息，可以追溯进程之间的血缘关系</td></tr><tr><td>kill</td><td>给进程发送一个信号<br /> kill -9 pid  杀死进程</td></tr></tbody></table><h1 id="小知识点"><a href="#小知识点" class="headerlink" title="小知识点"></a>小知识点</h1><p><strong>通配符*和？：</strong>* 代表任意多个字符，? 代表任意一个字符。</p><p><strong>相对路径和绝对路径：</strong> 以”/“开头为绝对路径，否则为相对路径。 </p><p><font color=red>linux一切皆文件。</font></p><p><strong>文件权限表示法：</strong></p><p><img src="https://s2.loli.net/2022/02/26/aCGT69pZHrv8cnO.png" alt="image.png"></p><p><strong>硬连接和软连接：</strong></p><ul><li>在Linux中，在磁盘分区中的文件不管什么类型都有一个编号， 叫索引节点号。Linux中可以多个文件名指向同一个索引节点，这种方式就叫硬连接，硬连接作用就是可以一个文件拥有多个有效的路径名，防止误删，只有当对应索引节点的所有硬连接全被删除之后，文件的数据块才会被释放。</li><li>软连接就类似于windows快捷方式，删了对硬连接无影响，硬连接全没了，软连接也就失效了。</li></ul><p><img src="https://s2.loli.net/2022/02/26/dSngu69ODZKw2Vp.png" alt="image.png"></p><p><strong>类unix系统目录结构：</strong></p><p><img src="https://s2.loli.net/2022/02/26/NRCgm4r6dMULqFb.png" alt="image.png"></p><p><strong>进程的虚拟地址空间</strong></p><p><img src="https://s2.loli.net/2022/03/03/yKps2PtraMoSBZG.png" alt="QQ截图20220303111420.png"></p><h1 id="GCC流程"><a href="#GCC流程" class="headerlink" title="GCC流程"></a>GCC流程</h1><ul><li><strong>示例代码</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="keyword">int</span> main（<span class="keyword">void</span>） &#123;</span><br><span class="line"><span class="built_in">printf</span>（<span class="string">&quot;hello\n&quot;</span>）;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>预编译过程</strong></li></ul><p>这个过程处理宏定义和include，去除注释，不会对语法进行检查。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E a.c -o a.i</span><br></pre></td></tr></table></figure><ul><li><strong>编译过程</strong></li></ul><p>这个阶段，检查语法，生成汇编代码。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S a.i -o a.s</span><br></pre></td></tr></table></figure><ul><li><strong>汇编过程</strong></li></ul><p>这个阶段，生成目标代码。</p><p>此过程生成ELF格式的目标代码。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c a.s -o a.o</span><br></pre></td></tr></table></figure><ul><li><strong>链接过程</strong></li></ul><p>链接过程。生成可执行代码。链接分为两种，一种是静态链接，另外一种是动态链接。使用静态链接的好处是，依赖的动态链接库较少，对动态链接库的版本不会很敏感，具有较好的兼容性；缺点是生成的程序比较大。使用动态链接的好处是，生成的程序比较小，占用较少的内存。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc a.o -o a</span><br><span class="line">./a</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200607142556997.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcxODc5NA==,size_16,color_FFFFFF,t_70" alt="image.png"></p><p><strong>动态库和静态库制作流程：</strong><a href="https://blog.csdn.net/weixin_44718794/article/details/106599417">https://blog.csdn.net/weixin_44718794/article/details/106599417</a></p><h1 id="Makefile文件编写"><a href="#Makefile文件编写" class="headerlink" title="Makefile文件编写"></a>Makefile文件编写</h1><ul><li><p>命名规则：makefile  Makefile</p></li><li><p>写法：</p><ul><li>目标：依赖</li><li>Tab键 规则命令</li></ul></li><li><p>Eg（第一版 ）：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">app:main.c add.c sub.c div.c mul.c</span></span><br><span class="line">gcc -o app -I ./<span class="keyword">include</span> main.c add.c sub.c div.c mul.c</span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line"><span class="comment"># make -f makefilename 可以指定具体的makefile文件</span></span><br></pre></td></tr></table></figure><p>如果更改其中一个，所有源码都重新编译。</p><p>Eg（第二版 ）：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># objFlies 定义的目标文件</span></span><br><span class="line">objFiles=main.o add.o sub.o div.o mul.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标文件用法 $（var）</span></span><br><span class="line"><span class="section">app:<span class="variable">$(objFiles)</span></span></span><br><span class="line">gcc -o app -I ./<span class="keyword">include</span> main.o add.o sub.o div.o mul.o</span><br><span class="line"></span><br><span class="line"><span class="section">main.o:main.c</span></span><br><span class="line">gcc -c main.c -I./<span class="keyword">include</span></span><br><span class="line"><span class="section">add.o:add.c</span></span><br><span class="line">gcc -c add.c -I./<span class="keyword">include</span></span><br><span class="line"><span class="section">sub.o:sub.c</span></span><br><span class="line">gcc -c sub.c -I./<span class="keyword">include</span></span><br><span class="line"><span class="section">div.o:div.c</span></span><br><span class="line">gcc -c div.c -I./<span class="keyword">include</span></span><br><span class="line"><span class="section">mul.o:mul.c</span></span><br><span class="line">gcc -c mul.c -I./<span class="keyword">include</span></span><br></pre></td></tr></table></figure><p>makefile隐含规则：默认处理第一个目标。</p><p>Eg（第三版 ）：</p><ul><li>函数：<ul><li>wildcard 进行文件匹配。</li><li>patsubst 内容替换。</li></ul></li><li>makefile变量：<ul><li>$@ 代表目标。</li><li>$^ 代表全部依赖。</li><li>$&lt; 代表第一个依赖。</li><li>$? 代表第一个变化的依赖 。</li></ul></li><li>@在规则前代表不输出该条规则的命令。</li><li>-在规则前代表该条规则报错，仍然继续执行。</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">SecFiles =<span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line"></span><br><span class="line">objFiles=<span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,<span class="variable">$(SrcFiles)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标文件用法 $（var）</span></span><br><span class="line"><span class="section">app:<span class="variable">$(objFiles)</span></span></span><br><span class="line">gcc -o app -I ./<span class="keyword">include</span> <span class="variable">$(objFiles)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># $@,$&lt;只能在规则中出现</span></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">gcc -c <span class="variable">$&lt;</span> -I ./<span class="keyword">include</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义伪目标，防止有歧义</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:clean all</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm *.o</span><br><span class="line">rm app</span><br></pre></td></tr></table></figure></li></ul><h1 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h1><ul><li>启动gdb:<code>gdb app</code>app为对应程序名。</li><li>在gdb启动程序：<ul><li><code>r(un)</code> 启动。</li><li><code>start</code> 启动-停留在 main函数，分步调试。</li><li><code>n(ext)</code> 下一条指令。</li><li><code>s(tep)</code> 下一条指令，可以进入函数内部，库函数不能进。</li><li><code>q(uit)</code> 退出。</li><li><code>b(reak)</code> n 在主函数所在文件 第n行设置断点， <code>b func</code> 在func函数设置断点， <code>b main.cpp:2=10</code> 在某个文件某一行设置断点；<code>b main.cpp:2=10 if i==0</code>设置条件断点。</li><li><code>l(ist)</code> 查看主函数对应文件，<code>list func.cpp:1</code>看func从第一行 。</li><li><code>info b</code> 查看断点。</li><li><code>d(el)  n</code> 删除断点，n对应info b里的第几个 断点。</li><li><code>c(ontinue)</code> 跳到下一断点。</li><li><code>p(rint) context </code>打印context的内容。</li><li><code>ptype x</code>  打印x类型。</li><li><code>set</code> 设置变量值。</li><li><code>display argc</code> 执行任何一个指令argc的值都显示一下。</li><li><code>undisplay n</code>不显示display，n代表display的那个行号，也可以通过info display查看。</li></ul></li><li>gdb追踪core<ul><li>查看core文件大小 ：<code>ulimit -c</code></li><li>设置生成core文件大小：<code>ulimit -c unlimited</code> 设置无限大</li><li>gdb app core<ul><li>where 查看错误在哪。</li></ul></li></ul></li></ul><h1 id="umask"><a href="#umask" class="headerlink" title="umask"></a>umask</h1><ul><li>设置文件没有的权限。</li><li>用户默认创建文件的最高权限为666。</li><li>用户默认创建目录的最高权限为777。</li></ul><h1 id="Linux库函数"><a href="#Linux库函数" class="headerlink" title="Linux库函数"></a>Linux库函数</h1><p><strong>open：</strong></p><ul><li>查看 man 2 open</li><li><code>int open(const char *pathname, int flags);</code></li><li><code>int open(const char *pathname, int flags, mode_t mode);</code><ul><li>pathname 文件名</li><li>flags<ul><li>必选项<ul><li>O_RDONLY  只读。</li><li>O_WRONLY 只写。</li><li>O_RWR         读写。</li></ul></li><li>可选项<ul><li>O_APPEND 追加。</li><li>O_CREAT    创建文件。<ul><li>O_EXCL 与 O_CREAT 如果文件存在报错。</li><li>创建的文件权限是（mode&amp;~umask）。</li></ul></li><li>O_NONBLOCK  非阻塞。</li></ul></li></ul></li></ul></li><li>返回值：返回一个新的文件描述符，返回的是当前最小可用的文件描述符。失败返回-1，设置errno。</li><li>注意：在打开fifo文件时read端会阻塞等待write端open，write端同理，也会阻塞的能带另一端打开。</li></ul><p><strong>close</strong>：</p><ul><li><code>int close(int fd);</code> 关闭文件描述符。</li><li>返回值：成功返回0，失败返回-1。</li></ul><p><strong>read：</strong></p><ul><li><code> ssize_t read(int fd, void *buf, size_t count);</code></li><li>fd          文件描述符</li><li>buf        缓冲区</li><li>count    缓冲区大小</li><li>返回值：<ul><li>失败返回-1，设置errno。</li><li>成功返回读的大小。</li><li>0代表读到文件末尾。</li><li>非阻塞的情况下，read返回-1，但是此时需要判断errno的值。</li></ul></li></ul><p><strong>write：</strong></p><ul><li><code>ssize_t write(int fd, const void *buf, size_t count);</code></li><li>fd          文件描述符</li><li>buf        缓冲区</li><li>count    缓冲区大小</li><li>返回值：失败返回-1，设置errno；成功返回写入的字节数；0代表未写入。 </li></ul><p><strong>lseek:</strong></p><ul><li><p><code>off_t lseek(int fd, off_t offset, int whence);</code></p></li><li><p>fd 文件描述符</p></li><li><p>offset 偏移量 设0</p></li><li><p>whence </p><ul><li>SEEK_SET  文件开始位置    </li><li>SEEK_CUR 当前位置</li><li>SEEK_END 结尾</li></ul></li><li><p>返回值：成功返回当前位置到开始的长度；失败返回-1，设置errno。</p></li><li><p>函数作用：</p><ul><li>移动文件读写位置。</li><li>计算文件大小。</li><li>拓展文件。</li></ul></li></ul><p><strong>阻塞的概念：</strong></p><ul><li>read函数在读设备或者读管道或者读网络的时候。</li></ul><p><strong>fcntl：</strong></p><ul><li><p><code>int fcntl(int fd, int cmd, ... /* arg */ );</code></p></li><li><pre><code class="c++">int fd = open(&quot;/dev/tty&quot;, O_RDWR)// 设置非阻塞int flags = fcntl(fd, F_GETFL);flags |= O_NONBLOCK;fcntl(fd, F_SETFL, flags);</code></pre></li></ul><p><strong>stat:</strong></p><ul><li><p><code>int stat(const char *pathname, struct stat *statbuf);</code>获得文件信息。</p></li><li><p>函数参数</p><ul><li>pathname 文件名。</li><li>statbuf       传出参数。</li></ul></li><li><p>返回值：成功返回0，失败返回-1，设置errno。</p></li><li><p>lstat和stat：stat会穿透到源文件，lstat不会。</p></li></ul><p><strong>access：</strong></p><ul><li>判断文件权限和文件是否存在。具体用法百度。</li></ul><p><strong>truncate：</strong></p><ul><li>截断文件。用法百度。</li></ul><p><strong>link系列函数：</strong></p><ul><li>创建删除软硬连接，读取连接。用法百度。</li></ul><p><strong>rename：</strong></p><ul><li>重命名函数。</li></ul><p><strong>getcwd：</strong></p><ul><li>获取当前工作路径。</li></ul><p><strong>chdir：</strong></p><ul><li>改变进程工作路径。</li></ul><p><strong>mkdir、rmdir、opendir、readdir、closedir：</strong></p><ul><li>创建删除打开读关闭 dir。</li></ul><p><strong>dup2和dup:</strong></p><ul><li>主要用于重定向。</li><li><code>int dup2(int oldfd, int newfd);</code><ul><li>把newfd指向oldfd。</li><li>成功返回newfd，失败返回-1，设置errno。</li></ul></li><li><code>int dup(int oldfd);</code><ul><li>新生成一个fd指向oldfd，新生成的fd是当前可用最小的。</li><li>返回值为新的fd。</li></ul></li></ul><p><strong>execl和execlp：</strong></p><ul><li><code>int execl(const char *path, const char *arg, .../* (char  *) NULL */);</code><ul><li>执行其他程序，需要加路径。</li><li>Eg：<code>execl(&quot;./bin/ls&quot;, &quot;ls&quot;, &quot;-l&quot;, NULL);</code></li></ul></li><li><code>int execlp(const char *file, const char *arg, .../* (char  *) NULL */);</code><ul><li>执行程序，使用当前PATH环境变量，可以不用加路径。</li><li>Eg：<code>execl(&quot;ls&quot;, &quot;ls&quot;, &quot;-l&quot;, NULL);</code></li></ul></li><li>path/file 为要执行的程序。</li><li>arg参数列表<ul><li>列表最后要一个NULL结尾。</li></ul></li><li>返回值：只有失败才返回。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> GCC </tag>
            
            <tag> makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++STL</title>
      <link href="2022/02/23/STL/"/>
      <url>2022/02/23/STL/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>​        STL广义上分为：容器（container）、算法（algorithm）、迭代器（iterator）。容器和算法通过迭代器进行无缝连接。</p><p>​        STL细分为六大组件：容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器。</p><ul><li>容器：各种数据结构，如vector、list、deque、set、map等，用来存放数据。从实现角度看，STL容器是一种class template。</li><li>算法：各种常用算法，如sort、find、copy、for_each。从实现角度看，STL算法是一种function template。</li><li>迭代器：扮演了容器和算法之间的调和剂，共5种类型（输入、输出、前向、双向、随机访问）。从实现角度看，迭代器是一种将operator*，operator-&gt;，operator++，operator–等指针相关操作予以重载的class template，所有的STL容器都有自己的专属迭代器。原生指针（native pointer）也是一种迭代器。</li><li>仿函数：行为类似函数，可作为算法的某种策略。从实现角度看，仿函数是一种重载了operator()的class或者class template。</li><li>适配器：一种用来修饰容器或者仿函数迭代器接口的东西。</li><li>空间配置器：负责空间的配置与管理。从实现角度看，配置器是一个实现了动态空间配置、空间管理、空间释放的class template。</li></ul><p>​        STL六大组件的交互关系：容器通过空间配置器取得数据存储空间，算法通过迭代器存储容器中的内容，仿函数可以协助算法完成不同策略得变化，适配器可以修饰仿函数。</p><h1 id="STL优点"><a href="#STL优点" class="headerlink" title="STL优点"></a>STL优点</h1><ul><li>STL为C++一部分，不用额外安装。</li><li>STL一个重要特性是将数据和操作分离，数据由容器类别加以管理，操作则由可定制的算法定义。迭代器在两者之间充当“粘合剂”，以使算法可以和容器交互运作。</li><li>程序员不用考虑STL内部实现，直接使用。</li><li>STL具有高可重用性，高性能，高移植性，跨平台的优点。<ul><li>高可重用性：STL几乎所有代码都采用模板类和模板函实现，相比于传统的函数和类提供了更好的代码重用机会。</li><li>高性能：如map可以高效从大量数据在检索指定记录，因为采用红黑树。</li><li>高移植性：如在项目A使用STL编写模块，可以直接移植到项目B。</li></ul></li></ul><h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><ul><li>序列式容器：强调值的顺序，每个元素均有固定位置，除非用插入删除操作改变，如vector、deque、list等。</li><li>关联式容器：非线性的二叉树结构，个元素间没有严格的物理上得顺序关系，也就是说元素在容器中并没有保存元素置入容器时的逻辑顺序。关联式容器一个显著特点：在值中选择一个值作为关键字key，key起到索引的作用，方便查找。如set、multiset、map、multimap等。 </li></ul><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><ul><li>质变算法：运算过程中改变区间内元素内容。如拷贝，替换，删除等。</li><li>非质变算法：运算过程中不改变区间内元素内容。如查找，计数，遍历等。</li></ul><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>​        提供一种方法，使之能够依序遍历某个容器所含的各个元素，而又无需暴露该容器内部的表示方式。</p><table><thead><tr><th>名称</th><th>功能</th><th>支持操作</th></tr></thead><tbody><tr><td>输入迭代器</td><td>提供对数据的只读访问</td><td>只读，支持++，–，!=</td></tr><tr><td>输出迭代器</td><td>提供对数据的只写访问</td><td>只写，支持++</td></tr><tr><td>前向迭代器</td><td>提供读写操作，并向前推进迭代器</td><td>读写，支持++，==，!=</td></tr><tr><td>双向迭代器</td><td>提供读写操作，并能向前和向后操作</td><td>读写，支持++,–，==，!=</td></tr><tr><td>随机访问迭代器</td><td>提供读写操作，并能以跳跃的方式访问容器的任意数据，功能最强。</td><td>读写，支持++，–，[n]，-n，&lt;，&lt;=，&gt;，&gt;=, ==，!=</td></tr></tbody></table><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><ul><li>s[]访问和s.at()访问区别：[]访问越界会直接挂掉，at则抛出异常。</li><li>string -&gt; const char* :   <code>const char *p = s.c_str();</code> 。</li><li>const char* -&gt; string：<code>string s2(p);</code>。</li><li>C++存在const char*到string的隐式类型转换，不存在从string到const char*的隐式类型转换。</li></ul><h1 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h1><ul><li><p>vector所谓的动态增加大小，并不是在原有空间之后虚接新空间，而是找一块更大空间，将原数据拷贝，然后释放原空间。所以一旦引起空间配置，则原有的迭代器失效。</p></li><li><p>利用swap收缩空间：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;    <span class="comment">// &gt;10000</span></span><br><span class="line">    cout &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// = 10000</span></span><br><span class="line">    </span><br><span class="line">    v.<span class="built_in">resize</span>(<span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;    <span class="comment">// &gt;10000  和之前一样</span></span><br><span class="line">    cout &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// = 3</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 巧用swap</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;(v).<span class="built_in">swap</span>(v);<span class="comment">// v初始化匿名对象，交换两个指针，然后释放掉匿名对象（那个大的就被释放了）</span></span><br><span class="line">    cout &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;    <span class="comment">// = 3  </span></span><br><span class="line">    cout &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// = 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>reserve(int len);</code>容器预留len个元素长度，预留位置不初始化，元素不可访问。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(p != &amp;v[<span class="number">0</span>]) &#123;  <span class="comment">// 查看开辟10万个数据重新开辟多少次空间。</span></span><br><span class="line">            p = &amp;v[<span class="number">0</span>];</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; num &lt;&lt; endl; <span class="comment">// &gt;1,好多次</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 改进：</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    v1.<span class="built_in">reserve</span>(<span class="number">100000</span>);</span><br><span class="line">    <span class="keyword">int</span> *p1 = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(p1 != &amp;v[<span class="number">0</span>]) &#123;  <span class="comment">// 查看开辟10万个数据重新开辟多少次空间。</span></span><br><span class="line">            p1 = &amp;v[<span class="number">0</span>];</span><br><span class="line">            num1++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; num1 &lt;&lt; endl; <span class="comment">//  = 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>s[]访问和s.at()访问区别：[]访问越界会直接挂掉，at则抛出异常。</p></li></ul><h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><ul><li>没有迭代器，不提供遍历功能。</li></ul><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><ul><li><p>双向循环链表。</p></li><li><p>不支持随机访问。</p></li><li><p>所有不支持随机访问的迭代器，不可以用系统提供的算法，但是这个类内部会提供。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="keyword">int</span>&gt; L&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(L.<span class="built_in">begin</span>(), L.<span class="built_in">end</span>());  <span class="comment">// 报错</span></span><br><span class="line">L.<span class="built_in">sort</span>();</span><br></pre></td></tr></table></figure></li></ul><h1 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h1><h2 id="优先队列使用lambda表达式"><a href="#优先队列使用lambda表达式" class="headerlink" title="优先队列使用lambda表达式"></a>优先队列使用lambda表达式</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> cmp = [&amp;nums1, &amp;nums2](<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp; a, <span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp; b) &#123;</span><br><span class="line">    <span class="keyword">return</span> nums1[a.first] + nums2[a.second] &gt; nums1[b.first] + nums2[b.second];</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">que</span>(cmp);</span><br></pre></td></tr></table></figure><ul><li>decltype 类型指示符，返回函数的返回值类型。</li><li>在初始化priority_queue时，&lt;&gt;中的三个参数必须都是类型名，而cmp为实例化的对象，所以加decltype进行转换。</li><li>que后加（cmp）原因是priority_queue内部实现的时候是根据&lt;&gt;第三个参数实例化一个对象，也就是需要调用其默认构造函数，但是因为lambda这种特殊的class没有默认构造函数，所以需要调用其拷贝构造函数，priority_queue内部定义了这种实现方式，就是通过que(cmp)传入cmp（lambda对象）来直接进行排序操作。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程、线程和信号</title>
      <link href="2022/02/22/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/"/>
      <url>2022/02/22/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>​        进程是操作系统中最重要的抽象概念之一，是资源分配的基本单位，是独立运行的基本单位。</p><p>​        进程的经典定义就是一个执行中程序的实例。系统中的每个程序（程序就是编译好的二进制文件）都运行在某个进程的上下文（context）中。上下文是由程序正确运行所需的状态组成。这个状态包括存放在内存中的程序代码和数据，他的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。</p><p>进程一般由以下部分组成：</p><ul><li>进程控制块PCB，是进程存在的唯一标志，包含进程标识符PID、进程当前状态、程序、数据地址、进程优先级、CPU现场保护区（用于进程切换）、占有的资源清单等等。</li><li>程序段。</li><li>数据段。</li></ul><h2 id="进程和程序"><a href="#进程和程序" class="headerlink" title="进程和程序"></a>进程和程序</h2><ul><li>程序是编译好的二进制文件。</li><li>进程是运行着的程序。从程序员角度，进程是运行一系列指令的过程。从操作系统角度，进程是资源分配的基本单位，是独立运行的基本单位。</li><li>区别：<ul><li>程序占用磁盘，不占用系统资源。</li><li>进程占用内存，占用系统资源。</li><li>一个程序可以对应多个进程，一个进程只能对应一个程序。</li><li>程序没有生命周期，进程有。</li></ul></li></ul><h2 id="简述进程间通信方法"><a href="#简述进程间通信方法" class="headerlink" title="简述进程间通信方法"></a>简述进程间通信方法</h2><p>​        每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程A把数据从用户空间拷到内核缓冲区，进程B再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信。</p><p>​        不同进程间的通信本质：进程之间可以看到一份公共资源；而提供这份资源的形式或者提供者不同，造成了通信方式的不同。</p><p>​        进程间通信主要包括管道、系统IPC（包括消息队列、信号量、信号、共享内存等）以及套接字socket。</p><h2 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h2><ul><li>IPC：Inter Process Communication进程间通信，通过内核提供的缓冲区进行数据交换的机制。</li><li>常见通信方式：单工（广播），半双工（对讲机），全双工（打电话）。</li><li>IPC通信方式：<ul><li>pipe             管道–只支持有血缘关系的进程间通信，半双工通信。</li><li>fifo               有名管道–不同进程间也可以通信。</li><li>mmap          文件映射（共享）IO–速度最快。</li><li>本地socket  最稳定。</li><li>信号              携带信息量最小。</li><li>共享内存    </li><li>消息队列</li></ul></li></ul><h2 id="进程的状态与状态转换"><a href="#进程的状态与状态转换" class="headerlink" title="进程的状态与状态转换"></a>进程的状态与状态转换</h2><p>进程在运行时有三种基本状态：就绪态、运行态和阻塞态。（五态模型还有新建态和终止态）。</p><ul><li>运行态：进程占有处理器正在运行的状态。进程已获得CPU，其程序正在执行。在单处理机系统中，只有一个进程处于执行状态；在多处理机系统中，则有多个进程处于执行状态。</li><li>就绪态：进程具备运行条件，等待系统分配处理器以便运行的状态。当进程已分配到除CPU以外的所有必要资源后，只要再获得CPU，便可立即执行，进程这时的状态称为就绪态。在一个系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列。</li><li>阻塞态：又称为等待态或睡眠态，指进程不具备运行条件，正在等待某个时间完成的状态。</li></ul><p>各状态之间的转换：</p><p><img src="https://s2.loli.net/2022/03/09/p9TfiQYyzcDGXF2.png" alt="进程状态转换"></p><ul><li>就绪→执行：处于就绪状态的进程，当进程调度程序为之分配了处理机后，该进程便由就绪状态转变成运行状态。</li><li>执行→就绪：处于运行态程序在执行过程中，因分配给他的一个时间片用完而不得不让出CPU，遇是进程从运行态转变成就绪态。</li><li>执行→阻塞：正在执行的进程因等待某种事件发生而无法继续执行时，便从执行状态变成阻塞态。</li><li>阻塞→就绪：处于阻塞态的进程，若等待的事件已经发生，于是进程由阻塞状态转变为就绪态。</li></ul><h2 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h2><p>​        管道是一种最基本的IPC机制，作用域有血缘关系的进程之间，完成数据传递。调用pipe系统函数即可创建一个管道，有如下特质：</p><ul><li>其本质是一个伪文件（实为一个内核缓冲区）。</li><li>有两个文件描述符引用，一个表示读端，一个表示写端，</li><li>规定数据从管道的写端流入管道，从读端流出。</li></ul><p><strong>管道原理：</strong>管道实为内核使用环形队列机制，借助内核缓冲区实现。</p><p><strong>管道局限性：</strong></p><ul><li>数据自己读不能自己写，如果需要双向通信需要创建多根管道。 </li><li>数据一旦被读走，便不在管道中存在，不可反复读取。</li><li>由于管道采用半双工通信方式，因此数据只能在一个方向流动。</li><li>只能在有公共祖先的进程间使用管道。</li></ul><p><strong>管道函数：</strong></p><ul><li><p><code> int pipe(int pipefd[2]);</code></p><ul><li>pipefd 读写文件描述符，0代表读，1代表写。</li><li>返回值：失败-1，成功0。</li></ul></li><li><p>读管道 ：</p><ul><li>写端 全部关闭 – read读到0，相当于读到文件末尾。</li><li>写端没有全部关闭。<ul><li>有数据  – read读到数据。</li><li>无数据  – read阻塞，fcntl函数可以更改非阻塞。</li></ul></li></ul></li><li><p>写管道：</p><ul><li>读端全部关闭  –  产生一个信号SIGPIPE，程序异常终止。</li><li>读端未全部关闭。<ul><li>管道已满  –  write阻塞。</li><li>管道未满  –  write正常写入。</li></ul></li></ul></li></ul><ul><li><code>long fpathconf(int fd, int name);</code><ul><li>计算管道大小。</li><li>name 设置为  _PC_PIPE_BUF。</li></ul></li></ul><h2 id="FIFO通信"><a href="#FIFO通信" class="headerlink" title="FIFO通信"></a>FIFO通信</h2><p>​        FIFO有名管道，实现无血缘关系进程通信。</p><ul><li>创建一个管道的伪文件。<ul><li>mkfifo myfifo 命令创建。</li><li><code>int mkfifo(const char *pathname, mode_t mode);</code> 函数创建。</li></ul></li><li>内核会针对fifo文件开辟一个缓冲区，操作fifo文件–实际上就是文件读写，可以操作缓冲区，实现进程间通信。</li></ul><h2 id="mmap通信"><a href="#mmap通信" class="headerlink" title="mmap通信"></a>mmap通信</h2><p>​        mmap共享映射区，可以无血缘关系进程通信。</p><ul><li><code>void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);</code><ul><li>创建映射区。</li><li>addr     传NULL。</li><li>length  映射区长度。</li><li>prot：<ul><li>PROT_READ   可读 。</li><li>PROT_WRITE  可写。</li><li>MAP_ANON     可以创建匿名映射，不用再建立一个文件，这时候fd设为-1。这个宏在有些Unix系统没有，匿名映射只能实现有血缘关系的进程通信。</li></ul></li><li>flag：<ul><li>MAP_SHARED 共享的，对内存的修改会影响到源文件。</li><li>MAP_PRIVATE 私有的，修改不反应到磁盘实际文件，是一个copy-on-write（写时复制）的映射方式。</li></ul></li><li>fd  文件描述符。</li><li>offeset  偏移量。</li><li>返回值：<ul><li>成功返回可用的内存首地址。</li><li>失败返回MAP_FAILED。</li></ul></li></ul></li><li><code>int munmap(void *addr, size_t length);</code><ul><li>释放映射区。</li><li>addr 传mmap返回值。</li><li>length mmap创建的长度。</li><li>返回值：<ul><li>失败返回-1。</li><li>成功返回0。</li></ul></li></ul></li></ul><p><img src="https://s2.loli.net/2022/03/08/W9iZmHUJXEIGMRO.png" alt="QQ截图20220308132738.png"></p><h2 id="共享内存通信"><a href="#共享内存通信" class="headerlink" title="共享内存通信"></a>共享内存通信</h2><p>​        共享内存使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。</p><p><strong>特点：</strong></p><ul><li>共享内存是最快的一种IPC，因为进程是直接对内存进行操作来实现通信，避免了数据在用户空间和内核空间来回拷贝。</li><li>因为多个进程可以同时操作，所以需要进行同步处理。</li><li>信号量和共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。</li></ul><h2 id="进程调度的时机"><a href="#进程调度的时机" class="headerlink" title="进程调度的时机"></a>进程调度的时机</h2><ul><li>当前运行的进程运行结束。</li><li>当前运行的进程由于某种原因阻塞。</li><li>执行完系统调用等系统程序后返回用户进程。</li><li>在使用抢占调度的系统中，具有更高优先级的进程就绪时。</li><li>分时系统中，分给当前进程的时间片用完。</li></ul><h2 id="不能进行进程调度的情况"><a href="#不能进行进程调度的情况" class="headerlink" title="不能进行进程调度的情况"></a>不能进行进程调度的情况</h2><ul><li>在中断处理程序执行时。</li><li>在操作系统的内核程序临界区内。</li><li>其他需要完全屏蔽中断的原子操作过程中。</li></ul><h2 id="进程的调度策略"><a href="#进程的调度策略" class="headerlink" title="进程的调度策略"></a>进程的调度策略</h2><ul><li>先到先服务调度算法</li><li>短作业优先调度算法</li><li>优先级调度算法</li><li>时间片轮转调度算法</li><li>高响应比优先调度算法（响应比 = （等待时间+需要服务时间）/需要服务时间）</li><li>多级队列调度算法</li><li>多级反馈队列调度算法</li></ul><h2 id="进程调度策略的基本设计指标"><a href="#进程调度策略的基本设计指标" class="headerlink" title="进程调度策略的基本设计指标"></a>进程调度策略的基本设计指标</h2><ol><li>CPU利用率 。</li><li>系统吞吐率，即单位时间内CPU完成的作业的数量。</li><li>响应时间。</li><li>周转时间。是指作业从提交到完成的时间间隔。从每个作业的角度看，完成每个作业的时间也是很关键 。<ul><li>平均周转时间 </li><li>带权周转时间 </li><li>平均带权周转时间</li></ul></li></ol><h2 id="孤儿进程和僵尸进程"><a href="#孤儿进程和僵尸进程" class="headerlink" title="孤儿进程和僵尸进程"></a>孤儿进程和僵尸进程</h2><ul><li>孤儿进程：父亲死了 ，子进程被init进程领养。父进程退出，子进程还在运行的这些子进程都是孤儿进程，孤儿进程将会被init进程(1号进程)收养，并由 init进程对他们完成状态收集工作。</li><li>僵尸进程：子进程死了，父进程没有回收子进程的资源（PCB）。进程使用fork创建子进程，如果子进程退出，而父进程没有盗用wait或者 waitpid获取子进程状态信息，那么子进程的进程描述符依然保存在系统中的这些进程为僵尸进程。</li><li>如何回收僵尸进程：<ul><li>kill 父进程，init领养子进程后，自动回收。</li><li>wait和waitpid</li></ul></li></ul><h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><p>​        操作系统中，进程是具有不同的地址空间的，两个进程是不能感知对方的存在的。有时候，需要多个进程来协同完成一些任务。</p><p>​        当多个进程需要对同一个内核资源进行操作时，这些进程便是竞争关系，操作系统必须协调各个进程对资源的占用，进程的互斥是解决进程间竞争关系的方法。进程互斥指若干进程要使用同一共享资源时，任何时刻最多允许一个进程去使用，其他进程要使用该资源的进程必须等待，直到占有资源的进程释放该资源。</p><p>​        当多个进程协同完成一些任务时，不同进程的执行进度不一致，这便产生了进程同步问题。需要操作系统干预，在特定的同步点对所有进程进行同步，这种协作进程之间相互等待对方消息或信号的协调关系称为进程同步，进程互斥本质上也是一种进程同步。</p><p><strong>进程同步方法：</strong></p><ul><li>互斥锁</li><li>读写锁</li><li>条件变量</li><li>记录锁</li><li>信号量</li><li>屏障</li></ul><h2 id="进程API"><a href="#进程API" class="headerlink" title="进程API"></a>进程API</h2><p><strong>fork:</strong></p><ul><li><code>pid_t fork();</code> </li><li>创建一个新的进程。fork函数将运行着的程序分成2个（几乎）完全一样的进程，每个进程都启动一个从代码的同一位置开始执行的线程。子进程使用相同的pc（程序计数器），相同的CPU寄存器，在父进程中使用的相同打开文件。</li><li>返回值：<ul><li>失败 -1。</li><li>成功，两次返回。<ul><li>父进程返回子进程id。</li><li>子进程返回0。</li></ul></li></ul></li><li>父子进程的数据：读时共享，写时复制。</li></ul><p><strong>getpid，getppid：</strong></p><ul><li><code>pid_t getpid();</code>获得进程id。</li><li><code>pid_t getppid()</code>获得父进程id。</li></ul><p><strong>wait:</strong></p><ul><li><p>回收子进程，知道子进程死亡原因。</p></li><li><p>作用：</p><ul><li>阻塞等待。</li><li>回收子进程资源。</li><li>查看死亡原因。</li></ul></li><li><p><code>pid_t wait(int *wstatus);</code></p><ul><li>没有子进程退出会阻塞。</li><li>wstatus 传出参数，告知死亡原因，具体看百度。</li><li>返回值：<ul><li>成功返回终止的子进程ID。</li><li>失败返回-1。</li></ul></li></ul></li><li><p><code>pid_t waitpid(pid_t pid, int *wstatus, int options);</code></p><ul><li><p>pid </p><p><img src="https://s2.loli.net/2022/03/07/latG6nAJriKVXLy.png" alt="QQ截图20220307111516.png"></p></li><li><p>wstatus 传出参数，告知死亡原因，具体看百度。</p></li><li><p>options</p><ul><li>设置0和wait差不多。</li><li>设置WNOHANG 如果没有子进程退出立刻返回。</li></ul></li><li><p>返回值：</p><ul><li>如果设置了WNOHANG，如果没有子进程退出，返回0。如果有子进程退出，返回PID。</li><li>失败返回-1（没有子进程）。</li></ul></li></ul></li><li><p>通过捕捉SIGCHLD信号也可以在捕获函数中释放子进程。</p></li></ul><h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><p><strong>守护进程：</strong>守护进程(daemon)是一类在后台运行的特殊进程，用于执行特定的系统任务。很多守护进程在系统引导的时候启动，并且一直运行直到系统关闭。另一些只在需要的时候才启动，完成任务后就自动结束。</p><p><strong>会话：</strong>进程组的更高一级，多个进程组对应一个会话。创建会话时，只能组员创建，不能组长创建。</p><p><strong>进程组：</strong>多个进程在同一个组，第一个进程默认是进程组组长。</p><p><strong>创建会话步骤：</strong>创建子进程，杀死父进程，子进程自当会长。</p><p><strong>守护进程步骤：</strong></p><ul><li><font color=red>创建子进程fork</font></li><li><font color=red>父进程退出</font></li><li><font color=red>子进程当会长setid</font></li><li>切换工作目录$HOME</li><li>设置掩码  umask</li><li>关闭文件描述符0，1，2，为了避免浪费资源</li><li><font color=red>执行核心逻辑</font></li><li>退出</li></ul><p><strong>扩展：</strong><br>通过nohub指令也可以达到守护进程创建的效果。</p><p><code>nohub ./a.out &gt; 1.log &amp;</code></p><ul><li>nohub指令会让cmd收不到SIGHUB信号</li><li>&amp;代表后台运行。</li></ul><hr><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>​        轻量级的进程，一个进程可以有多个线程，默认情况下一个进程只有一个线程。线程是最小的执行单位，进程是最小的系统资源分配单位。在linux里内核实现都是通过clone函数实现的。</p><ul><li>线程是进程划分的任务，是一个进程内可调度的实体，是CPU调度的基本单位，用于保存程序的实时性，实现进程内部的并发。</li><li>线城市操作系统可识别的最小执行和调度单位。每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。</li><li>每个线程完成不同的任务，但是属于同一个进程的不同线程之间共享同一地址空间（也就是同样的动态内存，映射文件，目标代码等等），打开的文件队列和其他内核资源。</li></ul><h2 id="为什么需要线程"><a href="#为什么需要线程" class="headerlink" title="为什么需要线程"></a>为什么需要线程</h2><p><strong>线程产生原因：</strong>进程可以使多个程序能并发执行，以提高资源的利用率和系统的吞吐量；但是其具有一些缺点：</p><ul><li>进程在同一时刻只能做一个任务，很多时候不能充分利用CPU资源。</li><li>进程在执行过程中如果发生阻塞，整个进程就会挂起，即使进程中其他任务不依赖于等待的资源，进程仍会被阻塞。</li></ul><p>引入线程就是为了解决以上进程的不足，线程具有如下优点：</p><ul><li>从资源上讲，开辟一个线程所需要的资源远小于一个进程。</li><li>从切换效率上来讲，运行于一个进程中的多个线程，他们之间使用相同的地址空间，而且线程间彼此切换所需要的时间也远远小于进程间切换所需要的时间（这种时间差异主要由于缓存的大量未命中导致）。</li><li>从通信机制上来讲，线程间方便的通信机制。对不同线程来说，他们具有独立的地址空间，要进行数据的传递只能通过进程间通信的方式进行。线程则不然 ，属于同一个进程的不同线程之间共享同一地址空间，所以一个线程的数据可以被其他线程感知，线程间可以直接读写进程数据段（如全局变量）来进行通信（需要一些同步措施）。</li><li>线程提高程序并发性，充分利用CPU资源。</li></ul><p>Linux下线程缺点：</p><ul><li>调试困难。</li><li>库函数，不稳定。</li><li>对信号支持不好。</li></ul><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>​        操作系统中，属于同一进程的线程之间具有相同的地址空间，线程之间共享数据变得简单高效。遇到竞争的线程同时修改同一数据或者协作的线程设置同步点问题时，需要使用一些线程同步的方法解决这些问题。</p><p><strong>线程同步方法：</strong></p><ul><li><p>互斥锁</p></li><li><p>读写锁</p><ul><li><p>读是共享，写是独占，写的优先级高。</p></li><li><p>读写锁仍然是一把锁，只是有不同的状态：</p><ul><li>未加锁</li><li>读锁</li><li>写锁</li></ul></li><li><p>使用场景：适合读的线程多。</p></li></ul></li><li><p>条件变量</p><ul><li>可以引起阻塞，并非锁 。</li><li>要和互斥量组合使用。</li><li>避免不必要的竞争。</li></ul></li><li><p>信号量</p><ul><li>就是加强版的互斥锁，允许多个线程访问共享资源。</li></ul></li><li><p>自旋锁</p></li><li><p>屏障</p></li></ul><h2 id="线程和进程的区别和联系"><a href="#线程和进程的区别和联系" class="headerlink" title="线程和进程的区别和联系"></a>线程和进程的区别和联系</h2><ul><li>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。</li><li>进程在执行过程中拥有独立的地址空间，而多个线程共享进程的地址空间。（资源分配给进程，同一进程的所有线程共享该进程的所有资源 。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段 ，用来存放所有局部变量和临时变量）。</li><li>进程是资源分配的最小单位，而线程是CPU调度的最小单位。</li><li>通信：由于同一进程中多个线程具有相同的地址空间，使他们之间的同步和通信的实现也变得比较容易，进程间通信IPC通过内核提供的缓冲区进行数据交换，而线程间可以直接读写进程数据段（如全局变量）来进行通信（需要一些同步方法 ，以保证数据的一致性）。</li><li>进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快 ，但是编程调试相对复杂。</li><li>进程间不会相互影响；一个进程内某个线程挂掉将导致整个进程挂掉。</li><li>进程适应于多核、多机分布；线程是用于多核。</li></ul><h2 id="线程API"><a href="#线程API" class="headerlink" title="线程API"></a>线程API</h2><p><strong>pthread_self:</strong></p><ul><li><code>pthread_t pthread_self(void);</code>查看线程id。</li></ul><p><strong>pthread_creat:</strong></p><ul><li><code>int pthread_create(pthread_t *thread, const pthread_attr_t *attr,void *(*start_routine) (void *), void *arg);</code> 创建一个线程。</li><li>thread 线程id，传出参数。</li><li>attr 代表线程的属性。</li><li>第三个参数 ，函数指针，void* func（void*）。</li><li>arg 线程执行函数的参数。</li><li>返回值：<ul><li>成功返回0。</li><li>失败返回errno。</li></ul></li></ul><p><font color=red>注意：Compile and link with -pthread。</font></p><p><strong>pthread_exit:</strong></p><ul><li><code>void pthread_exit(void *retval);</code>退出线程。</li><li>retval 函数传出参数。设NULL。</li></ul><p><strong>线程退出注意事项：</strong></p><ul><li>在线程中使用pthread_exit。</li><li>在线程中使用return（主控线程即主函数return代表退出进程）。</li><li>exit代表退出整个进程。</li></ul><p><strong>pthread_join:</strong></p><ul><li><code>int pthread_join(pthread_t thread, void **retval);</code>线程回收函数，阻塞等待回收。</li><li>thrad 创建的时候传出的第一个参数，想回收的线程id。</li><li>retval代表传出线程的退出信息。如果是被pthread_cancel杀死的，返回-1。</li></ul><p><strong>pthread_cancel:</strong></p><ul><li><code>int pthread_cancel(pthread_t thread);</code> 杀死线程。</li><li>thrad 创建的时候传出的第一个参数，想杀死的线程id。</li><li>返回值：<ul><li>失败返回errno。</li><li>成功返回0。</li></ul></li></ul><p><strong>strerror：</strong></p><ul><li><code>char *strerror(int errnum);</code>  获得错误码对应的错误信息。</li></ul><p><strong>pthread_detach:</strong></p><ul><li><code>int pthread_detach(pthread_t thread);</code> 线程分离，此时不用pthread_join回收资源。</li></ul><p><strong>pthread_equal:</strong></p><ul><li><code> int pthread_equal(pthread_t t1, pthread_t t2);</code>比较两个线程id是否相等。</li><li>线程id在进程内部唯一。</li></ul><p><strong>pthread_attr进程属性控制函数：</strong></p><ul><li><code> int pthread_attr_init(pthread_attr_t *attr);</code>   初始化线程属性。</li><li><code>int pthread_attr_destroy(pthread_attr_t *attr);</code>销毁线程属性。</li><li><code> int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);</code> 设置属性分离<ul><li>attr 用pthread_attr_init初始化的属性。</li><li>detachstate<ul><li>PTHREAD_CREATE_DETACHED 线程分离。</li><li>PTHREAD_CREATE_JOINABLE   允许回收。  默认是这个状态。</li></ul></li></ul></li></ul><p><strong>pthread_mutex互斥量函数：</strong></p><ul><li><code>int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);</code><ul><li>restrict 约束该块内存区域对应的数据，只能通过后面的变量进行访问和修改。</li><li>mutex 互斥量– 锁。</li><li>attr 互斥量的属性，一般传NULL。</li><li><code>pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;</code>或者用这个进行mutex初始化，不用上述函数。</li></ul></li><li><code>int pthread_mutex_lock(pthread_mutex_t *mutex);</code> 给共享资源加锁。<ul><li>mutex 是pthread_mutex_init初始化的锁。rugu</li><li>如果当前未锁，成功加锁。如果已经加锁，阻塞等待。</li></ul></li><li><code>int pthread_mutex_trylock(pthread_mutex_t *mutex);</code> 尝试加锁。<ul><li>mutex 是pthread_mutex_init初始化的锁。</li><li>如果当前未锁，成功加锁返回0，失败设置errno。</li></ul></li><li><code> int pthread_mutex_unlock(pthread_mutex_t *mutex);</code> 解锁。</li><li><code>int pthread_mutex_destroy(pthread_mutex_t *mutex);</code> 摧毁锁。<ul><li>mutex 是pthread_mutex_init初始化的锁。</li></ul></li></ul><p><em><strong>互斥量只是建议锁</strong></em></p><p><strong>pthread_rwlock读写锁函数 ：</strong></p><ul><li><p><code>int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock,const pthread_rwlockattr_t *restrict attr)</code>初始化锁</p><ul><li><code>pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER;</code>同上</li></ul></li><li><p><code> int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);</code>销毁锁</p></li><li><p><code> int pthread_rwlock_rdlock(pthread_rwlock_twr *rwlock);</code>加读锁</p></li><li><p><code> int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);</code>加写锁</p></li><li><p><code> int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);</code>释放锁</p></li></ul><p><strong>pthrad_cond条件变量函数：</strong></p><ul><li><p><code>int pthread_cond_timedwait(pthread_cond_t *restrict cond,pthread_mutex_t *restrict mutex,const struct timespec *restrict abstime);</code> 超时等待。 </p><ul><li><p>```c++<br>struct timespec {</p><pre><code>           time_t tv_sec;      /* Seconds */           long   tv_nsec;     /* Nanoseconds [0 .. 999999999] */       &#125;;</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - abstime 写 time（NULL）+秒数。 </span><br><span class="line"></span><br><span class="line">- `int pthread_cond_wait(pthread_cond_t *restrict cond,pthread_mutex_t *restrict mutex);`条件变量阻塞等待。</span><br><span class="line"></span><br><span class="line">  - 先释放锁mutex。</span><br><span class="line">  - 阻塞在cond条件变量上。</span><br><span class="line"></span><br><span class="line">- `int pthread_cond_init(pthread_cond_t *restrict cond,const pthread_condattr_t *restrict attr);`初始化条件变量。</span><br><span class="line"></span><br><span class="line">  - `pthread_cond_t cond = PTHREAD_COND_INITIALIZER;`    </span><br><span class="line"></span><br><span class="line">- `int pthread_cond_destroy(pthread_cond_t *cond);`销毁条件变量。</span><br><span class="line"></span><br><span class="line">- `int pthread_cond_signal(pthread_cond_t *cond);`唤醒至少一个阻塞在条件变量cond上的线程。</span><br><span class="line"></span><br><span class="line">- `int pthread_cond_broadcast(pthread_cond_t *cond);`唤醒所有阻塞在条件变量cond上的线程。</span><br><span class="line"></span><br><span class="line">**信号量函数：**</span><br><span class="line"></span><br><span class="line">- `int sem_init(sem_t *sem, int pshared, unsigned int value);` 初始化信号量</span><br><span class="line">  - sem定义的信号量，传出参数。</span><br><span class="line">  - pshared  </span><br><span class="line">    - 0代表线程信号量。</span><br><span class="line">    - 非0代表进程信号量。</span><br><span class="line">  - value 定义信号量个数。</span><br><span class="line">- `int sem_destroy(sem_t *sem);`摧毁信号量。</span><br><span class="line">- `int sem_wait(sem_t *sem);`申请信号量</span><br><span class="line">  - 成功value--。</span><br><span class="line">  - 当信号量为0阻塞。</span><br><span class="line">- ` int sem_post(sem_t *sem);`释放信号量 。</span><br><span class="line">  - value++。</span><br><span class="line"></span><br><span class="line">## 线程共享资源和非共享资源</span><br><span class="line"></span><br><span class="line">### 共享资源</span><br><span class="line"></span><br><span class="line">1. 文件描述符表</span><br><span class="line">2. 每种信号的处理方式</span><br><span class="line">3. 当前工作目录</span><br><span class="line">4. 用户ID和组ID</span><br><span class="line">5. 内存地址空间</span><br><span class="line"></span><br><span class="line">### 非共享资源</span><br><span class="line"></span><br><span class="line">1. 线程id</span><br><span class="line">2. 处理器现场和栈指针（内核栈）</span><br><span class="line">3. 独立的栈空间（用户空间栈）</span><br><span class="line">4. errno变量</span><br><span class="line">5. 信号屏蔽字</span><br><span class="line">6. 调度优先级</span><br><span class="line"></span><br><span class="line">## 多线程模型</span><br><span class="line"></span><br><span class="line">- 多对一模型：将多个用户级线程映射到同一个内核级线程上。该模型下，线程在用户空间进行管理，效率较高。缺点就是一个线程阻塞，整个进程内所有线程都会阻塞，几乎没有系统继续使用这个模型。</span><br><span class="line">- 一对一模型：将内核线程与用户线程一一对应。优点是一个线程阻塞时，不会影响到其他线程的执行。该模型具有更好的并发性。缺点是内核线程数量一般有上线，会限制用户线程的数量，更多的内核线程数目也给线程切换带来额外的负担。Linux和Windows操作系统都是使用一对一模型。</span><br><span class="line">- 多对多模型：将多个用户级线程映射到多个内核级线程上，结合了多对一模型和一对一模型的特点。</span><br><span class="line"></span><br><span class="line">## 进程同步和线程同步的区别</span><br><span class="line"></span><br><span class="line">​进程之间地址空间不同，不能感知对方的存在，同步时需要将锁放在多进程共享的空间。而线程之间共享同一地址空间，同步时把锁放在所属的同一进程空间即可。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 线程池</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 信号</span><br><span class="line"></span><br><span class="line">## 什么是信号</span><br><span class="line"></span><br><span class="line">​一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件。Linux系统上支持的30多种不同类型的信号。每种 信号类型都对应于某种系统事件。底层的硬件异常是由内核异常处理程序处理的，正常情况下，对用户进程而言不可见。信号提供一种机制，通知用户进程发生了这些异常。信号也叫软件产生的中断，有可能会有延迟。</span><br><span class="line"></span><br><span class="line">1. 发送信号：内核通过更新目的进程上下文中的某个状态，发送一个信号到目的进程。发送信号的原因：</span><br><span class="line">   - 内核检测到一个系统事件，比如零错误或者子进程终止。</span><br><span class="line">   - 一个进程调用了kill函数，显式要求内核发送一个信号给目的进程。一个进程可以发送信号给他自己。</span><br><span class="line">2. 接收信号：当目的进程被内核强迫以某种方式对信号的发送作出反应时，它就接收了信号。进程可以忽略、终止或者通过执行一个称为信号处理程序（signal handler）的用户层函数捕获这个信号。</span><br><span class="line"></span><br><span class="line">**特点：**简单，不能带大量信息，满足特定条件发生。</span><br><span class="line"></span><br><span class="line">**信号的机制：**进程B发送给进程A，内核产生信号，内核处理。</span><br><span class="line"></span><br><span class="line">**信号产生：**</span><br><span class="line"></span><br><span class="line">- 按键产生 crtl+c crtl+z  crtl+\。</span><br><span class="line">- 调用函数  kill  raise   abort。</span><br><span class="line">- 定时器  alarm， setitimer。</span><br><span class="line">- 命令产生  kill。</span><br><span class="line">- 硬件异常  段错误，浮点型错误，总线错误，SIGPIPE。</span><br><span class="line"></span><br><span class="line">**信号状态：**</span><br><span class="line"></span><br><span class="line">- 产生。</span><br><span class="line">- 递答  信号到达并且处理完。</span><br><span class="line">- 未决  信号被阻塞。</span><br><span class="line"></span><br><span class="line">**信号默认处理方式：**</span><br><span class="line"></span><br><span class="line">- 忽略。</span><br><span class="line">- 执行默认动作。</span><br><span class="line">- 捕获。</span><br><span class="line"></span><br><span class="line">**信号四要素：**</span><br><span class="line"></span><br><span class="line">- 编号</span><br><span class="line">- 事件</span><br><span class="line">- 名称</span><br><span class="line">- 默认处理动作：忽略、终止、终止+core、暂停、继续。</span><br><span class="line"></span><br><span class="line">**信号集：**</span><br><span class="line"></span><br><span class="line">![信号集](https://s3.bmp.ovh/imgs/2022/03/311eea32a3ddcab1.png)</span><br><span class="line"></span><br><span class="line">**信号捕捉特性：**</span><br><span class="line"></span><br><span class="line">- 进程正常运行时，默认PCB中有一个信号屏蔽字，假定为⭐，它决定了进程自动屏蔽那些信号。当注册了某个信号捕捉函数 ，捕捉到该信号后，要调用该函数，该函数有可能执行很长时间，在这期间所屏蔽的信号不由⭐指定，而是用sa_mask指定。调用完信号处理函数在恢复为⭐。</span><br><span class="line">- \*\*\*信号捕捉函数执行期间，\*\*\*信号自动被屏蔽。</span><br><span class="line">- 阻塞的常规信号不支持排队，产生多次只记录一次。（后32个实时信号支持排队）</span><br><span class="line"></span><br><span class="line">**内核实现信号捕捉过程：**</span><br><span class="line"></span><br><span class="line">![1](https://img2018.cnblogs.com/blog/1241434/201908/1241434-20190811095430459-2130640271.png)</span><br><span class="line"></span><br><span class="line">## 信号API</span><br><span class="line"></span><br><span class="line">### 系统API产生信号</span><br><span class="line"></span><br><span class="line">**kill:**</span><br><span class="line"></span><br><span class="line">- `int kill(pid_t pid, int sig);`</span><br><span class="line">- pid:</span><br><span class="line">  - \&gt;0，要发送进程ID。</span><br><span class="line">  - =0，代表当前调用进程组内所有进程。</span><br><span class="line">  - =-1，代表有权限发送的所有进程。</span><br><span class="line">  - &lt;0，代表-pid对应的组内所有进程。</span><br><span class="line">- sig：对应的信号。</span><br><span class="line"></span><br><span class="line">**raise和abort:**</span><br><span class="line"></span><br><span class="line">- `int raise(int sig);`</span><br><span class="line">- sig：对应的信号。给自己发。</span><br><span class="line">- `void abort(void);`</span><br><span class="line">- 直接给自己发个异常信号。</span><br><span class="line"></span><br><span class="line">### 时钟信号</span><br><span class="line"></span><br><span class="line">**alarm：**</span><br><span class="line"></span><br><span class="line">- `unsigned int alarm(unsigned int seconds);`</span><br><span class="line">- 定时给自己发SIGALRM信号，也会使进程终止。</span><br><span class="line">- 返回值：上次闹钟剩余的秒数。</span><br><span class="line">- 如果传入参数为0，代表取消闹钟。</span><br><span class="line"></span><br><span class="line">**setitimer：**</span><br><span class="line"></span><br><span class="line">- ` int getitimer(int which, struct itimerval *curr_value);`</span><br><span class="line"></span><br><span class="line">- `int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value);`</span><br><span class="line"></span><br><span class="line">  - ```c++</span><br><span class="line">    struct itimerval &#123;</span><br><span class="line">        struct timeval it_interval; /* Interval for periodic timer 周期性时间设置*/</span><br><span class="line">        struct timeval it_value;    /* Time until next expiration 第一次闹钟时间*/</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    struct timeval &#123;</span><br><span class="line">        time_t      tv_sec;         /* seconds 秒*/</span><br><span class="line">        suseconds_t tv_usec;        /* microseconds 微秒*/</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></li><li><p>which</p><ul><li>ITIMER_REAL  自然定时法，发送SIGALRM信号，</li><li>ITIMER_VIRTUAL 计算进程执行时间，发送SIGVTALRM信号。</li><li>ITIMER_PROF  进程执行时间+调度时间，发送SIGPROF信号。</li></ul></li><li><p>new_value 要设置的闹钟时间。</p></li><li><p>old_value  传出原闹钟时间。</p></li></ul></li></ul><h3 id="信号集处理函数"><a href="#信号集处理函数" class="headerlink" title="信号集处理函数"></a>信号集处理函数</h3><ul><li><p>```c++<br>// 清空信号集<br>int sigemptyset(sigset_t *set);</p><p>// 填充信号集<br>int sigfillset(sigset_t *set);</p><p>// 添加某个信号到信号集<br>int sigaddset(sigset_t *set, int signum);</p><p>// 从集合中删除某个信号<br>int sigdelset(sigset_t *set, int signum);</p><p>// 是否为集合中的成员，是return 1 否return 0<br>int sigismember(const sigset_t *set, int signum);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**sigprocmask：**</span><br><span class="line"></span><br><span class="line">- `int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);`设置阻塞或者解除阻塞信号集。</span><br><span class="line">- how</span><br><span class="line">  - SIG_BLOCK  设置阻塞。</span><br><span class="line">  - SIG_UNBLOCK  解除阻塞。</span><br><span class="line">  - SIG_SETMASK  设置set为新的阻塞信号集。</span><br><span class="line">- set        传入的信号集。</span><br><span class="line">- oldset  传出旧的信号集。</span><br><span class="line"></span><br><span class="line">**sigpending:**</span><br><span class="line"></span><br><span class="line">- `int sigpending(sigset_t *set);`获取当前的未决信号集。</span><br><span class="line">- set 传出参数，当前的未决信号集。</span><br><span class="line"></span><br><span class="line">### 信号捕捉</span><br><span class="line"></span><br><span class="line">**signal：**</span><br><span class="line"></span><br><span class="line">- ```c++</span><br><span class="line">  typedef void (*sighandler_t)(int); </span><br><span class="line">  </span><br><span class="line">  sighandler_t signal(int signum, sighandler_t handler); // 定义一个handler函数来进行捕捉到信号后执行什么操作，signum为信号。</span><br></pre></td></tr></table></figure></li><li><p>捕捉信号并进行相关处理。</p></li></ul><p><strong>sigaction：</strong></p><ul><li><p><code>int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);</code>注册捕捉函数 。</p></li><li><p>signum 捕捉的信号。</p></li><li><p>act 传入的动作</p><ul><li><pre><code class="c++">struct sigaction &#123;    void     (*sa_handler)(int);      // 函数指针，捕捉后的动作    void     (*sa_sigaction)(int, siginfo_t *, void *);    sigset_t   sa_mask;                // 执行捕捉函数期间，临时屏蔽的信号集    int        sa_flags;            // 一般填0使用第一个函数指针，填SA_SIGINFO用第二个    void     (*sa_restorer)(void);  // 无效&#125;;</code></pre></li></ul></li><li><p>oldact 原动作，传出参数，恢复现场。</p></li></ul><h2 id="如何编写正确且安全的信号处理函数"><a href="#如何编写正确且安全的信号处理函数" class="headerlink" title="如何编写正确且安全的信号处理函数"></a>如何编写正确且安全的信号处理函数</h2><ol><li><p>处理程序要尽可能简单。 避免麻烦的最好方法是保持处理程序尽可能小和简单。例如，处理程序可 能只是简单地设置全局标志并立即返回；所有与接收信号相关的处理都由主程序执行，它周期性地 检查(并重置)这个标志。 </p></li><li><p>在处理程序中只调用异步信号安全的函数。 所谓异步信号安全的函数(或简称安全的函数)能够被信 号处理程序安全地调用，原因有二：要么它是可重入的(例如只访问局部变量），要么它不能被信号 处理程序中断。 </p></li><li><p>保存和恢复errno。 许多Linux 异步信号安全的函数都会在出错返回时设置errno在处理程序中调用 这样的函数可能会干扰主程序中其他依赖于分。解决方法是在进人处理程序时把errno 保存在一个 局部变量中，在处理程序返回前恢复它。注意，只有在处理程序要返回时才有此必要。如果处理程 序调用_exit终止该进程，那么就不需要这样做了。 </p></li><li><p>阻塞所有的信号，保护对共享全局数据结构的访问。 如果处理程序和主程序或其他处理程序共享一 个全局数据结构，那么在访问(读或者写)该数据结构时，你的处理程序和主程序应该暂时阻塞所有 的信号。这条规则的原因是从主程序访问一个数据结构d 通常需要一系列的指令，如果指令序列被 访问d 的处理程序中断，那么处理程序可能会发现d 的状态不一致，得到不可预知的结果。在访问d 时暂时阻塞信号保证了处理程序不会中断该指令序列。</p></li><li><p>用volatile 声明全局变量。 考虑一个处理程序和一个main 函数，它们共享一个全局变量g 。处理程 序更新g，main 周期性地读g， 对于一个优化编译器而言，main 中g的值看上去从来没有变化过， 因此使用缓存在寄存器中g 的副本来满足对g 的每次引用是很安全的。如果这样，main 函数可能永 远都无法看到处理程序更新过的值。可以用volatile 类型限定符来定义一个变量，告诉编译器不要 缓存这个变量。例如：volatile 限定符强迫编译器毎次在代码中引用g时，都要从内存中读取g的 值。一般来说，和其他所有共享数据结构一样，应该暂时阻塞信号，保护每次对全局变量的访问。 volatile int g; </p></li><li><p>用sig_atomic_t声明标志。在常见的处理程序设计中，处理程序会写全局标志来记录收到了信号。 主程序周期性地读这个标志，响应信号，再清除该标志。对于通过这种方式来共享的标志，C 提供 一种整型数据类型sig_atomic_t对它的读和写保证会是原子的（不可中断的）。 </p></li><li><p>信号的一个与直觉不符的方面是未处理的信号是不排队的。因为 pending 位向量中每种类型的信号 只对应有一位，所以每种类型最多只能有一个未处理的信号。关键思想是如果存在一个未处理的信 号就表明至少有一个信号到达了。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
            <tag> OS </tag>
            
            <tag> 进程 </tag>
            
            <tag> 线程 </tag>
            
            <tag> 信号 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存泄露</title>
      <link href="2022/02/22/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
      <url>2022/02/22/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h1><p>​        内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是<a href="http://baike.baidu.com/view/330120.htm">应用程序</a>分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。</p><h1 id="内存是如何泄露的？"><a href="#内存是如何泄露的？" class="headerlink" title="内存是如何泄露的？"></a>内存是如何泄露的？</h1><ul><li>堆区数据未被释放。</li></ul><h1 id="C-中的内存泄露该如何避免？"><a href="#C-中的内存泄露该如何避免？" class="headerlink" title="C++ 中的内存泄露该如何避免？"></a>C++ 中的内存泄露该如何避免？</h1><ul><li>避免在堆区开辟数据。</li><li>使用智能指针，而不是手动管理内存。</li><li>使用 std::string 来替代 char*。</li><li>善用 RAII（Resource Acquisition Is Initialization）思想：在类的构造函数中分配资源，在类的析构函数中释放资源。</li></ul><h1 id="如果发生了内存泄露，该如何定位问题代码？"><a href="#如果发生了内存泄露，该如何定位问题代码？" class="headerlink" title="如果发生了内存泄露，该如何定位问题代码？"></a>如果发生了内存泄露，该如何定位问题代码？</h1><ul><li>使用工具软件BoundsChecker，BoundsChecker是一个运行时错误检测工具，它主要定位程序运行时期发生的各种错误。</li><li>调试运行DEBUG版程序，运用以下技术：CRT(C run-time libraries)、运行时函数调用堆栈、内存泄漏时提示的内存分配序号(集成开发环境OUTPUT窗口)，综合分析内存泄漏的原因，排除内存泄漏。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 面经 </tag>
            
            <tag> 内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件读写</title>
      <link href="2022/02/22/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/"/>
      <url>2022/02/22/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/</url>
      
        <content type="html"><![CDATA[<h1 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h1><ul><li>头文件<code>#include&lt;fstream&gt;</code></li></ul><h2 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// 以输出方式打开文件</span></span><br><span class="line">    <span class="comment">//  ofstream ofs(&quot;./test.txt&quot;, ios::out | ios::trunc);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 也可以后期指定打开方式</span></span><br><span class="line">    ofstream ofs;</span><br><span class="line">    ofs.<span class="built_in">open</span>(<span class="string">&quot;./test.txt&quot;</span>, ios::out | ios::trunc);</span><br><span class="line">    <span class="keyword">if</span>(!ofs.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;open fail&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ofs&lt;&lt;<span class="string">&quot;goudan&quot;</span>&lt;&lt;endl;</span><br><span class="line">    ofs&lt;&lt;<span class="string">&quot;11&quot;</span>&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// 以输出方式打开文件</span></span><br><span class="line">    <span class="comment">//  ifstream ifs(&quot;./test.txt&quot;, ios::in);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 也可以后期指定打开方式</span></span><br><span class="line">    ifstream ifs;</span><br><span class="line">    ifs.<span class="built_in">open</span>(<span class="string">&quot;./test.txt&quot;</span>, ios::out | ios::trunc);</span><br><span class="line">    <span class="keyword">if</span>(!ifs.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;open fail&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第一种方式</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span>(ifs&gt;&gt;buf) &#123; <span class="comment">// 按行读取</span></span><br><span class="line">cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第二种方式</span></span><br><span class="line">    <span class="keyword">char</span> buf2[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span>(ifs.<span class="built_in">eof</span>()) &#123;<span class="comment">// eof读到文件尾</span></span><br><span class="line">ifs.<span class="built_in">getline</span>(buf2, <span class="built_in"><span class="keyword">sizeof</span></span>(buf2));</span><br><span class="line">        cout &lt;&lt; buf2 &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第三种方式，不推荐，按单个字符读取</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">while</span>(c = ifs.<span class="built_in">get</span>() != EOF) &#123; <span class="comment">// EOF文件尾</span></span><br><span class="line">        cout &lt;&lt; c;</span><br><span class="line">    &#125;</span><br><span class="line">    ifs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 文件操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>输入输出流</title>
      <link href="2022/02/22/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/"/>
      <url>2022/02/22/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1 id="标准输入流"><a href="#标准输入流" class="headerlink" title="标准输入流"></a>标准输入流</h1><ul><li><code>cin.get(一个参数)</code>缓冲区中读取一个字符。</li><li><code> cin.get(两个参数)</code>读取字符串，不读换行符。</li><li><code>cin.getline()</code>读取字符串，读取换行符并扔掉。</li><li><code>cin.ignore(N)</code>忽略N个字符。</li><li><code>cin.peek()</code>偷窥，偷看一个字符然后放回缓冲区 。</li><li><code>cin.putback(c)</code>把字符c放回缓冲区。</li><li><code>cin.fail()</code>看标志位，0正常，1不正常。</li><li><code>cin.clear()</code>重置标志位。</li><li><code>cib.sync()</code>清空缓冲区。</li></ul><h1 id="标准输出流"><a href="#标准输出流" class="headerlink" title="标准输出流"></a>标准输出流</h1><ul><li><code>cout.flush</code>刷新缓冲区，Linux有效。</li><li><code>cout.put()</code> 向缓冲区写字符。</li><li><code>cout.write()</code>从缓冲区写num个字节到当前输出流中。</li></ul><p><img src="https://s2.loli.net/2022/02/22/H1IZo4N5h6X7Dji.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++异常</title>
      <link href="2022/02/21/C++%E5%BC%82%E5%B8%B8/"/>
      <url>2022/02/21/C++%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><ul><li>基本思想：将问题检测和问题处理相分离。</li><li>try试图执行try{}中的内容。</li><li>在可能出现异常的地方抛出异常 eg： throw -1； </li><li>try下面catch捕获异常。</li><li>catch(捕获类型)   …代表所有其他类型。</li><li>如果不能处理异常，继续向上抛出  thow；</li><li>如果没有任何处理异常的地方，那么程序调用terminate函数终止程序 。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myDevide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="number">-1</span>;  <span class="comment">// 抛出int异常</span></span><br><span class="line">        <span class="comment">// throw 3.14;  抛出double异常</span></span><br><span class="line">        <span class="comment">// throw &quot;a&quot;;</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="built_in">myDevide</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">int</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;int error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">double</span>) &#123;</span><br><span class="line">        <span class="comment">// throw;  如果加上这个，则异常向上反馈，最后只输出 main double error</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;double error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(...) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;other error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">test01</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">double</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;main double error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h1><h2 id="自己写类"><a href="#自己写类" class="headerlink" title="自己写类"></a>自己写类</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;自定义 error&quot;</span> &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myDevide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">MyException</span>();  <span class="comment">// 匿名对象    </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="built_in">myDevide</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(MyException e) &#123;</span><br><span class="line">e.<span class="built_in">prinError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承系统中自带的"><a href="#继承系统中自带的" class="headerlink" title="继承系统中自带的"></a>继承系统中自带的</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyOutOfRangeException</span> :</span> <span class="keyword">public</span> exception &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyOutOfRangeException</span>(string errorInfo) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_ErrorInfo = errorInfo;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">MyOutOfRangeException</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> cont <span class="keyword">char</span>* <span class="title">what</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_ErrorInfo.<span class="built_in">c_str</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    string m_ErrorInfo;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h1 id="栈解旋"><a href="#栈解旋" class="headerlink" title="栈解旋"></a>栈解旋</h1><ul><li>从try开始到throw抛出异常前，所有栈上的对象都会被释放，这个过程称为栈解旋。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;自定义 error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myDevide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 栈解旋</span></span><br><span class="line">        <span class="comment">// 从try开始到throw抛出异常前，所有栈上的对象都会被释放，这个过程称为栈解旋。</span></span><br><span class="line">        Person p1;</span><br><span class="line">        Person p2;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">MyException</span>();  <span class="comment">// 匿名对象    </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="built_in">myDevide</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(MyException e) &#123;</span><br><span class="line">e.<span class="built_in">prinError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">p1构造</span></span><br><span class="line"><span class="comment">p2构造</span></span><br><span class="line"><span class="comment">p2析构</span></span><br><span class="line"><span class="comment">p1析构</span></span><br><span class="line"><span class="comment">自定义 error</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="异常接口声明"><a href="#异常接口声明" class="headerlink" title="异常接口声明"></a>异常接口声明</h1><ul><li>抛出特定类型异常。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该代码不能在VS里运行，可以在QT和linux运行。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="title">throw</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span>)</span>  </span>&#123;<span class="comment">// throw(int)只能抛出int类型异常 throw()不抛出任何类型异常</span></span><br><span class="line"><span class="keyword">throw</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">int</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;int error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="异常变量的生命周期"><a href="#异常变量的生命周期" class="headerlink" title="异常变量的生命周期"></a>异常变量的生命周期</h1><ul><li>如果<code>catch(MyException e)</code> 会多开销一份数据，调用拷贝构造。</li><li>如果<code>catch(MyException *e)</code>，如果不new会提前释放对象，new需要自己释放delete。</li><li>推荐<code>catch(MyException &amp;e)</code>，只一份数据。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyException</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;MyException moren gouzao&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">MyException</span>(<span class="keyword">const</span> MyException &amp;e) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;MyException kaobei gouzao&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;自定义 error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">MyException</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;MyException xigou&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">MyException</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">doWork</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(MyException &amp;e) &#123; <span class="comment">// MyException e会多开销一份数据</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;catch error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">输出catch(MyException e)情况：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">MyException moren gouzao</span></span><br><span class="line"><span class="comment">MyException kaobei gouzao</span></span><br><span class="line"><span class="comment">catch error</span></span><br><span class="line"><span class="comment">MyException xigou</span></span><br><span class="line"><span class="comment">MyException xigou</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注：编译器会做优化，不会立刻将匿名对象释放掉，所以可以改为 catch(MyException &amp;e)减少开销。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="异常的多态使用"><a href="#异常的多态使用" class="headerlink" title="异常的多态使用"></a>异常的多态使用</h1><ul><li>利用多态实现<code>printError()</code>同一个接口调用。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseException</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">printError</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NullPointException</span> :</span> <span class="keyword">public</span> BaseException  &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt;  <span class="string">&quot;Null Point Error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">NullPointException</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">doWork</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(BaseException &amp;e) &#123;</span><br><span class="line">        e.<span class="built_in">printError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="系统标准异常使用"><a href="#系统标准异常使用" class="headerlink" title="系统标准异常使用"></a>系统标准异常使用</h1><ul><li>头文件<code>#include&lt;stdexcept&gt;</code>。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">if</span>(age &lt; <span class="number">0</span> || age &gt; <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;年龄越界！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span>  </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="number">1000</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(out_of_range &amp;e) &#123;</span><br><span class="line">        cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;  <span class="comment">// 年龄越界！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++类型转换</title>
      <link href="2022/02/20/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
      <url>2022/02/20/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="静态类型转换（static-cast）"><a href="#静态类型转换（static-cast）" class="headerlink" title="静态类型转换（static_cast）"></a>静态类型转换（static_cast）</h1><ul><li><p>写法<code>static_cast&lt;目标类型&gt;(原始对象)</code>。</p></li><li><p>可以进行基础类型转换。</p></li><li><p>父与子的class可以转换。</p></li><li><p>没有父子关系的class不可以转换。</p></li></ul><h1 id="动态类型转换（dynamic-cast）"><a href="#动态类型转换（dynamic-cast）" class="headerlink" title="动态类型转换（dynamic_cast）"></a>动态类型转换（dynamic_cast）</h1><ul><li><p>写法<code>dynamic_cast&lt;目标类型&gt;(原始对象)</code>。</p></li><li><p>不可以转换基础数据类型。</p></li><li><p>父子间可以转换。</p><ul><li>一般父转子，不可以。</li><li>子转父，可以。</li><li>如果发生多态，都可以。</li></ul></li></ul><h1 id="常量转换（const-cast）"><a href="#常量转换（const-cast）" class="headerlink" title="常量转换（const_cast）"></a>常量转换（const_cast）</h1><ul><li><p>写法<code>const_cast&lt;目标类型&gt;(原始对象)</code>。</p></li><li><p>用来修改类型的const属性。</p><ul><li>常量指针和非常量指针相互转换，并且仍然指向原来对象。</li><li>常量引用和非常量引用相互转换，并且仍然指向原来对象。</li></ul></li></ul><p>​    <font color=red><strong>注意：不能对非指针和非引用的变量使用const_cast操作符去移除他的const。</strong></font></p><h1 id="重新解释转换（reinterpret-cast）"><a href="#重新解释转换（reinterpret-cast）" class="headerlink" title="重新解释转换（reinterpret_cast）"></a>重新解释转换（reinterpret_cast）</h1><ul><li><p>写法<code>reinterpret_cast&lt;目标类型&gt;(原始对象)</code>。</p></li><li><p>什么都可以转，最不安全，不推荐。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 类型转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++模板</title>
      <link href="2022/02/18/C++%E6%A8%A1%E6%9D%BF/"/>
      <url>2022/02/18/C++%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h1><p>​        函数模板实际上是建立一个通用函数，其函数类型和形参类型不具体制定用一个虚拟的类型来代表，这个通用函数就是函数模板。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型参数化，泛型编程</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span>  <span class="comment">// 告诉编译器，T是一个通用类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap</span><span class="params">(T &amp;a, T &amp;b)</span> </span>&#123;</span><br><span class="line">    T tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// typename和class二者没啥区别,等价</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 自动类型推导</span></span><br><span class="line">    <span class="built_in">mySwap</span>(a, b);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 显式指定类型</span></span><br><span class="line">    mySwap&lt;<span class="keyword">int</span>&gt;(a, b);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 模板必须指定出T才可以使用。</span></span><br><span class="line">    <span class="built_in">func</span>();  <span class="comment">// 报错</span></span><br><span class="line">    func&lt;<span class="keyword">int</span>&gt;(); <span class="comment">// 正常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数模板和普通函数区别以及调用规则"><a href="#函数模板和普通函数区别以及调用规则" class="headerlink" title="函数模板和普通函数区别以及调用规则"></a>函数模板和普通函数区别以及调用规则</h1><p><strong>区别:</strong></p><ul><li>函数模板不能进行隐式类型转换，普通函数可以。</li></ul><p><strong>调用规则：</strong></p><ul><li>c++编译器优先考虑普通函数。</li><li>可以通过空模板实参列表的语法限定编译器只能通过模板匹配。</li><li>函数模板可以向普通函数一样被重载。</li><li>如果函数模板可以产生一个更好的匹配，优先使用函数模板。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt; </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPlus</span><span class="params">(T &amp;a, T &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPlus01</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">myPlus</span>(a, c); <span class="comment">// 报错，不能执行</span></span><br><span class="line">    <span class="built_in">myPlus2</span>(a, c); <span class="comment">// 可以执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数和函数模板的调用规则</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt; </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(T &amp;a, T &amp;b)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;函数模板print&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt; </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(T &amp;a, T &amp;b, T &amp;c)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;重载函数模板print&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;普通函数print&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果出现重载，优先使用普通函数调用，如果普通函数只声明没有实现，会出现错误</span></span><br><span class="line"><span class="built_in">myPrint</span>(a, b); <span class="comment">// 普通函数print</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果想强制使用模板，可以使用空参数列表</span></span><br><span class="line">    myPrint&lt;&gt;(a, b);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 函数模板可以发生重载</span></span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">30</span>;</span><br><span class="line">    <span class="built_in">myPrint</span>(a, b, c);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果函数模板可以产生更好的匹配，优先使用函数模板</span></span><br><span class="line">    <span class="keyword">char</span> d = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">    <span class="keyword">char</span> e = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line"><span class="built_in">myPrint</span>(d, e); <span class="comment">// 调用函数模板</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="模板机制"><a href="#模板机制" class="headerlink" title="模板机制"></a>模板机制</h1><ul><li>模板不是万能的，不能适用所有的数据类型。</li><li>函数模板通过具体类型产生不同的函数。</li><li>编译器对函数模板进行<strong>两次</strong>编译，在声明地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译（替换后代码称为模板函数）。</li></ul><h1 id="模板局限性及解决"><a href="#模板局限性及解决" class="headerlink" title="模板局限性及解决"></a>模板局限性及解决</h1><ul><li>模板不能解决所有的类型。</li><li>如果出现不能解决的类型，可以通过第三代具体化进行解决。</li><li>语法<code>template &lt;&gt; 返回值 函数名&lt;具体类型&gt;(参数)&#123;&#125;</code>       返回值和函数名必须和模板一致。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="keyword">int</span> age) : <span class="built_in">mName</span>(name), <span class="built_in">mAge</span>(age)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    string mName;</span><br><span class="line">    <span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCompare</span><span class="params">(T &amp;a, T &amp;b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a == b) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过第三代具体化自定义数据类型解决问题</span></span><br><span class="line"><span class="comment">// 如果具体化能够优先匹配，那么选择具体化</span></span><br><span class="line"><span class="comment">// 语法template &lt;&gt; 返回值 函数名&lt;具体类型&gt;(参数)      返回值和函数名必须和模板一致</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">bool</span> myCompare&lt;Person&gt;(Person &amp;a, Person &amp;b) &#123;</span><br><span class="line"><span class="keyword">if</span>(a.mAge == b.mAge) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;jerry&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="built_in">myCompare</span>(p1, p2);  <span class="comment">// 如果没具体化自定义实现会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h1><ul><li>写法：<code>template&lt;class T, ...&gt;</code> 紧跟着类。</li><li>相比于函数模板，类模板可以有默认类型参数。</li><li>函数模板可以进行自动类型推导，类模板不可以。</li><li>成员函数一开始不会创建，在运行时才会创建。</li></ul><p><strong>类模板做函数的参数的三种方式：</strong></p><ul><li>显式指定类型</li><li>xxxxxxxxxx #include<stdexcept>​class Person {public:    Person(int age) {        if(age &lt; 0 || age &gt; 200) {            throw out_of_range(“年龄越界！”);        }    }        int m_Age;};​void test01()  {    try {        Person p(1000);    }    catch(out_of_range &amp;e) {        cout &lt;&lt; e.what() &lt;&lt; endl;  // 年龄越界！    }}c++</li><li>整体模板化</li></ul><p><strong>查看类型名称的方式：</strong><code>typeid(T1).name</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">NameType</span>, <span class="keyword">class</span> <span class="title">AgeType</span> =</span> <span class="keyword">int</span>&gt;  <span class="comment">// 类模板可以有默认类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(NameType name, Agetype age) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;age:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    NameType m_Name;</span><br><span class="line">    AgeType m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 类模板不支持自动类型推导</span></span><br><span class="line">    <span class="comment">// Person p(&quot;goudan&quot;, 100);   会出错</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">Person&lt;string, <span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;goudan&quot;</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传参方式</span></span><br><span class="line"><span class="comment">// 1.指定传入类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork1</span><span class="params">(Person&lt;string, <span class="keyword">int</span>&gt; &amp;p)</span> </span>&#123;</span><br><span class="line">    p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.参数模板化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T1, class T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork2</span><span class="params">(Person&lt;T1, T2&gt; &amp;p)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 如何查看类型</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(T1).name &lt;&lt; endl;</span><br><span class="line">    p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.整体模板化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork3</span><span class="params">(T &amp;p)</span> </span>&#123;</span><br><span class="line">p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person&lt;string, <span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;goudan&quot;</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="built_in">doWork1</span>(p);</span><br><span class="line">    <span class="built_in">doWork2</span>(p);</span><br><span class="line">    <span class="built_in">doWork3</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类模板碰到继承的问题"><a href="#类模板碰到继承的问题" class="headerlink" title="类模板碰到继承的问题"></a>类模板碰到继承的问题</h1><ul><li>基类如果是模板类，必须让子类告诉编译器基类中的T是什么类型。否则无法分配内存，编译不通过。</li><li>利用参数列表<code>class Child : public Base&lt;int&gt;</code> </li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// child继承base必须告诉base中T的类型，否则无法分配内存</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Base&lt;<span class="keyword">int</span>&gt; &#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// child2 也是模板类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child2</span> :</span> <span class="keyword">public</span> Base&lt;T2&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T1 m_B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Child2&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt; c2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>类模板类外实现成员函数：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">NameType</span>, <span class="keyword">class</span> <span class="title">AgeType</span>&gt;</span>  <span class="comment">// 类模板可以有默认类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(NameType name, Agetype age); </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    NameType m_Name;</span><br><span class="line">    AgeType m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">NameType</span>, <span class="keyword">class</span> <span class="title">AgeType</span>&gt;</span></span><br><span class="line">Person&lt;NameType, AgeType&gt;::<span class="built_in">Person</span>(NameType name, Agetype age) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">NameType</span>, <span class="keyword">class</span> <span class="title">AgeType</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> Person&lt;NameType, AgeType&gt;::<span class="built_in">showPerson</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color=red><strong>注意：类模板不要用分文件编写，如果用正常的分文件编写会出现问题，因为类模板成员函数一开始不会创建，在运行时才会创建，导致包含.h头文件，不会创建函数实现，无法解析外部命令，所以在检查#include“Person.h”不会有问题，但是到链接阶段会链接不到成员函数，可以改成#include“Person.cpp”（但是一般不这么做，一般解决方案为：把实现和声明放在一个文件下，改名为hpp文件，hpp一般为模板）</strong></font></p><h1 id="类模板碰到友元函数"><a href="#类模板碰到友元函数" class="headerlink" title="类模板碰到友元函数"></a>类模板碰到友元函数</h1><p><strong>友元函数类内实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">printPerson</span><span class="params">(Person&lt;T1, T2&gt; &amp;p)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; p.m_Name &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(T1 name, T2 age) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;age:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 m_Name;</span><br><span class="line">    T2 m_Age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>友元函数类外实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 让编译器看到printPErson,否则编译器看不到他的声明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 让编译器看到Person类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span><span class="class"><span class="keyword">class</span> <span class="title">Person</span>;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span><span class="function"><span class="keyword">void</span> <span class="title">printPerson</span><span class="params">(Person&lt;T1, T2&gt; &amp;p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="comment">// 友元函数类外实现，利用空参数列表&lt;&gt;告诉编译器这是模板函数声明，否则是普通函数声明</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> printPerson&lt;&gt;(Person&lt;T1, T2&gt; &amp;p);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(T1 name, T2 age) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;age:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 m_Name;</span><br><span class="line">    T2 m_Age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T1, class T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPerson</span><span class="params">(Person&lt;T1, T2&gt; &amp;p)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; p.m_Name &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++多态</title>
      <link href="2022/01/17/C++%E5%A4%9A%E6%80%81/"/>
      <url>2022/01/17/C++%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><ul><li><p>C++支持编译时多态（静态多态）和运行时多态（动态多态）。重载–静态多态。虚函数和继承–动态多态。</p></li><li><p>静态多态和动态多态的区别就是函数地址是早绑定（静态连编，编译阶段绑定好地址）还是晚绑定（动态联编，运行时绑定好地址）。</p></li><li><p>什么叫多态？</p><ul><li>父类的引用或指针指向子类对象。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;   <span class="comment">// 改为 virtual void speak()</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;animal speak&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cat</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;  <span class="comment">// 子类中的 virtual 可写可不写</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;cat speak&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数func里， speak函数的地址早就绑定好了，在编译阶段就确定了地址</span></span><br><span class="line"><span class="comment">// 如果像调用cat的speak，不能提前绑定好函数地址，所以需要在运行的时候再去确定函数地址</span></span><br><span class="line"><span class="comment">// 动态联编写法：把speak（）在父类声明为虚函数，就发生了多态</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Animal &amp;animal)</span> </span>&#123;</span><br><span class="line">    animal.<span class="built_in">speak</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Cat cat;</span><br><span class="line">    <span class="built_in">func</span>(cat);  <span class="comment">// animal speak;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="多态内部原理"><a href="#多态内部原理" class="headerlink" title="多态内部原理"></a>多态内部原理</h1><ul><li>Animal 内部结构<ul><li><p>Animal 内部存在一个vfptr（virtual function pointer）虚函数表指针。</p></li><li><p>虚函数表指针指向虚函数表。</p></li><li><p>当Cat中没有写speak函数时，Cat的vfptr指向Animal speak函数，如下图：</p></li><li><p><img src="https://s2.loli.net/2022/01/18/XW46U1CHu3JRas8.png" alt="image.png"></p></li><li><p>当Cat中重写了speak函数后，Cat的vfptr指向自己的cat speak函数（对象创建的时候，调用构造函数，将所有的虚函数指针都指向自己的虚函数表，这个操作我们看不到），如下图：</p></li><li><p><img src="https://s2.loli.net/2022/01/18/u7mxhFrbGjA6kvI.png" alt="image.png"></p></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(Animal) &lt;&lt; endl;  <span class="comment">// 没加virtual时是1，加了以后是4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>深入剖析内部调用</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Animal * animal = <span class="keyword">new</span> Cat;</span><br><span class="line">    <span class="comment">// (*(int *)*(int *)animal) 为函数地址</span></span><br><span class="line">    ((<span class="built_in"><span class="keyword">void</span></span>(*)()) (*(<span class="keyword">int</span> *)*(<span class="keyword">int</span> *)animal))();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h1><ul><li>如果父类有纯虚函数，子类继承父类，子类必须将其实现，否则子类也是一个抽象类。</li><li>如果父类有纯虚函数，那么父类不能实例化对象。</li><li>如果类有了纯虚函数，通常称为抽象类。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;   <span class="comment">// 虚函数</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;animal speak&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 纯虚函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h1><ul><li>虚析构解决问题：是为了delete基类指针指向派生类时防止子类的数据不会被释放造成内存泄露。</li><li>纯虚析构：<ul><li>纯虚析构，需要声明，还需要实现，类内声明，类外实现。</li><li>如果类中出现纯虚析构，那么这个类也算抽象类。</li><li>抽象类不能实例化对象。</li></ul></li><li>虚析构和纯虚析构区别：纯虚析构的类不能实例化对象。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Animal speak&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 普通析构 不会调用子类的析构，所以可能导致释放不干净</span></span><br><span class="line">    <span class="comment">// 利用虚析构解决该问题</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Animal xigou&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 纯虚析构</span></span><br><span class="line">    <span class="comment">// 纯虚析构，需要声明，还需要实现，类内声明，类外实现</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal::~<span class="built_in">Animal</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Animal chunxu&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cat</span>(<span class="keyword">const</span> <span class="keyword">char</span> * name) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;mName = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(name) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;name, name);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Cat speak&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">Cat</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Cat xigou&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;mName != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;mName;</span><br><span class="line">            <span class="keyword">this</span>-&gt;mName = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>* mName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Animal * cat = <span class="keyword">new</span> <span class="built_in">Cat</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    animal-&gt;<span class="built_in">speak</span>();   <span class="comment">// Cat speak</span></span><br><span class="line">    <span class="keyword">delete</span> animal;  <span class="comment">// 父类析构函数没加virtual：Animal xigou</span></span><br><span class="line">    <span class="comment">// 父类改成虚析构后： Cat xigou</span></span><br><span class="line">    <span class="comment">//   Animal xigou</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="为什么静态成员函数不能是虚函数"><a href="#为什么静态成员函数不能是虚函数" class="headerlink" title="为什么静态成员函数不能是虚函数"></a>为什么静态成员函数不能是虚函数</h1><ul><li>静态成员函数不属于类中的任何一个对象和实例，属于类共有的函数，因此不能通过this指针访问，因为this指针指向的是每一个对象和实例，而虚函数的调用恰恰需要this指针。虚函数的类实例是通过this指针调用vptr指针，指向虚函数表，通过虚函数表找到需要调用的虚函数地址。this-&gt;vptr-&gt;vtabel-&gt;virtual 函数。</li></ul><h1 id="为什么析构函数一般写成虚函数"><a href="#为什么析构函数一般写成虚函数" class="headerlink" title="为什么析构函数一般写成虚函数"></a>为什么析构函数一般写成虚函数</h1><ul><li>析构函数定义成虚函数是为了防止内存泄漏，因为当父类指针或引用指向或绑定子类对象时，如果未将基类的析构函数定义成虚函数，会调用基类的析构函数，那么只能将基类的成员所占空间释放掉，子类中特有的会无法释放内存空间导致内存泄漏。</li></ul><h1 id="为什么构造函数一般不写为虚函数"><a href="#为什么构造函数一般不写为虚函数" class="headerlink" title="为什么构造函数一般不写为虚函数"></a>为什么构造函数一般不写为虚函数</h1><ul><li>构造函数是在实例化对象的时候进行调用，而虚函数指针是在实例化对象后才产生，而虚函数调用需要通过虚函数指针指向虚函数表从而得到虚函数地址来调用，如果声明成虚函数，在构造的时候由于并没有实例化对象，从而没有虚函数指针从而不能调用构造函数实例化对象。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 多态 </tag>
            
            <tag> 抽象类 </tag>
            
            <tag> 纯虚函数 </tag>
            
            <tag> 虚函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++继承</title>
      <link href="2022/01/15/C++%E7%BB%A7%E6%89%BF/"/>
      <url>2022/01/15/C++%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><ul><li>解决代码的复用。</li><li>语法： class 子类 ： 继承方式  父类</li></ul><h1 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h1><ul><li>三种：public、private、protected</li></ul><p><img src="https://s2.loli.net/2022/01/16/x3k79EPCJQdefIL.png" alt="QQ截图20220116151208.png"></p><ul><li>子类会继承父类的所有内容，包括私有属性，只是被编译器隐藏起来，访问不到私有成员。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>()&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(Son) &lt;&lt; endl;   <span class="comment">// 输出16；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="继承中的构造和析构函数"><a href="#继承中的构造和析构函数" class="headerlink" title="继承中的构造和析构函数"></a>继承中的构造和析构函数</h1><ul><li>子类会继承父类的成员属性和成员函数，但是子类不会继承父类的构造函数和析构函数。只有父类自己知道如何构造和析构自己的属性，而子类不知道。另外operator=也不会继承下来。</li><li>子类创建对象时，会先调用父类的构造，然后调用自身的构造。</li><li>析构顺序和构造顺序正好相反。</li><li>当父类的构造函数有参数时，需要在子类初始化列表（参数列表）中显式调用父类的构造函数。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base2</span>(<span class="keyword">int</span> a) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;有参构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son2</span> :</span> <span class="keyword">public</span> Base2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Son2() &#123;&#125;   // 报错，不存在无参构造</span></span><br><span class="line">    <span class="built_in">Son2</span>(<span class="keyword">int</span> a) : <span class="built_in">Base2</span>(a) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="继承中的同名处理"><a href="#继承中的同名处理" class="headerlink" title="继承中的同名处理"></a>继承中的同名处理</h1><ul><li>如果子类和父类拥有同名的属性和函数，子类不会覆盖父类成员，加作用域就可调父类的。</li><li>如果子类与父类的成员函数名称相同，子类会把父类的<strong>所有</strong>同名版本都隐藏掉，想调用必须加作用域。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123;</span><br><span class="line">        m_A = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base func&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Son</span>() &#123;</span><br><span class="line">        m_A = <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Son func&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Son S1;</span><br><span class="line">    cout &lt;&lt; s1.m_A &lt;&lt; endl;  <span class="comment">// cout 200</span></span><br><span class="line">    cout &lt;&lt; s1.Base::m_A &lt;&lt;endl;  <span class="comment">// cout 100</span></span><br><span class="line"></span><br><span class="line">    s1.<span class="built_in">func</span>();</span><br><span class="line">    s1.Base::<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="继承中静态成员的处理"><a href="#继承中静态成员的处理" class="headerlink" title="继承中静态成员的处理"></a>继承中静态成员的处理</h1><ul><li>静态成员属性，子类可以继承下来。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Base::m_A = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; Son::m_A &lt;&lt;endl;  <span class="comment">// cout 10;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base func&quot;</span> &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base func(int)&quot;</span> &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Base::m_A = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Son func&quot;</span> &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Son::m_A = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; Son::m_A &lt;&lt;endl;  <span class="comment">// cout 20;</span></span><br><span class="line">    cout &lt;&lt; Base::m_A &lt;&lt;endl;  <span class="comment">// cout 10;</span></span><br><span class="line"></span><br><span class="line">    Son::<span class="built_in">func</span>();      <span class="comment">// Son func</span></span><br><span class="line">    Base::<span class="built_in">func</span>();    <span class="comment">// Base func</span></span><br><span class="line">    Son::Base::<span class="built_in">func</span>(<span class="number">10</span>);    <span class="comment">// Base func(int)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h1><ul><li>多继承中很容易引发二义性问题</li><li>语法 ： class Son : public Base1, public Base2 {}</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base1</span>() &#123;</span><br><span class="line">        m_A = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base2</span>() &#123;</span><br><span class="line">        m_A = <span class="number">20</span>;</span><br><span class="line">    &#125;A</span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_C;</span><br><span class="line">    <span class="keyword">int</span> m_D;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(Son) &lt;&lt; endl;     <span class="comment">// 16</span></span><br><span class="line"></span><br><span class="line">    Son s1;</span><br><span class="line">    <span class="comment">// s1.m_A;        // 二义性 error</span></span><br><span class="line">    cout &lt;&lt; s1.Base1::m_A &lt;&lt; endl;  <span class="comment">// 10</span></span><br><span class="line">    cout &lt;&lt; s1.Base2::m_A &lt;&lt; endl;  <span class="comment">// 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="菱形继承和虚继承"><a href="#菱形继承和虚继承" class="headerlink" title="菱形继承和虚继承"></a>菱形继承和虚继承</h1><ul><li>菱形继承存在部分数据重复继承两份的问题，为解决该问题，采用虚继承的方式。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tuo</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SheepTuo</span> :</span> <span class="keyword">public</span> Sheep, <span class="keyword">public</span> Tuo &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SheepTuo st;</span><br><span class="line">    st.Sheep::m_Age = <span class="number">10</span>;</span><br><span class="line">    st.Tuo::m_Age = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">// 存在两份数据，造成资源浪费</span></span><br><span class="line">    cout &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;   <span class="comment">// 10</span></span><br><span class="line">    cout &lt;&lt; st.Tuo::m_Age &lt;&lt; endl;     <span class="comment">// 20;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用虚继承解决：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tuo</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SheepTuo</span> :</span> <span class="keyword">public</span> Sheep, <span class="keyword">public</span> Tuo &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 虚继承后操作一份共享数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SheepTou st;</span><br><span class="line">    st.Sheep::m_Age = <span class="number">10</span>;</span><br><span class="line">    st.Tuo::m_Age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;   <span class="comment">// 20</span></span><br><span class="line">    cout &lt;&lt; st.Tuo::m_Age &lt;&lt; endl;     <span class="comment">// 20;</span></span><br><span class="line">    cout &lt;&lt; st.m_Age &lt;&lt; endl;         <span class="comment">// 此时可以直接访问，没有二义性的情况了，只有一份m_Age</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/01/16/TdmLwOuqiYxXVaM.png" alt="QQ截图20220116203008.png"></p><h1 id="向上类型转换和向下类型转换"><a href="#向上类型转换和向下类型转换" class="headerlink" title="向上类型转换和向下类型转换"></a>向上类型转换和向下类型转换</h1><ul><li>基类转派生类。<ul><li>向下类型转换   安全的。</li></ul></li><li>派生类转基类。<ul><li>向上类型转换  不安全。</li></ul></li><li>如果发生了多态。<ul><li>总是安全的。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 继承 </tag>
            
            <tag> 父类子类转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四旋翼仿真控制模块</title>
      <link href="2022/01/15/%E5%9B%9B%E6%97%8B%E7%BF%BC%E4%BB%BF%E7%9C%9F%E5%90%84%E6%A8%A1%E5%9D%97%E6%A2%B3%E7%90%86/"/>
      <url>2022/01/15/%E5%9B%9B%E6%97%8B%E7%BF%BC%E4%BB%BF%E7%9C%9F%E5%90%84%E6%A8%A1%E5%9D%97%E6%A2%B3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="PositionControl"><a href="#PositionControl" class="headerlink" title="PositionControl"></a>PositionControl</h1><p>​        以下模块参照PX4源码。</p><h2 id="positionControl"><a href="#positionControl" class="headerlink" title="_positionControl"></a>_positionControl</h2><p>所需数据：_pos_sp 和 _pos 和 _gain_pos_p 和 _lim_vel_horizontal</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> PositionControl::_positionControl() &#123;</span><br><span class="line">    <span class="comment">// P-position controller  对位置进行p比例控制</span></span><br><span class="line">    Vector3f vel_sp_position = (_pos_sp - _pos).<span class="built_in">emult</span>(_gain_pos_p);</span><br><span class="line">    <span class="comment">// Position and feed-forward velocity setpoints or position states being NAN results in them not having an influence位置和前馈速度设定点或位置状态为 NAN 导致它们没有影响</span></span><br><span class="line">    _vel_sp += vel_sp_position;</span><br><span class="line">    <span class="comment">// 确保没有NAN</span></span><br><span class="line">    <span class="comment">// ControlMath::setZeroIfNanVector3f(vel_sp_position); </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过优先考虑沿方向的速度分量来约束水平速度</span></span><br><span class="line">    <span class="comment">// 前馈项上的期望位置设定值。</span></span><br><span class="line">    _vel_sp.<span class="built_in">xy</span>() = ControlMath::<span class="built_in">constrainXY</span>(vel_sp_position.<span class="built_in">xy</span>(), (_vel_sp - vel_sp_position).<span class="built_in">xy</span>(), _lim_vel_horizontal);  <span class="comment">// _lim_vel_horizontal水平速度限制</span></span><br><span class="line">    <span class="comment">// Constrain velocity in z-direction. 可以不考虑z轴</span></span><br><span class="line">    <span class="comment">// _vel_sp(2) = math::constrain(_vel_sp(2), -_lim_vel_up, _lim_vel_down);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="velocityControl"><a href="#velocityControl" class="headerlink" title="_velocityControl"></a>_velocityControl</h2><p>来自_positionControl： _vel_sp </p><p>所需数据： _vel 和 _gain_vel_p 和 _gain_vel_d</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> PositionControl::_velocityControl(<span class="keyword">const</span> <span class="keyword">float</span> dt) &#123;</span><br><span class="line"><span class="comment">// PID velocity control</span></span><br><span class="line">    Vector3f vel_error = _vel_sp - _vel;  <span class="comment">// 速度误差</span></span><br><span class="line">    Vector3f acc_sp_velocity = vel_error.<span class="built_in">emult</span>(_gain_vel_p) + _vel_int - _vel_dot.<span class="built_in">emult</span>(_gain_vel_d);  <span class="comment">// emult是乘 _gain_vel_p </span></span><br><span class="line">    <span class="comment">// 如果acc_sp_velocity不是NAN值，就加到期望加速度里，</span></span><br><span class="line">    _acc_sp += acc_sp_velocity； <span class="comment">// _acc_sp 期望加速度</span></span><br><span class="line"></span><br><span class="line">    _accelerationControl();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 垂直方向积分器抗饱和  感觉没用</span></span><br><span class="line"><span class="comment">//if ((_thr_sp(2) &gt;= -_lim_thr_min &amp;&amp; vel_error(2) &gt;= 0.0f) ||</span></span><br><span class="line"><span class="comment">//    (_thr_sp(2) &lt;= -_lim_thr_max &amp;&amp; vel_error(2) &lt;= 0.0f)) &#123;</span></span><br><span class="line"><span class="comment">//vel_error(2) = 0.f;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在保持水平边距的同时，优先考虑垂直控制</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> Vector2f <span class="title">thrust_sp_xy</span><span class="params">(_thr_sp)</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> thrust_sp_xy_norm = thrust_sp_xy.<span class="built_in">norm</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> thrust_max_squared = math::<span class="built_in">sq</span>(_lim_thr_max);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 确定在保持水平边距的情况下还剩下多少垂直推力  这部分应该不重要</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> allocated_horizontal_thrust = math::<span class="built_in">min</span>(thrust_sp_xy_norm, _lim_thr_xy_margin);  <span class="comment">// 分配的水平推力</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> thrust_z_max_squared = thrust_max_squared - math::<span class="built_in">sq</span>(allocated_horizontal_thrust);    <span class="comment">// 推力 z 最大平方</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 饱和最大垂直推力  感觉没用</span></span><br><span class="line">    _thr_sp(<span class="number">2</span>) = math::<span class="built_in">max</span>(_thr_sp(<span class="number">2</span>), -<span class="built_in">sqrtf</span>(thrust_z_max_squared));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 确定优先垂直控制后还剩多少水平推力</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> thrust_max_xy_squared = thrust_max_squared - math::<span class="built_in">sq</span>(_thr_sp(<span class="number">2</span>));</span><br><span class="line"><span class="keyword">float</span> thrust_max_xy = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (thrust_max_xy_squared &gt; <span class="number">0</span>) &#123;</span><br><span class="line">thrust_max_xy = <span class="built_in">sqrtf</span>(thrust_max_xy_squared);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 水平方向饱和推力</span></span><br><span class="line"><span class="keyword">if</span> (thrust_sp_xy_norm &gt; thrust_max_xy) &#123;</span><br><span class="line">_thr_sp.<span class="built_in">xy</span>() = thrust_sp_xy / thrust_sp_xy_norm * thrust_max_xy;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 水平方向使用跟踪 Anti-Windup：在饱和期间，积分器用于使输出不饱和</span></span><br><span class="line"><span class="comment">// see Anti-Reset Windup for PID controllers, L.Rundqwist, 1990</span></span><br><span class="line">    <span class="comment">// 参见 PID 控制器的防复位饱和，L.Rundqwist，1990</span></span><br><span class="line"><span class="keyword">const</span> Vector2f acc_sp_xy_limited = <span class="built_in">Vector2f</span>(_thr_sp) * (CONSTANTS_ONE_G / _hover_thrust);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> arw_gain = <span class="number">2.f</span> / _gain_vel_p(<span class="number">0</span>);</span><br><span class="line">vel_error.<span class="built_in">xy</span>() = <span class="built_in">Vector2f</span>(vel_error) - (arw_gain * (<span class="built_in">Vector2f</span>(_acc_sp) - acc_sp_xy_limited));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保积分不会得到 NAN</span></span><br><span class="line">ControlMath::<span class="built_in">setZeroIfNanVector3f</span>(vel_error);</span><br><span class="line"><span class="comment">// 更新速度控制的组成部分</span></span><br><span class="line">_vel_int += vel_error.<span class="built_in">emult</span>(_gain_vel_i) * dt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 限制推力积分</span></span><br><span class="line">_vel_int(<span class="number">2</span>) = math::<span class="built_in">min</span>(<span class="built_in">fabsf</span>(_vel_int(<span class="number">2</span>)), CONSTANTS_ONE_G) * <span class="built_in">sign</span>(_vel_int(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="accelerationControl"><a href="#accelerationControl" class="headerlink" title="_accelerationControl"></a>_accelerationControl</h2><p>最终给出期望推力</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> PositionControl::_accelerationControl()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 假设在垂直方向上由于重力产生的标准加速度用于姿态生成</span></span><br><span class="line">Vector3f body_z = <span class="built_in">Vector3f</span>(-_acc_sp(<span class="number">0</span>), -_acc_sp(<span class="number">1</span>), CONSTANTS_ONE_G).<span class="built_in">normalized</span>();</span><br><span class="line">ControlMath::<span class="built_in">limitTilt</span>(body_z, <span class="built_in">Vector3f</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>), _lim_tilt);</span><br><span class="line"><span class="comment">// 假设悬停推力产生标准重力的比例推力</span></span><br><span class="line"><span class="keyword">float</span> collective_thrust = _acc_sp(<span class="number">2</span>) * (_hover_thrust / CONSTANTS_ONE_G) - _hover_thrust;</span><br><span class="line"><span class="comment">// Project thrust to planned body attitude</span></span><br><span class="line">collective_thrust /= (<span class="built_in">Vector3f</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>).<span class="built_in">dot</span>(body_z));</span><br><span class="line">collective_thrust = math::<span class="built_in">min</span>(collective_thrust, -_lim_thr_min);</span><br><span class="line">_thr_sp = body_z * collective_thrust;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> UAV Simulation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UAV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>智能指针</title>
      <link href="2022/01/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
      <url>2022/01/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><p>​        用来托管自定义类型的对象，让对象进行自动释放。</p><h1 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h1><ul><li>Class shared_ptr 实现共享式拥有的概念。多个智能指针指向相同对象，在最后一个指针销毁时释放对象。</li><li>支持定制型删除器，可防范Cross-DLL问题（对象在动态链接库DLL中被new创建，却在另一个DLL内被delete释放）、自动解除互斥锁。</li></ul><h1 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h1><ul><li>Class unique_ptr实现独占式拥有或严格拥有的概念。保证同一时间内只有一个智能指针可以指向该对象，可以移交拥有权。它对于避免内存泄漏（new后没delete）特别有效，一旦拥有者被销毁或者开始拥有另一个对象，先前拥有的那个对象会被销毁，其任何相关资源都会被释放。C++11才开始提供的类型。</li><li>unique_ptr 用于取代auto_ptr。</li></ul><h1 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h1><ul><li>weak_ptr 允许你共享但不拥有某对象，一旦最后一个拥有该对象的智能指针失去了所有权，任何weak_ptr都会自动成空（empty）。因此，在默认和拷贝构造函数之外，weak_ptr只提供“接受一个shared_ptr”的构造函数。</li><li>可打破环状引用问题（两个其实已经没有被使用的对象彼此互指，使之看似还在“被使用”的状态）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 智能指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运算符重载</title>
      <link href="2022/01/14/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
      <url>2022/01/14/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="左移运算符重载"><a href="#左移运算符重载" class="headerlink" title="左移运算符重载"></a>左移运算符重载</h1><ul><li>必须写在写在全局函数中，如果重载时想访问类的私有成员，需要将全局函数作类的友元。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;cout, Person &amp;A) &#123;</span><br><span class="line">    cout &lt;&lt; A.mA;</span><br><span class="line">    <span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="加法运算符重载"><a href="#加法运算符重载" class="headerlink" title="加法运算符重载"></a>加法运算符重载</h1><ul><li>可以在成员函数进行重载，也可以在全局函数重载。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person <span class="keyword">operator</span>+(Person &amp;A, Person&amp; B) &#123;  <span class="comment">// 全局方式  ，局部只需要把参数改下，返回this指针就行</span></span><br><span class="line">Person temp;</span><br><span class="line">    temp.mA = A.mA + B.mA;</span><br><span class="line">    temp.mB = A.mB + B.mB;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="前置递增运算符重载"><a href="#前置递增运算符重载" class="headerlink" title="前置递增运算符重载"></a>前置递增运算符重载</h1><ul><li>可以在成员函数进行重载，也可以在全局函数重载。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInteger</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyInteger</span>() &#123;</span><br><span class="line">mNum = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MyInteger&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">        <span class="keyword">this</span>.mNum++;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mNum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyInteger&amp; <span class="keyword">operator</span>++(MyInteger&amp; A) &#123;</span><br><span class="line">    A.mNum++;</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="后置递增运算符重载"><a href="#后置递增运算符重载" class="headerlink" title="后置递增运算符重载"></a>后置递增运算符重载</h1><ul><li>可以在成员函数进行重载，也可以在全局函数重载。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInteger</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyInteger</span>() &#123;</span><br><span class="line">mNum = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MyInteger <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">        MyInteger tmp = *<span class="keyword">this</span>;</span><br><span class="line">        A.mNum++;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mNum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyInteger <span class="keyword">operator</span>++(MyInteger&amp; A, <span class="keyword">int</span>) &#123;</span><br><span class="line">    MyInteger tmp = A;</span><br><span class="line">    A.mNum++;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="指针运算符重载"><a href="#指针运算符重载" class="headerlink" title="指针运算符重载"></a>指针运算符重载</h1><h2 id="智能指针实现"><a href="#智能指针实现" class="headerlink" title="智能指针实现"></a>智能指针实现</h2><p>用来托管自定义类型的对象，让对象进行自动释放，new出来的对象自动释放。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;age：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;xigou&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 智能指针</span></span><br><span class="line"><span class="comment">// 用来托管自定义类型的对象，让对象进行自动释放</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">smartPointer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">smartPointer</span>(Person *person) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;person = person;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重载-&gt;让智能指针对象像Person *p一样使用</span></span><br><span class="line">    Person * <span class="keyword">operator</span>-&gt;() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;person;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  重载*</span></span><br><span class="line">    Person&amp; <span class="keyword">operator</span>*() &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>-&gt;person;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">smartPointer</span>(Person *person) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;person != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>-&gt;person;</span><br><span class="line">            <span class="keyword">this</span>-&gt;person = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Person *person;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">smartPointer <span class="title">sp</span><span class="params">(<span class="keyword">new</span> Person(<span class="number">10</span>))</span></span>;  <span class="comment">//  开辟到栈上，自动释放</span></span><br><span class="line">    sp-&gt;<span class="built_in">showAge</span>();  <span class="comment">// sp-&gt;-&gt;showAge(),  编译器优化了写法</span></span><br><span class="line">    </span><br><span class="line">    (*sp).<span class="built_in">showAge</span>();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h1><ul><li>系统默认提供给类的赋值运算符写法是简单的值拷贝。</li><li>如果有数据在堆区，可能会有深浅拷贝问题。</li><li>如果想链式编程需要返回return *this;</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">char</span>* name) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;pName = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(name) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;pName, name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;age：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> Person &amp; p) &#123;</span><br><span class="line">        <span class="comment">// 如果原来堆区有内容，先释放掉</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>-&gt;pName != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pName;</span><br><span class="line">            thsi-&gt;pName = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;pName = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(p.pName) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;pName, p.pName);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">Person</span>() &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>-&gt;pName != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pName;</span><br><span class="line">            thsi-&gt;pName = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span>* pName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;goudan&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;gousheng&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;&quot;</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    p3 = p2 = p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="运算符重载"><a href="#运算符重载" class="headerlink" title="[]运算符重载"></a>[]运算符重载</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;myArray[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="和-关系运算符重载"><a href="#和-关系运算符重载" class="headerlink" title="==和!=关系运算符重载"></a>==和!=关系运算符重载</h1><ul><li>类似加号运算符重载</li></ul><h1 id="函数调用运算符重载"><a href="#函数调用运算符重载" class="headerlink" title="函数调用运算符重载"></a>函数调用运算符重载</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">MyPrint <span class="title">myPrint</span><span class="params">()</span></span>;</span><br><span class="line"><span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);  <span class="comment">// 仿函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="amp-amp-和"><a href="#amp-amp-和" class="headerlink" title="&amp;&amp; 和 ||"></a>&amp;&amp; 和 ||</h1><ul><li>这两个不要重载，因为无法实现它们的短路规则。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 重载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>友元</title>
      <link href="2022/01/14/%E5%8F%8B%E5%85%83/"/>
      <url>2022/01/14/%E5%8F%8B%E5%85%83/</url>
      
        <content type="html"><![CDATA[<h1 id="友元目的"><a href="#友元目的" class="headerlink" title="友元目的"></a>友元目的</h1><p>​        访问类中的私有成员属性。</p><h1 id="三种友元"><a href="#三种友元" class="headerlink" title="三种友元"></a>三种友元</h1><ul><li><p>全局函数做友元函数，在类中写<code>friend void show();</code></p></li><li><p>整个类做友元类。在类中写<code>friend class Person;</code></p><ul><li>注意事项：<ul><li>友元关系不能被继承。</li><li>友元关系是单向的，类A是类B的朋友，但是类B不一定是类A的朋友。</li><li>友元关系不具有传递性。类B是类A的朋友，类C是类B的朋友，但是类C和类A不一定是朋友。</li></ul></li></ul></li><li><p>成员函数做友元函数，在类中写<code>friend void Person::show();</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> friend </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>空指针访问成员函数</title>
      <link href="2022/01/14/%E7%A9%BA%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/"/>
      <url>2022/01/14/%E7%A9%BA%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<ul><li>如果成员函数没有用到this，那么空指针可以直接访问。</li><li>如果成员函数用的this指针，需要加if判断，如果this为空，直接return。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;show&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shouAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; mAge &lt;&lt;  endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>() &#123;</span><br><span class="line">Person *p1 = <span class="literal">NULL</span>;</span><br><span class="line">    p1-&gt;<span class="built_in">show</span>();    <span class="comment">// 正常运行</span></span><br><span class="line">    p1-&gt;<span class="built_in">shouAge</span>();<span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存对齐</title>
      <link href="2022/01/14/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"/>
      <url>2022/01/14/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</url>
      
        <content type="html"><![CDATA[<h1 id="结构体内存对齐方式"><a href="#结构体内存对齐方式" class="headerlink" title="结构体内存对齐方式"></a>结构体内存对齐方式</h1><p>​        结构体大小不是个数据成员之和，而是按照一定的对齐数进行对齐存储，最后结构体的大小也是按照一定的对齐数进行对齐。</p><p><strong>对齐规则：</strong></p><ul><li><p>第一个成员在与结构体变量偏移量为0的地址。</p></li><li><p>char 偏移量必须为sizeof(char)即1的倍数 。</p></li><li><p>int 偏移量必须为sizeof(int)即4的倍数 。</p></li><li><p>float 偏移量必须为sizeof(float)即4的倍数 。</p></li><li><p>double 偏移量必须为sizeof(double)即8的倍数 。</p></li><li><p>short 偏移量必须为sizeof(short)即2的倍数 。</p></li><li><p> 结构体总的大小为默认对齐数（该结构中占用最大空间的类型所占用的字节数）的整数倍，所以在为最后一个成员变量申请空间后，还会根据需要自动填充空缺的字节。 </p></li></ul><p><strong>注意：</strong>当内存中的变量变换了顺序后，那么该结构体对象或者该类的对象所占内存空间也会发生变化。</p><p><strong>内存对齐计算方法：</strong></p><ul><li><p>看变量所在偏移地址是否为变量大小的整数倍。</p></li><li><p>看对齐后的总大小是否为最长变量的整数倍。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> dda;    <span class="comment">//偏移量为0，满足对齐方式，dda占用1个字节；</span></span><br><span class="line">    <span class="keyword">double</span> dda1; <span class="comment">//下一个可用的地址的偏移量为1，不是sizeof(double)=8的倍数，需要补足7个字节才能使偏移量变为8（满足对齐方式），因此VC自动填充7个字节，dda1存放在偏移量为8的地址上，它占用8个字节。</span></span><br><span class="line">    <span class="keyword">int</span> type;    <span class="comment">//下一个可用的地址的偏移量为16，是sizeof(int)=4的倍数，满足int的对齐方式，所以不需要VC自动填充，type存放在偏移量为16的地址上，它占用4个字节。</span></span><br><span class="line">    <span class="comment">//共占20个字节，不是默认偏移量（8）的整数倍，需要进行字节填充，最终占24个字节</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStruct1</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> d1;<span class="comment">//偏移量0，满足对齐方式，d1占用8个字节</span></span><br><span class="line">    <span class="keyword">char</span> d2;<span class="comment">//偏移量为8，满足对其方式（是1的倍数），占用1个字节</span></span><br><span class="line">    <span class="keyword">int</span> d3;<span class="comment">//偏移量为9，不满足对其方式（不是4的倍数），需要补3个字节，9+3+4=16</span></span><br><span class="line">    <span class="comment">//最终，占16个字节，是默认偏移量（8）的整数倍，不用补充字节</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(MyStruct) &lt;&lt; endl;  <span class="comment">// 24</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(MyStruct1) &lt;&lt; endl; <span class="comment">// 16</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="内存对齐原因"><a href="#内存对齐原因" class="headerlink" title="内存对齐原因"></a>内存对齐原因</h1><ul><li>平台的移植性好，并不是所有的硬件平台都能存放任意地址的数据，某些平台只能在某些地址访问特定类型的数据，否则会出现异常。</li><li>CPU处理效率高：CPU并不是把内存看成以字节为单位，而是以块为单位，CPU在读取内存的时候是一块一块读取的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 面经 </tag>
            
            <tag> 内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>this指针</title>
      <link href="2022/01/13/this%E6%8C%87%E9%92%88/"/>
      <url>2022/01/13/this%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<ul><li><p>this指针指向被调用的成员函数所属的对象。</p></li><li><p>this是一种隐含指针，它隐含于每个类的非静态成员函数中，静态成员函数内部没有this指针，因此静态成员函数不能操作非静态成员变量。</p></li><li><p>当形参和成员变量同名时，可用this指针区分。</p></li><li><p>在类的非静态成员函数中返回对象本身，可使用 return *this。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> this </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>static</title>
      <link href="2022/01/13/static/"/>
      <url>2022/01/13/static/</url>
      
        <content type="html"><![CDATA[<h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><ul><li>static作用于局部变量，改变局部变量的生存周期，使得该变量存在于定义后直到程序运行结束。</li><li>static作用于全局变量和函数，改变了全局变量作用域，使得全局变量只能在定义它的文件中使用，在源文件中不具有全局可见性。</li><li>static作用于类的成员变量和成员函数，使得类变量或者类成员函数和类有关，可以不定义类的对象就可以通过类访问这些静态成员。类的静态成员函数中只能访问静态成员变量或者静态成员函数，不能将静态成员函数定义成虚函数。</li></ul><h1 id="全局变量、静态全局变量、局部变量和静态局部变量"><a href="#全局变量、静态全局变量、局部变量和静态局部变量" class="headerlink" title="全局变量、静态全局变量、局部变量和静态局部变量"></a>全局变量、静态全局变量、局部变量和静态局部变量</h1><ul><li>全局变量具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包含全局变量定义的源文件需要用extern 关键字再次声明这个全局变量。</li><li>局部变量也只有局部作用域，它是自动对象（auto），它在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回。</li><li>静态局部变量具有局部作用域，它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在，它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。</li><li>静态全局变量也具有全局作用域，它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被static关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。</li></ul><h1 id="static函数与普通函数有什么区别"><a href="#static函数与普通函数有什么区别" class="headerlink" title="static函数与普通函数有什么区别"></a>static函数与普通函数有什么区别</h1><p>​        用static修饰的函数，本限定在本源码文件中，不能被本源码文件以外的代码文件调用。而普通的函数，默认是extern的，也就是说，可以被其它代码文件调用该函数。<br>　　在函数的返回类型前加上关键字static，函数就被定义成为静态函数。普通函数的定义和声明默认情况下是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。</p><p>​        因此定义静态函数有以下好处：</p><ul><li>其他文件中可以定义相同名字的函数，不会发生冲突。</li><li>静态函数不能被其他文件所用。</li></ul><h2 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h2><ul><li>静态成员变量，属于某个类，所有成员共享，即一个类不管创建多少对象，他们都共用一个静态数据。</li><li>静态变量，在编译阶段就分配空间，对象还没创建时就已经分配了空间。</li><li>静态数据成员不属于某个对象，在为对象分配空间中不包括静态成员所占空间。</li><li><font color=red>静态成员变量必须在类中声明，类外定义。</font></li><li>静态成员变量也有权限。</li></ul><h2 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h2><ul><li>静态成员函数可以在类内实现。</li><li>静态成员函数不可以访问普通的成员变量，可以访问静态成员变量</li><li>静态成员函数也有权限。</li><li>普通成员函数可以访问静态成员变量和静态成员函数。</li><li>静态成员函数不能是虚函数 。</li></ul><p><strong>为什么静态成员函数不能是虚函数：</strong></p><ul><li>静态成员函数不属于类中的任何一个对象和实例，属于类共有的函数，因此不能通过this指针访问，因为this指针指向的是每一个对象和实例，而虚函数的调用恰恰需要this指针。虚函数的类实例是通过this指针调用vptr指针，指向虚函数表，通过虚函数表找到需要调用的虚函数地址。this-&gt;vptr-&gt;vtabel-&gt;virtual 函数。</li></ul><h1 id="访问方式"><a href="#访问方式" class="headerlink" title="访问方式"></a>访问方式</h1><ul><li>通过对象访问</li><li>通过类名访问</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> m_Age; <span class="comment">// 类内声明</span></span><br><span class="line"><span class="keyword">int</span> m_A;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; m_A &lt;&lt; endl;  会报错，不能访问普通成员变量</span></span><br><span class="line">        cout &lt;&lt; m_other &lt;&lt; endl;  <span class="comment">// 可以访问静态成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_other;  <span class="comment">// 私有权限，类外不能访问，但是加上作用域可以在类外初始化</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Person::m_Age = <span class="number">10</span>;  <span class="comment">// 类外初始化</span></span><br><span class="line"><span class="keyword">int</span> Person::m_other = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Person p1;</span><br><span class="line">    Person p2;</span><br><span class="line">    p1.m_Age = <span class="number">20</span>;</span><br><span class="line">    p2.m_Age = <span class="number">30</span>;</span><br><span class="line">cout &lt;&lt; p1.m_Age &lt;&lt; endl;  <span class="comment">// 30</span></span><br><span class="line">    cout &lt;&lt; p2.m_Age &lt;&lt; endl;  <span class="comment">// 30</span></span><br><span class="line">cout &lt;&lt; Person::m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> static </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>explicit关键字</title>
      <link href="2022/01/12/explicit%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>2022/01/12/explicit%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<ul><li>在创建对象的时候会存在隐式类型转换，添加explicit关键字后不能进行隐式类型转换。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">MyClass p = <span class="number">10</span>;  <span class="comment">// 如果在类中添加了explicit关键字，这行报错，不能进行隐式类型转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> explicit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象的构造和析构</title>
      <link href="2022/01/12/%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84/"/>
      <url>2022/01/12/%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h1><ul><li>构造函数：没有返回值，没有void，类名相同，可以发生重载，可以有参数。</li><li>析构函数：没有返回值，没有void，函数名称：~类名，不可以重载，不可以有参数。</li><li>系统会默认调用构造函数和析构函数且只调用一次。</li><li>若程序员不提供构造和析构函数，系统默认提供空实现。</li><li>构造和析构必须写在public下才可以调用到。</li></ul><h1 id="构造函数的分类和调用"><a href="#构造函数的分类和调用" class="headerlink" title="构造函数的分类和调用"></a>构造函数的分类和调用</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li>按参数分类<ul><li>无参构造函数（默认构造函数，调用默认构造函数创建对象时不加“()”，Person p1() 会被认成函数声明）</li><li>有参构造函数</li></ul></li><li>按类型分类<ul><li>普通构造函数</li><li>拷贝构造函数（注意浅拷贝问题，参数要加const）</li></ul></li></ul><h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Person p1;      <span class="comment">// 默认构造</span></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">1</span>)</span></span>;   <span class="comment">// 有参构造</span></span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(p1)</span></span>;    <span class="comment">// 拷贝构造</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="number">100</span>);    <span class="comment">// 匿名对象，如果编译器发现匿名对象，那么在这行代码结束后就释放这个对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式法调用</span></span><br><span class="line">Person p4 = <span class="built_in">Person</span>(<span class="number">100</span>);</span><br><span class="line">Person p5 = <span class="built_in">Person</span>(p4);</span><br><span class="line"><span class="comment">// 不能用拷贝构造函数初始化匿名对象</span></span><br><span class="line"><span class="built_in">Person</span>(p5);    <span class="comment">// 如果这么写，编译器会认为成 Person p5； 对象的声明，但是可以写成右值</span></span><br><span class="line">Person p6 = <span class="built_in">Person</span>(p5);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式类型转换</span></span><br><span class="line">Person p7 = <span class="number">100</span>;  <span class="comment">// 相当于调用Person p7 = Person(100);</span></span><br><span class="line">Person p8 = p7;</span><br></pre></td></tr></table></figure><h1 id="拷贝构造函数的调用时机"><a href="#拷贝构造函数的调用时机" class="headerlink" title="拷贝构造函数的调用时机"></a>拷贝构造函数的调用时机</h1><ul><li>用已经创建好的对象来初始化新对象。</li><li>以值传递方式给函数参数传值。</li><li>以值方式返回局部对象。</li></ul><h1 id="构造函数的调用规则"><a href="#构造函数的调用规则" class="headerlink" title="构造函数的调用规则"></a>构造函数的调用规则</h1><ul><li><p>系统默认提供三个函数：默认构造函数、拷贝构造函数和析构函数。 其实四个，还有个operator=赋值运算符进行简单值传递。</p></li><li><p>当提供了有参的构造函数，那么系统不会给我们提供默认构造函数，仍提供默认的拷贝构造函数，进行简单的值拷贝。</p></li><li><p>当提供了拷贝构造函数，那么系统不会提供其他构造函数。</p></li></ul><h1 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h1><ul><li>深拷贝：拷贝后，新对象和旧对象中的数据占用了不用的存储空间，也就是既拷贝了栈中的内容也拷贝了堆中的内容，就是深拷贝。</li><li>浅拷贝：拷贝后，新对象和就对象中的部分数据占用了相同的存储空间，即只拷贝了栈数据，堆数据没有重新申请内存，就是浅拷贝。</li><li>总的来说就是看是否发生了资源重新分配。</li><li>像类中的默认拷贝构造和赋值构造函数都是浅拷贝。</li><li>浅拷贝危害：如果两个对象指向同一内存空间，当其中的一个对象删除后，该内存空间释放，那么另一个对象指向的就是垃圾内存，形成了野指针。</li></ul><h1 id="构造函数和析构函数的调用顺序（在类对象作为成员时）"><a href="#构造函数和析构函数的调用顺序（在类对象作为成员时）" class="headerlink" title="构造函数和析构函数的调用顺序（在类对象作为成员时）"></a>构造函数和析构函数的调用顺序（在类对象作为成员时）</h1><ul><li>首先对类内的类成员对象进行构造，然后在调用类的构造函数</li><li>析构的顺序正好和构造顺序相反</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">class <span class="title">Phone</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Phone</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Phone构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Phone</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Phone析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"><span class="function">class <span class="title">Game</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Game</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Game构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Game</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Game析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"><span class="function">class <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Person</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Person析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Phone phone;</span><br><span class="line">    Game game;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://s2.loli.net/2022/01/12/U6bW2kl7AvKzRyt.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 构造 </tag>
            
            <tag> 析构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++封装</title>
      <link href="2022/01/11/C++%E5%B0%81%E8%A3%85/"/>
      <url>2022/01/11/C++%E5%B0%81%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><ul><li>把变量（属性）和函数（操作）合成一个整体，封装在一个类中。</li><li>成员变量和成员函数是分开存储的。</li><li>对变量和函数进行访问控制。</li><li>空类大小为1。 </li><li>只有非静态成员变量属于对象。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="comment">// 注释为加了该行后类的大小。</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_A;         <span class="comment">// 非静态成员变量，属于对象，   大小为4</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;;  <span class="comment">// 非静态成员函数，不属于对象， 大小为4   是通过this指针区分不同对象调用</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_B;  <span class="comment">// 静态成员变量，不属于对象，   大小为4</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;&#125;; <span class="comment">// 静态成员函数，不属于对象 大小4</span></span><br><span class="line">    <span class="keyword">double</span> m_C;      <span class="comment">// 12 错误  大小为16， double占8，但是因为字节对齐，int占4个补齐8个</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="class和struct"><a href="#class和struct" class="headerlink" title="class和struct"></a>class和struct</h1><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul><li><p>struct和class其实一样，区别是默认权限不同，struct默认public，class默认private。</p></li><li><p>class可以使用模板，struct不可以。</p></li></ul><h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><ul><li>private：私有权限，类内可以访问，类外不可访问，子类也不可访问。</li><li>public：共有权限，类内外都可以访问。</li><li>protected：保护权限，类内可访问，当前类的子类可以访问，类外不可访问。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 封装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四旋翼建模</title>
      <link href="2021/11/30/%E5%9B%9B%E6%97%8B%E7%BF%BC%E5%BB%BA%E6%A8%A1/"/>
      <url>2021/11/30/%E5%9B%9B%E6%97%8B%E7%BF%BC%E5%BB%BA%E6%A8%A1/</url>
      
        <content type="html"><![CDATA[<p><font color=red><em><strong>以下内容源于知乎，参考链接如下</strong></em></font></p><p><a href="https://zhuanlan.zhihu.com/p/332625724">https://zhuanlan.zhihu.com/p/332625724</a></p><p>先给出四旋翼建模和底层飞控的整体结构图：</p><p><img src="https://pic2.zhimg.com/80/v2-b0c8a97ed2d7865cab0865dd9fd80e29_1440w.png" alt="img"></p><p>上层控制器给出底层的控制指令，例如轨迹规划、协同控制算法等都算是上层控制器。</p><h2 id="1-坐标系"><a href="#1-坐标系" class="headerlink" title="1. 坐标系"></a><strong>1. 坐标系</strong></h2><h2 id="1-1-坐标系定义"><a href="#1-1-坐标系定义" class="headerlink" title="1.1 坐标系定义"></a><strong>1.1 坐标系定义</strong></h2><p>坐标系定义是最基础的前提，因为所有的公式变量都是以坐标系为前提的。</p><p>对于四旋翼模型来说，需要两个坐标系：</p><ul><li>全局坐标系/大地坐标系/惯性坐标系，符号表示： <img src="https://www.zhihu.com/equation?tex=%5CSigma%5E%5Cmathrm%7Bg%7D" alt="[公式]">  - （NED北东地)</li><li>机体坐标系，符号表示： <img src="https://www.zhihu.com/equation?tex=%5CSigma%5E%5Cmathrm%7Bb%7D" alt="[公式]">   - （前右下)</li></ul><p>全局坐标系是固连在大地上的；机体坐标系是固连到四旋翼机体上的，所以如果有很多个四旋翼，也就有很多个机体坐标系。</p><p>全局坐标系的原点一般来说是定义在飞机起飞点附近，在近距离的飞行时，可以忽略地球的曲率。机体坐标系的原点定义是飞机的重心位置。</p><p>全局坐标系的x,y,z轴的正方向分别是北东地（NED），所以无人机向上飞，其z轴坐标是负数。</p><p>机体坐标系的 x,y,z 轴的正方向分别是前右下，也就是飞机的正前方是x轴的正方向。</p><p>按照以上定义，如果全局坐标系的原点设在起飞点，无人机起飞前的初始位置的摆放是正前方对应北向，那么初始时，这两个坐标系是重合的。</p><h2 id="1-2-坐标变换"><a href="#1-2-坐标变换" class="headerlink" title="1.2 坐标变换"></a><strong>1.2 坐标变换</strong></h2><p>首先定义3个旋转矩阵：</p><p><img src="https://s2.loli.net/2022/01/10/72nOzGvLXJqNhoy.png" alt="旋转矩阵.png"></p><p>分别是绕x,y,z轴旋转 <img src="https://www.zhihu.com/equation?tex=%5Ctheta" alt="[公式]"> 角的旋转矩阵。</p><ul><li><p>全局到机体坐标变换公式为：<img src="https://www.zhihu.com/equation?tex=P%5Eb=R%5E%7Bg2b%7D(P%5Eg-T_%7Bb%7D%5Eg)" alt="[公式]"></p><p>其中，</p></li><li><ul><li><img src="https://www.zhihu.com/equation?tex=P%5Eg" alt="[公式]"> 是全局坐标系下的点的坐标，</li><li><img src="https://www.zhihu.com/equation?tex=P%5Eb" alt="[公式]">  是同样的点在机体坐标系下的坐标；</li><li><img src="https://www.zhihu.com/equation?tex=R%5E%7Bg2b%7D=R_xR_yR_z" alt="[公式]"> </li><li>飞机角度为， <img src="https://www.zhihu.com/equation?tex=%5Ctheta_x=roll,+%5Ctheta_y=pitch,%5Ctheta_z=yaw" alt="[公式]"> </li><li><img src="https://www.zhihu.com/equation?tex=T_b%5Eg" alt="[公式]"> 为飞机全局坐标系下的位置。</li></ul></li><li><p>机体到全局坐标变换公式为： <img src="https://www.zhihu.com/equation?tex=P%5Eg=R%5E%7Bb2g%7DP%5Eb+T_b%5Eg" alt="[公式]"></p></li><li><ul><li>其中， <img src="https://www.zhihu.com/equation?tex=R%5E%7Bb2g%7D=(R%5E%7Bg2b%7D)%5E%7B-1%7D=R_zR_yR_x" alt="[公式]"> </li><li>飞机角度为 <img src="https://www.zhihu.com/equation?tex=%5Ctheta_x=-roll,+%5Ctheta_y=-pitch,%5Ctheta_z=-yaw" alt="[公式]"></li></ul></li></ul><p>坐标变换有两种变换方法：先平移后旋转；先旋转后平移。</p><p>上面全局到机体的变换是先平移后旋转的方式，而机体到全局的变换是先旋转后平移的方式。两种方式都可以。</p><p>注意上面的变换中，从全局到机体和从机体到全局的变换是互逆的，两个旋转矩阵也是互逆的。但是如果两种变换都是用同样的方式（比如先旋转后平移），那么两个旋转矩阵就不是互逆的了。</p><h2 id="1-3-坐标变换的通俗解释"><a href="#1-3-坐标变换的通俗解释" class="headerlink" title="1.3 坐标变换的通俗解释"></a><strong>1.3 坐标变换的通俗解释</strong></h2><p>这一节是一个非常通俗的坐标变换的解释，对坐标变换比较熟悉的读者就不需要看了。</p><p>可能刚开始接触坐标系转换的同学对各种旋转矩阵搞得很头疼，其实只要搞明白源头，搞明白为什么要进行坐标系变换，搞明白坐标系变换的本质，就不难理解了。</p><p>其实说白了，<strong>坐标系变换就是用不同的方式来表示同一个点</strong>。让我们首先通俗的讲一下这个事情，我想表示二维平面中某一个点，这时我可以用手指或者画一个箭头指向这个点，那你就知道了我想表达的这个点了。但是如果有很多点怎么办，我如果对每一个点都画个箭头，那么就太乱了，这时，坐标系就出现了。我可以首先建立一个坐标，确定了原点所在的位置和两个轴的方向，然后我把这个坐标系告诉你，这样咱俩都知道了同一个坐标系，以后再相互表达某些点的时候，只需要讲这些点的坐标就可以了，你可以根据坐标，在提前商量好的坐标系中快速地找到这些点。但是，如果你和我都有自己喜欢的坐标系，而且这两个坐标系不一样，不是同一个坐标系，那么我将某个点的坐标告诉你，你在你喜欢的坐标系上是无法准确找到这个点的，这时就需要坐标变换了。所以<strong>坐标变换就是用不同的坐标系去表达同一个点</strong>。</p><h2 id="2-四旋翼建模"><a href="#2-四旋翼建模" class="headerlink" title="2. 四旋翼建模"></a><strong>2. 四旋翼建模</strong></h2><h2 id="2-1-四旋翼的状态量"><a href="#2-1-四旋翼的状态量" class="headerlink" title="2.1 四旋翼的状态量"></a><strong>2.1 四旋翼的状态量</strong></h2><p>首先我们使用到的四旋翼的状态量有18个量：</p><ul><li>位置（全局坐标系）： <img src="https://www.zhihu.com/equation?tex=%5Cbold%7Bp%7D%5E%5Cmathrm%7Bg%7D=%5Bx,y,z%5D%5ET" alt="[公式]"> </li><li>速度（全局坐标系）： <img src="https://www.zhihu.com/equation?tex=%5Cbold%7Bv%7D%5E%5Cmathrm%7Bg%7D+=+%5Bv_x,v_y,v_z%5D%5ET" alt="[公式]"></li><li>加速度（全局坐标系）： <img src="https://www.zhihu.com/equation?tex=%5Cbold%7Ba%7D%5E%5Cmathrm%7Bg%7D=%5Ba_x,a_y,a_z%5D%5ET" alt="[公式]"> </li><li>姿态角： <img src="https://www.zhihu.com/equation?tex=%5CTheta+=%5B%5Cphi,%5Ctheta,%5Cpsi%5D%5ET" alt="[公式]"> , (roll, pitch, yaw)</li><li>机体旋转角速度： <img src="https://www.zhihu.com/equation?tex=%5Cbold%7B%5Comega%7D%5Eb=%5Bp,q,r%5D%5ET" alt="[公式]"> </li><li>机体旋转角加速度： <img src="https://www.zhihu.com/equation?tex=%5Cbold%7B%5Cdot%7B%5Comega%7D%7D%5Eb=%5B%5Cdot%7Bp%7D,%5Cdot%7Bq%7D,%5Cdot%7Br%7D%5D%5ET" alt="[公式]"> </li></ul><p>其中姿态角是机体坐标系相对于全局坐标系的三个欧拉角，机体角速度和机体角加速度都是机体坐标系下的。</p><h2 id="2-2-四旋翼6自由度模型-动力学模型与运动学模型"><a href="#2-2-四旋翼6自由度模型-动力学模型与运动学模型" class="headerlink" title="2.2 四旋翼6自由度模型 - 动力学模型与运动学模型"></a><strong>2.2 四旋翼6自由度模型 - 动力学模型与运动学模型</strong></h2><p>四旋翼非线性建模分为运动学模型和动力学模型两部分。6自由度模型的意思是四旋翼有6个自由度，分别是3个方向的移动和3个方向的转动。下面将6自由度模型的公式罗列出来，本文不进行细节方面详细的讲解，只讲明白怎么使用。</p><ul><li>运动学模型</li></ul><p><img src="https://s2.loli.net/2022/02/22/75BdQeb2DAxTisF.png" alt="image.png"></p><ul><li>动力学模型</li></ul><p><img src="https://s2.loli.net/2022/02/22/UhOFkGaCST2Xxdn.png" alt="image.png"></p><ul><li><p>其中符号的解释：</p><p>$$<br>p^g 和v^g 分别是飞机的全局位置和全局速度；<br>W是表示姿态角速率与机体角速度之间关系的矩阵；<br>$$</p><p><img src="https://s2.loli.net/2022/02/22/2KdeagCY8kDPrpo.png" alt="image.png"></p></li></ul><p>应避免 cosθ=0 ​的情况发生。<br>反过来可以得到：​ <img src="https://www.zhihu.com/equation?tex=%5Cbold%7B%5Comega%7D%5Eb=%5Cbold%7BW%7D%5E%7B-1%7D%5Cdot%7B%5CTheta%7D" alt="[公式]"><br>$$<br>θ是姿态角速率，w^b 是机体角速度<br>$$</p><p>$$<br>e^3 = [0,0,1]^T 表示单位列向量；<br>$$</p><p>$$<br>f是四个电机的拉力总和，方向沿机体坐标系z轴负方向；<br>$$</p><p>$$<br>J是四旋翼的惯性矩阵，J=diag(J_x,J_y,J_z)<br>$$</p><p>$$<br>G_a表示陀螺力矩，一般忽略不计；<br>$$</p><p>$$<br>\tau=[\tau_x,\tau_y,\tau_z]表示螺旋桨在机体轴上产生的外力矩。<br>$$</p><h2 id="2-3-四旋翼6自由度模型的使用"><a href="#2-3-四旋翼6自由度模型的使用" class="headerlink" title="2.3 四旋翼6自由度模型的使用"></a><strong>2.3 四旋翼6自由度模型的使用</strong></h2><p>有了6自由度模型，输入飞机的整体拉力（ f ）和3个方向的力矩（ τ ），再f加上上一时刻四旋翼的状态，就可以计算出下一时刻四旋翼的状态量（位置、速度、加速度、姿态角、机体角速率、机体角加速度)。</p><p>从写代码的计算过程来看，先使用动力学模型两个公式，输入拉力和力矩（ f , τ  ），计算飞机的加速度（ v’ ）和角加速度(ω’^b)，然后再使用运动学模型的两个公式，更新其他状态量。</p><h2 id="2-4-四旋翼电机模型"><a href="#2-4-四旋翼电机模型" class="headerlink" title="2.4 四旋翼电机模型"></a><strong>2.4 四旋翼电机模型</strong></h2><p>电机模型是用来对电机建模的，因为电机的响应非常快，所以可以忽略电机的延迟，等效认为对电机的转速指令能够瞬间达到。</p><p>四旋翼分为X型和十字型，分析过程相似，本文使用X型四旋翼来推导，</p><ul><li>四个电机的id号定义如下：(向上为前进方向)</li></ul><p><img src="https://pic2.zhimg.com/80/v2-1e5ef3aa664fe35bcddcbbff2e27a45d_1440w.jpg" alt="img"></p><ul><li><p>力、力矩与电机转速的转换如下：</p><p> <img src="https://s2.loli.net/2022/02/22/29pPwJF5frOHykY.png" alt="image.png"></p></li></ul><p>其中， l 为机体中心到任一电机的距离， Cτ 为拉力系数， C_M 为扭矩系数。    </p><h2 id="3-四旋翼底层飞控"><a href="#3-四旋翼底层飞控" class="headerlink" title="3. 四旋翼底层飞控"></a><strong>3. 四旋翼底层飞控</strong></h2><h2 id="3-1-四旋翼底层飞控结构图"><a href="#3-1-四旋翼底层飞控结构图" class="headerlink" title="3.1 四旋翼底层飞控结构图"></a><strong>3.1 四旋翼底层飞控结构图</strong></h2><p>一般四旋翼的底层飞控都是用PID控制器，我这里在内环姿态回路用了LQR控制器，底层控制器整体结构图如下：</p><p><img src="https://pic2.zhimg.com/80/v2-66e3d3bea01271615f2e0c07bd21ab25_1440w.jpg" alt="img"></p><h2 id="3-2-简化的线性模型"><a href="#3-2-简化的线性模型" class="headerlink" title="3.2 简化的线性模型"></a><strong>3.2 简化的线性模型</strong></h2><p>在设计控制器之前，首先要对6自由度非线性模型进行线性化，这样设计出来控制器以后，可以先用线性化的模型计算控制器的收敛性，以此判断控制设计的好不好。最后再用设计好的控制器去控制非线性模型。</p><ul><li><p>假设条件：</p></li><li><ul><li><p>动力学模型忽略 <img src="https://www.zhihu.com/equation?tex=-%5Cbold%7B%5Comega%7D%5Eb%5Ctimes(%5Cbold%7BJ%7D%5Ccdot%5Cbold%7B%5Comega%7D%5Eb)+%5Cbold%7BG%7D_a" alt="[公式]"> </p></li><li><p>俯仰角和滚转角都非常小：</p></li><li><ul><li> <img src="https://www.zhihu.com/equation?tex=%5Csin(%5Cphi)%5Capprox+%5Cphi" alt="[公式]"></li><li> <img src="https://www.zhihu.com/equation?tex=%5Ccos(%5Cphi)%5Capprox+1" alt="[公式]"></li><li> <img src="https://www.zhihu.com/equation?tex=%5Csin(%5Ctheta)%5Capprox+%5Ctheta" alt="[公式]"></li><li> <img src="https://www.zhihu.com/equation?tex=%5Ccos(%5Ctheta)%5Capprox+1" alt="[公式]"></li></ul></li><li><p>总拉力约等于四旋翼的重力： <img src="https://www.zhihu.com/equation?tex=f%5Capprox+mg" alt="[公式]"></p></li><li><p>此时，运动学模型中的 <img src="https://www.zhihu.com/equation?tex=%5Cbold%7BW%7D%5Capprox%5Cbold%7BI%7D_3" alt="[公式]"></p></li><li><p>此时，动力学模型中的 <img src="https://www.zhihu.com/equation?tex=%5Cbold%7BR%7D%5E%7Bb2g%7D%5Cbold%7Be%7D_3%5Capprox+%5Cleft%5B%5Cbegin%7Bmatrix%7D+%5Ctheta%5Ccos%5Cpsi+%5Cphi%5Csin%5Cpsi+%5C%5C+%5Ctheta%5Csin%5Cpsi-%5Cphi%5Ccos%5Cpsi+%5C%5C+1+%5Cend%7Bmatrix%7D%5Cright%5D" alt="[公式]"></p></li></ul></li></ul><p>最终，忽略高阶项，原始模型解耦为三个线性模型：水平位置通道模型、高度通道模型、姿态模型</p><ul><li><p>水平位置通道模型： <img src="https://s2.loli.net/2022/02/22/JIEMSCgb46ZY7fA.png" alt="image.png"></p><p>其中，     <img src="https://s2.loli.net/2022/02/22/MdJD4T1IXFOuV8x.png" alt="image.png"> </p></li><li><p>高度通道模型： <img src="https://s2.loli.net/2022/02/22/Ln92yV6XBsmFA7k.png" alt="image.png"></p></li><li><p>姿态模型： <img src="https://s2.loli.net/2022/02/22/yGmuEPFZJRWv5L3.png" alt="image.png"></p></li></ul><h2 id="3-3-外环PID控制器"><a href="#3-3-外环PID控制器" class="headerlink" title="3.3 外环PID控制器"></a><strong>3.3 外环PID控制器</strong></h2><p>外环PID分为水平和垂直两个解耦的控制器。</p><p><strong>外环水平通道PID控制器</strong></p><p>外环水平通道控制器有三种情况：输入指令可以是，位置、速度、加速度。</p><ul><li><p>输入：期望水平方向的指令（三选一）位置、速度、加速度， <img src="https://www.zhihu.com/equation?tex=(p_h)_%7Bcmd%7D=%5Bx_%7Bcmd%7D,y_%7Bcmd%7D%5D%5ET" alt="[公式]"> <img src="https://www.zhihu.com/equation?tex=(%5Cbold%7Bv%7D_h)_%7Bcmd%7D=%5B(v_x)_%7Bcmd%7D,(v_y)_%7Bcmd%7D%5D%5ET" alt="[公式]"> , <img src="https://www.zhihu.com/equation?tex=(a_h)_%7Bcmd%7D=%5B(a_x)_%7Bcmd%7D,(a_y)_%7Bcmd%7D%5D%5ET" alt="[公式]"> </p></li><li><p>输出（给内环）：期望俯仰和滚转姿态角 <img src="https://www.zhihu.com/equation?tex=%5Cphi_%7Bdes%7D,%5Ctheta_%7Bdes%7D" alt="[公式]"> </p></li><li><p>控制器设计：</p></li><li><ul><li><p>位置控制：</p></li><li><ul><li><img src="https://www.zhihu.com/equation?tex=(%5Cbold%7Bv%7D_h)_%7Bdes%7D=%5Cbold%7BK%7D_%7Bp_h%7D%5Cleft((%5Cbold%7Bp%7D_h)_%7Bcmd%7D-%5Cbold%7Bp%7D_h%5Cright)" alt="[公式]"> , P控制器， 其中 <img src="https://www.zhihu.com/equation?tex=(%5Cbold%7Bv%7D_h)_%7Bdes%7D" alt="[公式]"> 要限幅</li><li><img src="https://www.zhihu.com/equation?tex=(%5Cbold%7Ba%7D_h)_%7Bdes%7D=(%5Cbold%7BK%7D_%7B%5Cbold%7Bv%7D_hp%7D%5Cbold%7Be%7D_%7B%5Cbold%7Bv%7D_h%7D+%5Cbold%7BK%7D_%7B%5Cbold%7Bv%7D_hi%7D%5Cint%5Cbold%7Be%7D_%7B%5Cbold%7Bv%7D_h%7D+%5Cbold%7BK%7D_%7B%5Cbold%7Bv%7D_hd%7D%5Cdot%7B%5Cbold%7Be%7D%7D_%7B%5Cbold%7Bv%7D_h%7D)" alt="[公式]"> , PID控制器，一般用PI即可，其中 <img src="https://www.zhihu.com/equation?tex=(%5Cbold%7Ba%7D_h)_%7Bdes%7D" alt="[公式]"> 要限幅</li><li><img src="https://www.zhihu.com/equation?tex=(%5Cbold%7B%5CTheta%7D_h)_%7Bdes%7D=g%5E%7B-1%7D%5Cbold%7BA%7D_%5Cpsi%5E%7B-1%7D(-%5Cbold%7Ba%7D_h)_%7Bdes%7D" alt="[公式]"> , 其中 <img src="https://www.zhihu.com/equation?tex=(%5Cbold%7B%5CTheta%7D_h)_%7Bdes%7D" alt="[公式]"> 要限幅。</li><li>其中 <img src="https://www.zhihu.com/equation?tex=%5Cbold%7BK%7D_%7Bp_h%7D,%5Cbold%7BK%7D_%7B%5Cbold%7Bv%7D_hp%7D,%5Cbold%7BK%7D_%7B%5Cbold%7Bv%7D_hi%7D,%5Cbold%7BK%7D_%7B%5Cbold%7Bv%7D_hd%7D%5Cin+R%5E%7B2%5Ctimes2%7D" alt="[公式]"> 是系数;<img src="https://www.zhihu.com/equation?tex=%5Cbold%7Be%7D_%7B%5Cbold%7Bv%7D_h%7D=(%5Cbold%7Bv%7D_h)_%7Bdes%7D-%5Cbold%7Bv%7D_h" alt="[公式]"></li></ul></li><li><p>速度控制：</p></li><li><ul><li><img src="https://www.zhihu.com/equation?tex=+(%5Cbold%7Ba%7D_h)_%7Bdes%7D=(%5Cbold%7BK%7D_%7B%5Cbold%7Bv%7D_hp%7D%5Cbold%7Be%7D_%7B%5Cbold%7Bv%7D_h%7D+%5Cbold%7BK%7D_%7B%5Cbold%7Bv%7D_hi%7D%5Cint%5Cbold%7Be%7D_%7B%5Cbold%7Bv%7D_h%7D+%5Cbold%7BK%7D_%7B%5Cbold%7Bv%7D_hd%7D%5Cdot%7B%5Cbold%7Be%7D%7D_%7B%5Cbold%7Bv%7D_h%7D)" alt="[公式]"> , PID控制器，一般用PI即可，其中 <img src="https://www.zhihu.com/equation?tex=(%5Cbold%7Ba%7D_h)_%7Bdes%7D" alt="[公式]"> 要限幅</li><li><img src="https://www.zhihu.com/equation?tex=(%5Cbold%7B%5CTheta%7D_h)_%7Bdes%7D=-g%5E%7B-1%7D%5Cbold%7BA%7D_%5Cpsi%5E%7B-1%7D(%5Cbold%7Ba%7D_h)_%7Bdes%7D" alt="[公式]"> , 其中 <img src="https://www.zhihu.com/equation?tex=(%5Cbold%7B%5CTheta%7D_h)_%7Bdes%7D" alt="[公式]"> 要限幅。</li><li>其中， <img src="https://www.zhihu.com/equation?tex=%5Cbold%7BK%7D_%7B%5Cbold%7Bv%7D_hp%7D,%5Cbold%7BK%7D_%7B%5Cbold%7Bv%7D_hi%7D,%5Cbold%7BK%7D_%7B%5Cbold%7Bv%7D_hd%7D%5Cin+R%5E%7B2%5Ctimes2%7D" alt="[公式]"> 是系数; <img src="https://www.zhihu.com/equation?tex=%5Cbold%7Be%7D_%7B%5Cbold%7Bv%7D_h%7D=(%5Cbold%7Bv%7D_h)_%7Bcmd%7D-%5Cbold%7Bv%7D_h" alt="[公式]"> </li></ul></li><li><p>加速度控制：</p></li><li><ul><li><img src="https://www.zhihu.com/equation?tex=(%5Cbold%7B%5CTheta%7D_h)_%7Bdes%7D=-g%5E%7B-1%7D%5Cbold%7BA%7D_%5Cpsi%5E%7B-1%7D(%5Cbold%7Ba%7D_h)_%7Bcmd%7D" alt="[公式]"> , 其中 <img src="https://www.zhihu.com/equation?tex=(%5Cbold%7B%5CTheta%7D_h)_%7Bdes%7D" alt="[公式]"> 要限幅。</li></ul></li></ul></li><li><p>限幅：</p></li><li><ul><li>输入限幅： <img src="https://www.zhihu.com/equation?tex=%7C%7C(%5Cbold%7Bv%7D_h)_%7Bdes%7D%7C%7C%5Cle+%5Cmax+v_h" alt="[公式]"> </li><li>输出限幅： <img src="https://www.zhihu.com/equation?tex=%5Cphi_%7Bdes%7D,%5Ctheta_%7Bdes%7D%5Cle+%5Cmax+%5Ctheta" alt="[公式]"> </li></ul></li></ul><p><strong>外环高度通道PID控制器</strong></p><ul><li><p>输入：期望高度 <img src="https://www.zhihu.com/equation?tex=z_%7Bdes%7D" alt="[公式]"> </p></li><li><p>输出：拉力 <img src="https://www.zhihu.com/equation?tex=f_%7Bdes%7D" alt="[公式]"> </p></li><li><p>控制器设计： <img src="https://www.zhihu.com/equation?tex=f_%7Bdes%7D=m(g+k_%7Bv_zp%7De_%7Bv_z%7D+k_%7Bv_zi%7D%5Cint+e_%7Bv_z%7D)" alt="[公式]"></p><p>其中， ![[公式]](<a href="https://www.zhihu.com/equation?tex=k_%7Bv_zp%7Dk_%7Bv_zi%7D">https://www.zhihu.com/equation?tex=k_%7Bv_zp%7Dk_%7Bv_zi%7D</a> 是系数)   <img src="https://www.zhihu.com/equation?tex=e_%7Bv_z%7D=v_z-(v_z)_%7Bdes%7D%E6%98%AF%E9%80%9F%E5%BA%A6%E5%B7%AE" alt="[公式]"><br>其中， <img src="https://www.zhihu.com/equation?tex=(v_z)_%7Bdes%7D=-k_z(z-z_%7Bdes%7D)" alt="[公式]"> </p></li><li><p>限幅： <img src="https://www.zhihu.com/equation?tex=(v_z)_%7Bdes%7D%5Cle%5Cmax+z_v" alt="[公式]"> <img src="https://www.zhihu.com/equation?tex=f_%7Bdes%7D%5Cle%5Cmax+f" alt="[公式]"> </p></li></ul><h2 id="3-4-内环LQR控制器"><a href="#3-4-内环LQR控制器" class="headerlink" title="3.4 内环LQR控制器"></a><strong>3.4 内环LQR控制器</strong></h2><p><strong>输入输出</strong></p><ul><li>输入1（外环）：期望的俯仰滚转角， <img src="https://www.zhihu.com/equation?tex=%5Cphi_%7Bdes%7D,%5Ctheta_%7Bdes%7D" alt="[公式]"> </li><li>输入2：期望的偏航角 <img src="https://www.zhihu.com/equation?tex=%5Cpsi_%7Bdes%7D" alt="[公式]"> </li><li>输出：力矩， <img src="https://www.zhihu.com/equation?tex=%5Cbold%7B%5Ctau%7D_%7Bdes%7D" alt="[公式]"> </li></ul><p><strong>控制器设计</strong></p><ul><li><p>状态方程：</p><p><img src="https://s2.loli.net/2022/02/22/atgihfRAVu7x5Pe.png" alt="image.png"><br><img src="https://www.zhihu.com/equation?tex=%5Cdot%7Bx%7D=Ax+Bu" alt="[公式]"></p></li><li><p>其中， <img src="https://www.zhihu.com/equation?tex=x=%5B%5Cphi,%5Ctheta,%5Cpsi,p,q,r%5D%5ET" alt="[公式]"> </p><p><img src="https://www.zhihu.com/equation?tex=u=%5B%5Ctau_x,%5Ctau_y,%5Ctau_z%5D%5ET" alt="[公式]"> </p><p><img src="https://s2.loli.net/2022/02/22/8A1pEbxilICcTFe.png" alt="image.png"> </p><p><img src="https://www.zhihu.com/equation?tex=B=%5Cleft%5B%5Cbegin%7Bmatrix%7D%5Cbold%7B0%7D%5C%5C+%5Cbold%7BJ%7D%5E%7B-1%7D%5Cend%7Bmatrix%7D%5Cright%5D" alt="[公式]"></p></li><li><p>两个矩阵的参数选择： <img src="https://www.zhihu.com/equation?tex=Q=diag%5C%7B8,8,2,+2,+2,+0.1%5C%7D" alt="[公式]"> , <img src="https://www.zhihu.com/equation?tex=R=diag%5C%7B1,1,1%5C%7D" alt="[公式]"> </p></li><li><p>求中间矩阵 <img src="https://www.zhihu.com/equation?tex=P" alt="[公式]"> ，解方程： <img src="https://www.zhihu.com/equation?tex=A%5ETP+PA+Q-PBR%5E%7B-1%7DB%5ETP=0" alt="[公式]"> </p></li><li><p>解出系数矩阵 <img src="https://www.zhihu.com/equation?tex=K" alt="[公式]"> :  <img src="https://www.zhihu.com/equation?tex=K=R%5E%7B-1%7DB%5ETP" alt="[公式]"> </p></li><li><p>最后的解为：<br><img src="https://www.zhihu.com/equation?tex=%5Cbold%7B%5Ctau%7D_%7Bdes%7D=-K(x-x_%7Bdes%7D)" alt="[公式]"></p></li><li><p>限幅： <img src="https://www.zhihu.com/equation?tex=%5Cphi_%7Bdes%7D,%5Ctheta_%7Bdes%7D+%5Cle+%5Cmax%5Ctheta" alt="[公式]"> ,  <img src="https://www.zhihu.com/equation?tex=%5Ctau_%7Bdes%7D%5Cle+%5Cmax+%5Ctau" alt="[公式]"></p></li></ul><h2 id="4-四旋翼参数参考"><a href="#4-四旋翼参数参考" class="headerlink" title="4. 四旋翼参数参考"></a><strong>4. 四旋翼参数参考</strong></h2><p>下面列举的参数是我再仿真中用的参数，可以用来参考。</p><ul><li>参考3dr Robotics</li></ul><table><thead><tr><th>参数</th><th>数据 值/范围</th></tr></thead><tbody><tr><td>质量（kg）</td><td>1.4</td></tr><tr><td>轴距 (m)</td><td>0.56</td></tr><tr><td>转动惯量 (x,y,z) (kg/m^2)</td><td>[0.05,0.05,0.24]</td></tr><tr><td>滚转和俯仰角</td><td>-30 ~ 30</td></tr><tr><td>拉力 (N)</td><td>0 ~ 43.5</td></tr><tr><td>力矩 (x,y) (N.m)</td><td>-6.25 ~ 6.25</td></tr><tr><td>力矩 z</td><td>-2.25 ~ 2.25</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> UAV Simulation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UAV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>namespcae</title>
      <link href="2021/11/25/namespcae/"/>
      <url>2021/11/25/namespcae/</url>
      
        <content type="html"><![CDATA[<h1 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h1><ul><li>namespace用于解决命名冲突问题</li><li>namespace必须放在全局作用域下</li><li>命名空间下可以放变量、结构体、类、函数</li><li>命名空间可以嵌套命名空间</li><li>命名空间是开放的，可以随时往原来的命名空间添加内容</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A &#123;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> A &#123;  <span class="comment">// 此命名空间会和上面的命名空间合并</span></span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>无名/匿名命名空间相当与写了static，只能在当前文件内使用</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"><span class="keyword">int</span> m_A = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> m_B = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 相当于写了static int m_A; static int m_B;</span></span><br></pre></td></tr></table></figure><ul><li>命名空间可以起别名</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> veryLongName &#123;</span><br><span class="line">    <span class="keyword">int</span> m_A = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> test01 &#123;</span><br><span class="line"><span class="keyword">namespace</span> veryShortName = veryLongName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> namespace </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++面向对象</title>
      <link href="2021/11/25/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>2021/11/25/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p>面向对象编程的思想核心：功能分解，自上而下，逐层细化<font color=red>（程序=数据结构+算法）</font></p><h1 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h1><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>把客观事物封装成抽象的类。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>表达的是类之间的关系，对象可以继承另一个对象的特征和能力。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>一个接口，多种方法，程序在运行时才决定调用的方法。父类的指针或引用指向子类对象。</p><h1 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h1><ul><li><strong>面向过程：</strong>以事件为中心的编程思想，编程时把解决问题的步骤分析出来，然后用函数把这些步骤实现，在一步一步的具体步骤中按顺序调用函数。</li><li><strong>面向对象：</strong>把所有的事务看作对象，每个对象都有自己的属性和行为，对象和对象之间可以通过方法来交互，对象的抽象称为类。</li></ul><p><strong>什么是面向对象，介绍面向对象的三大特性，并且举例说明每一个。</strong></p><p>面向对象：对象是指具体的某一个事物，这些事物的抽象就是类，类中包含数据（成员变量）和动作（成员方法）。</p><p>封装：将具体的实现过程和数据封装成一个函数，只能通过接口进行访问，降低耦合性。<br>继承：子类继承父类的特征和行为，子类有父类的非private方法或成员变量，子类可以对父类的方法进行重写，增强了类之间的耦合性，但是当父类中的成员变量、成员函数或者类本身被final关键字修饰时，修饰的类不能继承，修饰的成员不能重写或修改。<br>多态：多态就是不同继承类的对象，对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现方式。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="2021/11/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>2021/11/24/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="设计模式七大原则"><a href="#设计模式七大原则" class="headerlink" title="设计模式七大原则"></a>设计模式七大原则</h1><ul><li>开闭原则：用抽象构建架构，用实现扩展细节。</li><li>依赖倒置原则：高层模块不应该依赖于底层模块，二者都应该依赖其抽象。</li><li>单一职责原则：单个接口或类不应该有多个职责，应该尽可能的划分职责，通过组合的方式，完成更为复杂的业务。</li><li>接口隔离原则：一个接口不要包含过多的职责，应合理划分，跟单一职责原则相辅相成。<ul><li>典型场景：动物、人、鸟，人和鸟都会吃，人会走路，鸟会飞，应该把走路和飞这两个行为抽象成接口，通过组合的方式让人拥有走路的行为，让鸟拥有飞的行为。再细划分，人有多个走路姿势，鸟有多个飞行方式，可以分别继承走路和飞的抽象行为扩展其具体的行为。</li></ul></li><li>迪米特法则：也就最少知道原则，一个对象尽量让其它对象保持最少的了解。<ul><li>典型场景：我点外卖，我只关心外卖员，不关系具体的店。我的类中只依赖外卖员，不会依赖具体的店。是不是静态代理。</li></ul></li><li>里氏替换原则：在引用父类的地方，都可以替换为其子类。从而可以实现子类间的动态切换。换句话说就是要有面向接口的编程思维。结合“开闭原则”，完美。</li><li>合成复用原则：多用组合，少用继承。</li></ul><h1 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h1><ul><li>创建型模式：在创建对象的同时隐藏创建逻辑，不用new直接实例化对象，避免new过程所导致的紧耦合（依赖具体类）。有工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</li><li>结构型模式：通过类和接口间的继承和引用实现创建复杂结构的对象。有适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</li><li>行为型模式：通过类之间不同通信方式实现不同行为。有策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</li></ul><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>​        单例模式是一种软件设计模式，在它的核心结构中只包含一个被称为单例的特殊类，单例模式可以保证系统中一个类只有一个实例且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。如果希望系统中某个类的对象只能存在一个，用单例模式。</p><h2 id="静态成员实现单例模式"><a href="#静态成员实现单例模式" class="headerlink" title="静态成员实现单例模式"></a>静态成员实现单例模式</h2><h3 id="饿汉式实现"><a href="#饿汉式实现" class="headerlink" title="饿汉式实现"></a>饿汉式实现</h3><ul><li>目的：为了让类中只有一个实例，实例不需要自己释放。</li><li>将默认构造和拷贝构造私有化。</li><li>内部维护一个对象指针。</li><li>私有化唯一指针。</li><li>对外提供getInstance方法来访问这个指针。</li><li>保证类中只能实例化唯一一个对象。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChairMan</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 构造函数进行私有化</span></span><br><span class="line">    <span class="built_in">ChairMan</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;creat ChairMan&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数也需要私有化</span></span><br><span class="line">    <span class="built_in">ChairMan</span>(<span class="keyword">const</span> ChairMan&amp;c)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> ChairMan * singleMan;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 提供get方法访问主席</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> ChairMan* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleMan;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ChairMan * ChairMan:;singleMan = <span class="keyword">new</span> ChairMan;  <span class="comment">// 静态变量编译阶段就创建</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ChairMan* cm1 = ChairMan::getInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果为：</span></span><br><span class="line"><span class="comment">// creat ChairMan</span></span><br><span class="line"><span class="comment">// main函数调用</span></span><br></pre></td></tr></table></figure><h3 id="懒汉式实现"><a href="#懒汉式实现" class="headerlink" title="懒汉式实现"></a>懒汉式实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">singleton</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="built_in">pthread_mutex_init</span>(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> singleton* p;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> singleton* <span class="title">initance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">pthread_mutex_t</span> singleton::mutex;</span><br><span class="line">singleton* singleton::p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="function">singleton* <span class="title">singleton::initance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line">            p = <span class="keyword">new</span> <span class="built_in">singleton</span>();</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>懒汉：在访问量较小时，采用懒汉实现。这是以时间换空间。（本身就是线程安全的）</p><p>饿汉：由于要进行线程同步，所以在访问量比较大，或者可能访问的线程比较多时，采用饿汉实现，可以实现更好的性能。这是以空间换时间。（注意，懒汉本身是线程不安全的）</p><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><ul><li>动机：在软件系统中，经常面临创建对象的工作，由于需求的变化，需要创建的对象的具体类型经常变化。</li><li>本质：并不是消除变化，而是把所有的变化集中到某个局部。</li><li>定义：定义一个用于创建对象接口的类，让子类决定实例化哪一个类，工厂模式使得一个类的实例化延迟到子类进行 （目的：解耦。手段：虚函数）。</li><li>缺点：要求创建方法/参数相同。</li></ul><p><img src="https://s2.loli.net/2022/03/23/GoOFhwCHEbPDzTZ.png" alt="QQ截图20220323155245.png"></p><h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><ul><li>动机：在软件系统中，经常面临“一系列相互依赖的对象”的创建工作，同时，由于需求的变化，往往存在更多系列对象的创建工作。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>inline函数</title>
      <link href="2021/11/24/%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"/>
      <url>2021/11/24/%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="内联函数的引出–宏函数的缺陷"><a href="#内联函数的引出–宏函数的缺陷" class="headerlink" title="内联函数的引出–宏函数的缺陷"></a>内联函数的引出–宏函数的缺陷</h1><ul><li><p>第一个问题在c中也会出现的，宏看起来像一个函数调用，但是有一些隐藏的难以发现的错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MyAdd(int a, int b) a+b</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">MyAdd</span>(a, b) &lt;&lt; endl;  <span class="comment">// 输出30；</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">MyAdd</span>(a, b) * <span class="number">10</span> &lt;&lt; endl;  <span class="comment">// 预期结果300，但是输出210； </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MyCompare(int a, int b) a &gt; b ? a : b</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">MyCompare</span>(a, b); <span class="comment">// 输出 20；</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">MyCompare</span>(++a, b); <span class="comment">// 预期21，输出22；</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>第二个问题是C++特有的，预处理器不能访问类的成员，所以预处理宏不能用作类的成员函数。</p></li><li><p>宏函数没有作用域。</p></li></ul><h1 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h1><ul><li>内联函数是一个真正的函数。</li><li>内联函数的声明和实现都需要加inline，否则会被认为成普通函数处理。</li><li>内联函数相当于空间换时间。</li><li>类内部的成员函数，默认前面会加inline关键字，即如果函数定义在类内部，自动成为内联函数<font color=blue>（同样受到最后一条的限制）</font>。</li><li>注意即使加了inline也不一定会变成内联函数，以下情况不会变成inline：<ul><li>不能存在任何形式的循环语句；</li><li>不能存在过多的条件判断语句；</li><li>函数体不能过于庞大；</li><li>不能对函数进行取址操作；</li></ul></li></ul><p><font color=red>内联函数只是相当于给了编译器一个建议，但是编译器不一定会接受。</font></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> inline </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="2021/11/13/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>2021/11/13/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>并查集主要用于解决一些<strong>元素分组</strong>的问题。它管理一系列<strong>不相交的集合</strong>，并支持两种操作：</p><ul><li><strong>合并</strong>（Union）：把两个不相交的集合合并为一个集合。</li><li><strong>查询</strong>（Find）：查询两个元素是否在同一个集合中。</li></ul><p>元素之间具有<strong>传递性</strong>的关系以及<strong>只考虑连通性</strong>不考虑距离时，可考虑使用并查集。</p><h1 id="并查集的简介与实现"><a href="#并查集的简介与实现" class="headerlink" title="并查集的简介与实现"></a>并查集的简介与实现</h1><p><font color=red>/<em><strong>以下内容源于知乎，原文链接在末尾</strong></em>/</font></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>并查集的重要思想在于，<strong>用集合中的一个元素代表集合</strong>。我曾看过一个有趣的比喻，把集合比喻成<strong>帮派</strong>，而代表元素则是<strong>帮主</strong>。接下来我们利用这个比喻，看看并查集是如何运作的。</p><p><img src="https://pic4.zhimg.com/v2-09fa3fa35e5411444b327d9cb9a31057_r.jpg"></p><p>最开始，所有大侠各自为战。他们各自的帮主自然就是自己。<em>（对于只有一个元素的集合，代表元素自然是唯一的那个元素）</em></p><p>现在1号和3号比武，假设1号赢了（这里具体谁赢暂时不重要），那么3号就认1号作帮主<em>（合并1号和3号所在的集合，1号为代表元素）</em>。</p><p><img src="https://pic4.zhimg.com/v2-3bf6c1a6ecf87fa93f4dbab2012446c7_r.jpg" alt="img"></p><p>​        现在2号想和3号比武<em>（合并3号和2号所在的集合）</em>，但3号表示，别跟我打，让我帮主来收拾你<em>（合并代表元素）</em>。不妨设这次又是1号赢了，那么2号也认1号做帮主。</p><p><img src="https://pic4.zhimg.com/80/v2-be12a6c795572d2acd77dcd49de35127_720w.jpg"></p><p>现在我们假设4、5、6号也进行了一番帮派合并，江湖局势变成下面这样：</p><p><img src="https://pic1.zhimg.com/80/v2-3c353bc781c7f3553079d541a9cfdc28_720w.jpg" alt="img"></p><p>现在假设2号想与6号比，跟刚刚说的一样，喊帮主1号和4号出来打一架（帮主真辛苦啊）。1号胜利后，4号认1号为帮主，当然他的手下也都是跟着投降了。</p><p><img src="https://pic3.zhimg.com/80/v2-6362d8b13705d5ba17b19cdeee453022_720w.jpg" alt="img"></p><p>好了，比喻结束了。如果你有一点图论基础，相信你已经觉察到，这是一个<strong>树</strong>状的结构，要寻找集合的代表元素，只需要一层一层往上访问<strong>父节点</strong>（图中箭头所指的圆），直达树的<strong>根节点</strong>（图中橙色的圆）即可。根节点的父节点是它自己。我们可以直接把它画成一棵树：</p><p><img src="https://pic2.zhimg.com/80/v2-cca3ddf5806a221201ed78caf1d27041_720w.jpg" alt="img"></p><p>用这种方法，我们可以写出最简单版本的并查集代码。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fa[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        fa[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如有编号为1, 2, 3, …, n的n个元素，我们用一个数组fa[]来存储每个元素的父节点（因为每个元素有且只有一个父节点，所以这是可行的）。一开始，我们先将它们的父节点设为自己。</p><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x] == x)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们用递归的写法实现对代表元素的查询：一层一层访问父节点，直至根节点（根节点的标志就是父节点是本身）。要判断两个元素是否属于同一个集合，只需要看它们的根节点是否相同即可。</p><h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fa[find(i)] = find(j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合并操作也是很简单的，先找到两个集合的代表元素，然后将前者的父节点设为后者即可。当然也可以将后者的父节点设为前者，这里暂时不重要。本文末尾会给出一个更合理的比较方法。</p><h2 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h2><p>​    最简单的并查集效率是比较低的。例如，来看下面这个场景：</p><p><img src="https://pica.zhimg.com/v2-49b5dd7af650192373e96d29f9c4b8cf_720w.jpg?source=3af55fa1" alt="img"><img src="https://pica.zhimg.com/80/v2-49b5dd7af650192373e96d29f9c4b8cf_720w.jpg?source=3af55fa1" alt="img"></p><p>​    现在我们要merge(2,3)，于是从2找到1，fa[1]=3，于是变成了这样：</p><p><img src="https://pica.zhimg.com/v2-6f85fc7c5578aa20400ac56f0da31e37_720w.jpg?source=3af55fa1" alt="img"><img src="https://pica.zhimg.com/80/v2-6f85fc7c5578aa20400ac56f0da31e37_720w.jpg?source=3af55fa1" alt="img"></p><p>​    然后我们又找来一个元素4，并需要执行merge(2,4)：</p><p><img src="https://pic2.zhimg.com/v2-1d3ef8a42d424cbec76135ce8a494ff7_720w.jpg?source=3af55fa1" alt="img"><img src="https://pic2.zhimg.com/80/v2-1d3ef8a42d424cbec76135ce8a494ff7_720w.jpg?source=3af55fa1" alt="img"></p><p>​        从2找到1，再找到3，然后fa[3]=4，于是变成了这样：</p><p><img src="https://pica.zhimg.com/v2-23c367515ace6fc0603692dfd865849f_720w.jpg?source=3af55fa1" alt="img"><img src="https://pica.zhimg.com/80/v2-23c367515ace6fc0603692dfd865849f_720w.jpg?source=3af55fa1" alt="img"></p><p>​    大家应该有感觉了，这样可能会形成一条长长的<strong>链</strong>，随着链越来越长，我们想要从底部找到根节点会变得越来越难。</p><p>​    怎么解决呢？我们可以使用<strong>路径压缩</strong>的方法。既然我们只关心一个元素对应的<strong>根节点</strong>，那我们希望每个元素到根节点的路径尽可能短，最好只需要一步，像这样：</p><p><img src="https://pic3.zhimg.com/v2-c2f835398a3e54d8209bf5e034ac6820_720w.jpg?source=3af55fa1" alt="img"><img src="https://pic3.zhimg.com/80/v2-c2f835398a3e54d8209bf5e034ac6820_720w.jpg?source=3af55fa1" alt="img"></p><p>​    其实这说来也很好实现。只要我们在查询的过程中，<strong>把沿途的每个节点的父节点都设为根节点</strong>即可。下一次再查询时，我们就可以省很多事。这用递归的写法很容易实现：</p><h3 id="合并（路径压缩）"><a href="#合并（路径压缩）" class="headerlink" title="合并（路径压缩）"></a>合并（路径压缩）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == fa[x])</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        fa[x] = find(fa[x]);  <span class="comment">//父节点设为根节点</span></span><br><span class="line">        <span class="keyword">return</span> fa[x];         <span class="comment">//返回父节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    以上代码常常简写为一行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == fa[x] ? x : (fa[x] = find(fa[x]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    注意赋值运算符=的优先级没有三元运算符?:高，这里要加括号。</p><p>​    路径压缩优化后，并查集的时间复杂度已经比较低了，绝大多数不相交集合的合并查询问题都能够解决。然而，对于某些时间卡得很紧的题目，我们还可以进一步优化。</p><hr><h2 id="按秩合并"><a href="#按秩合并" class="headerlink" title="按秩合并"></a>按秩合并</h2><p>​    有些人可能有一个误解，以为路径压缩优化后，并查集始终都是一个<strong>菊花图</strong>（只有两层的树的俗称）。但其实，由于路径压缩只在查询时进行，也只压缩一条路径，所以并查集最终的结构仍然可能是比较复杂的。例如，现在我们有一棵较复杂的树需要与一个单元素的集合合并：</p><p><img src="https://pic3.zhimg.com/v2-d3ff42bb79a6bc751f47daf3fc70e0d9_720w.jpg?source=3af55fa1" alt="img"><img src="https://pic3.zhimg.com/80/v2-d3ff42bb79a6bc751f47daf3fc70e0d9_720w.jpg?source=3af55fa1" alt="img"></p><p>​    假如这时我们要merge(7,8)，如果我们可以选择的话，是把7的父节点设为8好，还是把8的父节点设为7好呢？</p><p>​    当然是后者。因为如果把7的父节点设为8，会使树的<strong>深度</strong>（树中最长链的长度）加深，原来的树中每个元素到根节点的距离都变长了，之后我们寻找根节点的路径也就会相应变长。虽然我们有路径压缩，但路径压缩也是会消耗时间的。而把8的父节点设为7，则不会有这个问题，因为它没有影响到不相关的节点。</p><p><img src="https://pica.zhimg.com/v2-96fbb25365b43f0a109bec6d55b3b899_720w.jpg?source=3af55fa1" alt="img"><img src="https://pica.zhimg.com/80/v2-96fbb25365b43f0a109bec6d55b3b899_720w.jpg?source=3af55fa1" alt="img"></p><p>​    这启发我们：我们应该把简单的树往复杂的树上合并，而不是相反。因为这样合并后，到根节点距离变长的节点个数比较少。</p><p>​    我们用一个数组rank[]记录每个根节点对应的树的深度（如果不是根节点，其rank相当于以它作为根节点的<strong>子树</strong>的深度）。一开始，把所有元素的rank（<strong>秩</strong>）设为1。合并时比较两个根节点，把rank较小者往较大者上合并。</p><p>路径压缩和按秩合并如果一起使用，时间复杂度接近 <img src="https://www.zhihu.com/equation?tex=O(n)" alt="[公式]"> ，但是很可能会破坏rank的准确性。</p><h3 id="初始化（按秩合并）"><a href="#初始化（按秩合并）" class="headerlink" title="初始化（按秩合并）"></a>初始化（按秩合并）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">        rank[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并（按秩合并）"><a href="#合并（按秩合并）" class="headerlink" title="合并（按秩合并）"></a>合并（按秩合并）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = find(i), y = find(j);    <span class="comment">//先找到两个根节点</span></span><br><span class="line">    <span class="keyword">if</span> (rank[x] &lt;= rank[y])</span><br><span class="line">        fa[x] = y;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fa[y] = x;</span><br><span class="line">    <span class="keyword">if</span> (rank[x] == rank[y] &amp;&amp; x != y)</span><br><span class="line">        rank[y]++;                   <span class="comment">//如果深度相同且根节点不同，则新的根节点的深度+1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    为什么深度相同，新的根节点深度要+1？如下图，我们有两个深度均为2的树，现在要merge(2,5)：</p><p><img src="https://pic1.zhimg.com/v2-de356190829600f438058e8615c7a5ac_720w.jpg?source=3af55fa1" alt="img"><img src="https://pic1.zhimg.com/80/v2-de356190829600f438058e8615c7a5ac_720w.jpg?source=3af55fa1" alt="img"></p><p>​    这里把2的父节点设为5，或者把5的父节点设为2，其实没有太大区别。我们选择前者，于是变成这样：</p><p><img src="https://pic3.zhimg.com/v2-a829932f008f000440942cb8df393662_720w.jpg?source=3af55fa1" alt="img"><img src="https://pic3.zhimg.com/80/v2-a829932f008f000440942cb8df393662_720w.jpg?source=3af55fa1" alt="img"></p><p>​        显然树的深度增加了1。另一种合并方式同样会让树的深度+1。</p><p><a href="https://zhuanlan.zhihu.com/p/93647900/">点我！！这是原文！！！！！！！！！！</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PX4、ROS、Gazebo安装</title>
      <link href="2021/11/03/PX4%E3%80%81ROS%E3%80%81Gazebo%E5%AE%89%E8%A3%85/"/>
      <url>2021/11/03/PX4%E3%80%81ROS%E3%80%81Gazebo%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="安装指南"><a href="#安装指南" class="headerlink" title="安装指南"></a>安装指南</h1><h2 id="前置步骤"><a href="#前置步骤" class="headerlink" title="前置步骤"></a>前置步骤</h2><h3 id="ubuntu换源："><a href="#ubuntu换源：" class="headerlink" title="ubuntu换源："></a>ubuntu换源：</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure><ul><li>以下几个源任选</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#  阿里镜像源</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 清华镜像源</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>更新</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update &amp;&amp; sudo apt-get upgrade</span><br></pre></td></tr></table></figure><h3 id="科学上网"><a href="#科学上网" class="headerlink" title="科学上网"></a>科学上网</h3><p>主机全局代理+虚拟机nat模式+虚拟机代理</p><h2 id="正式步骤"><a href="#正式步骤" class="headerlink" title="正式步骤"></a>正式步骤</h2><h3 id="ROS-MAVROS-Gazebo"><a href="#ROS-MAVROS-Gazebo" class="headerlink" title="ROS+MAVROS+Gazebo"></a>ROS+MAVROS+Gazebo</h3><ol><li><p>获取快速安装脚本，可能出现网络问题，自行百度，科学上网多试几次，换手机网可行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/PX4/Devguide/master/build_scripts/ubuntu_sim_ros_melodic.sh</span><br></pre></td></tr></table></figure></li><li><p>在脚本目录下运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash ubuntu_sim_ros_melodic.sh</span><br></pre></td></tr></table></figure><p>在运行过程中报错</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error downloading <span class="string">&#x27;install_geographiclib_datasets.sh&#x27;</span>. Sorry but I cannot proceed further :(</span><br></pre></td></tr></table></figure><p><a href="https://gitee.com/MrZhaosx/geographic-lib">https://gitee.com/MrZhaosx/geographic-lib</a></p><p>将链接中三个文件夹下载拷贝到 <strong>/usr/share/GeographicLib</strong> 文件夹下面，不能直接拖拽，先放到桌面用命令行sudo操作</p><p>然后运行 </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./install_geographiclib_datasets.sh</span><br></pre></td></tr></table></figure></li></ol><h3 id="PX4"><a href="#PX4" class="headerlink" title="PX4"></a>PX4</h3><ol><li><p>下载PX4源码</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/PX4/PX4-Autopilot.git --recursive</span><br></pre></td></tr></table></figure></li><li><p>运行ubuntu.sh，如果需要nuttx把–no-nuttx去除即可</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash ./PX4-Autopilot/Tools/setup/ubuntu.sh --no-nuttx</span><br></pre></td></tr></table></figure></li><li><p>重启</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> UAV Simulation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gazebo </tag>
            
            <tag> PX4 </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gazebo问题汇总</title>
      <link href="2021/09/24/Gazebo%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
      <url>2021/09/24/Gazebo%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="问题描述1"><a href="#问题描述1" class="headerlink" title="问题描述1"></a>问题描述1</h1><p><img src="https://i.loli.net/2021/09/24/FWRNOJ7iPm6Et5U.png" alt="image.png"></p><h1 id="解决方案1"><a href="#解决方案1" class="headerlink" title="解决方案1"></a>解决方案1</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unset LIBGL_ALWAYS_INDIRECT</span><br></pre></td></tr></table></figure><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>gazebo在Ardupilot下模型加载慢</p><p><img src="https://i.loli.net/2021/09/24/gRT3DWJmY69CUnt.png" alt="image.png"></p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>提前下载模型后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /usr/share/gazebo/setup.sh</span><br></pre></td></tr></table></figure><h1 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h1><p>运行roslaunch 文件报错</p><p><img src="https://i.loli.net/2021/09/24/vJWqMsb6Gx5CitL.png" alt="image.png"></p><h1 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br><span class="line">把自己创建的catwin那个注释掉</span><br></pre></td></tr></table></figure><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p><img src="https://s2.loli.net/2022/04/19/swiIx47OedS53na.png" alt="image.png"></p><h1 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ros-melodic-mavros ros-melodic-mavros-extras</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> UAV Simulation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gazebo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红黑树</title>
      <link href="2021/08/23/%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%88%EF%BC%89/"/>
      <url>2021/08/23/%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><ul><li>每个节点不是红色就是黑色。</li><li>根节点是黑色的。</li><li>红色节点的子节点必须是黑色（不能有连续的红节点）。</li><li>从根节点到NULL的任何路径所含的黑色节点数目相同。</li><li>叶子节点是黑色的NULL节点（不是二叉树中的叶节点，是其子节点NULL）。</li></ul><p><img src="https://i.loli.net/2021/08/23/9tClpNzVPEginvd.png" alt="image.png"></p><p><strong>为什么有了二叉查找树/平衡树还需要红黑树</strong></p><p><strong>二叉查找树</strong></p><p>特点就是<strong>左子树的节点值比父亲节点小，而右子树的节点值比父亲节点大</strong>，正常logn，但是二叉查找树有可能出现一种极端的情况类似于链表那样。</p><p><strong>平衡二叉树</strong></p><p>是为了解决二叉查找树退化成一颗链表而诞生了，平衡树具有如下特点：</p><p>1、具有二叉查找树的全部特性。</p><p>2、每个节点的左子树和右子树的<strong>高度差至多等于1</strong>。</p><p>虽然平衡树解决了二叉查找树退化为近似链表的缺点，能够把查找时间控制在 O(logn)，不过却不是最佳的，因为平衡树要求<strong>每个节点的左子树和右子树的高度差至多等于1</strong>，这个<strong>要求实在是太严了</strong>，导致每次进行插入/删除节点的时候，几乎都会破坏平衡树的第二个规则，进而我们都需要通过<strong>左旋</strong>和<strong>右旋</strong>来进行调整，使之再次成为一颗符合要求的平衡树。</p><p>显然，如果在那种插入、删除很频繁的场景中，平衡树需要频繁着进行调整，这会使平衡树的性能大打折扣，为了解决这个问题，于是有了红黑树</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 红黑树 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>map, set</title>
      <link href="2021/08/23/map%EF%BC%8Cset/"/>
      <url>2021/08/23/map%EF%BC%8Cset/</url>
      
        <content type="html"><![CDATA[<h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p>​    map是关键字-值对的集合，又名关联数组。无重复关键字。</p><h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><p>​    set是关键字的简单集合。无重复关键字。</p><h1 id="map和set的区别"><a href="#map和set的区别" class="headerlink" title="map和set的区别"></a>map和set的区别</h1><ul><li><p>相同点：map和set都是 C++的关联容器，底层都是红黑树实现的。</p></li><li><p>元素：map的元素是key-value（键值-实值）对，关键字起到索引的作用，值表示与索引相关联的数据；set的元素是键值，没有实值。</p></li><li><p>迭代器：map的迭代器既不是const也不是mutable，map允许修改value实值，不允许修改key键值；set迭代器是const的，不允许修改键值。其原因在于map和 set是根据关键字来保证其有序性的，如果允许修改键值，那么首先要删除该键，调节平衡，然后再插入修改后的键值，调节平衡，这样一来破坏了map和set的结构，导致iterator失效。</p></li><li><p>下标操作：map支持下标操作，用关键字作为下标访问关键字对应的值，如果关键字不存在，它会自动将该关键字插入；set不支持下标操作。</p></li></ul><h1 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h1><p>​    用哈希函数组织的无序map。</p><h1 id="unordered-set"><a href="#unordered-set" class="headerlink" title="unordered_set"></a>unordered_set</h1><p>​    用哈希函数组织的无序set。</p><h1 id="unordered-map和map的区别"><a href="#unordered-map和map的区别" class="headerlink" title="unordered_map和map的区别"></a>unordered_map和map的区别</h1><ul><li>底层实现不同：<ul><li>unordered_map底层实现是一个哈希表，元素无序。</li><li>map底层实现是红黑树，其内部所有的元素都是有序的，因此对map的所有操作，其实都是对红黑树的操作。</li></ul></li><li>优缺点：<ul><li>unordered_map：查找效率高；但是建立哈希表比较耗费时间。</li><li>map：内部元素有序，查找和删除操作又是logn的时间复杂度；但是维护红黑树的存储结构需要占用一定的内存空间。</li></ul></li><li>适用情况：<ul><li>对于要求内部元素有序的用map，对于要求查找效率的用unordered_map。</li></ul></li></ul><h1 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a>multimap</h1><p>​    关键字可重复出现的map。</p><h1 id="multiset"><a href="#multiset" class="headerlink" title="multiset"></a>multiset</h1><p>​    关键字可重复出现的set。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> map </tag>
            
            <tag> set </tag>
            
            <tag> unordered_map </tag>
            
            <tag> unordered_set </tag>
            
            <tag> multiset </tag>
            
            <tag> multimap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迭代和递归</title>
      <link href="2021/08/13/%E8%BF%AD%E4%BB%A3%E5%92%8C%E9%80%92%E5%BD%92/"/>
      <url>2021/08/13/%E8%BF%AD%E4%BB%A3%E5%92%8C%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>​    重复调用函数自身实现循环称为递归。典型问题：斐波那契数列，阶乘（n!）。</p><p>​    构成递归需具备的条件：</p><ol><li>子问题需与原问题为同样的事，且更为简单。</li><li>不能无限制的调用本身，需要有出口。</li></ol><h1 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h1><p>​    迭代法是一种不断用变量的旧值递推新值的过程，典型问题：斐波那契数列，背包问题。</p><h1 id="二者关系与区别"><a href="#二者关系与区别" class="headerlink" title="二者关系与区别"></a>二者关系与区别</h1><p>​    从概念上讲，递归就是指程序调用自身的编程思想，即一个函数调用本身；迭代是利用已知的变量值，根据递推公式不断演进得到新变量值的编程思想。简单的说，递归是重复调用函数自身实现循环。迭代时函数内某段代码实现循环。</p><p>​    迭代与普通循环的区别：迭代时，循环代码中参与运算的变量同时是保存结果的变量，当前保存的结果作为下一次循环计算的初始值。</p><p>​    递归与普通循环的区别：递归是有去无回，而递归是有去有回。</p><p>​    </p><p><a href="https://blog.csdn.net/gaoyu1253401563/article/details/82384958?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control">参考链接1</a>          <a href="https://blog.csdn.net/qq_40817827/article/details/89950325">参考链接2</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 迭代 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git权限管理</title>
      <link href="2021/07/28/git%E6%9D%83%E9%99%90/"/>
      <url>2021/07/28/git%E6%9D%83%E9%99%90/</url>
      
        <content type="html"><![CDATA[<p>​    运行Ardupilot出现permission denied错误解决方案：    git config core.filemode false + chmod</p><h3 id="忽略文件权限"><a href="#忽略文件权限" class="headerlink" title="忽略文件权限"></a>忽略文件权限</h3><p>​    有很多时候我们并不需要过多关注文件权限，特别是部署时会重置文件权限的情况，在开发时由于各环境不同，总是有文件权限的冲突，此时，我们可以忽略文件变更追踪。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config core.filemode <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>可以禁止 <code>Git</code> 跟踪文件权限。</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存管理</title>
      <link href="2021/07/23/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>2021/07/23/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="C-memory-primitives"><a href="#C-memory-primitives" class="headerlink" title="C++ memory primitives"></a>C++ memory primitives</h1><table><thead><tr><th>分配</th><th>释放</th><th>类属</th><th>可否重载</th></tr></thead><tbody><tr><td>malloc()</td><td>free()</td><td>C函数</td><td>不可</td></tr><tr><td>new</td><td>delete</td><td>C++表达式（expressions）</td><td>不可</td></tr><tr><td>::operator new()</td><td>::operator delete()</td><td>C++函数</td><td>可</td></tr><tr><td>allocator<T>:: allocate()</td><td>allocator<T>:: deallocate()</td><td>C++标准库</td><td>可自由设计并搭配任何容器</td></tr></tbody></table><p>各用法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* malloc() and free() */</span></span><br><span class="line"><span class="keyword">void</span>* p1 = <span class="built_in">malloc</span>(<span class="number">512</span>);  <span class="comment">// 分配512个bytes</span></span><br><span class="line"><span class="built_in">free</span>(p1);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* new and delete expression */</span></span><br><span class="line">complex&lt;<span class="keyword">int</span>&gt;* p2 = <span class="keyword">new</span> complex&lt;<span class="keyword">int</span>&gt;; <span class="comment">// one object;</span></span><br><span class="line"><span class="keyword">delete</span> p2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* array new, array delete */</span></span><br><span class="line">Complex* pca = <span class="keyword">new</span> Complex[<span class="number">3</span>];  <span class="comment">// 这里的Complex为自己定义的；</span></span><br><span class="line"><span class="comment">// 调用三次ctor</span></span><br><span class="line"><span class="keyword">delete</span>[] pca;  <span class="comment">// 如果不加[]会导致内存泄漏</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ::operator new() and ::operator delete() */</span></span><br><span class="line"><span class="keyword">void</span>* p3 = ::<span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span>(<span class="number">512</span>); <span class="comment">// 512 bytes</span></span><br><span class="line">::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(p3)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* allocator&lt;T&gt;:: allocate() and allocator&lt;T&gt;:: deallocate() */</span></span><br><span class="line"><span class="comment">// 以下是使用c++标准库提供的allocators</span></span><br><span class="line"><span class="comment">// 不同三家的形式如下 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _MSC_VER</span></span><br><span class="line"><span class="comment">// 以下两函数都是non-static的，需要通过object调用。以下分配3个int</span></span><br><span class="line"><span class="keyword">int</span>* p4 = allocator&lt;<span class="keyword">int</span>&gt;().<span class="built_in">allocate</span>(<span class="number">3</span>, (<span class="keyword">int</span>*)<span class="number">0</span>)； <span class="comment">// 其中(int*)0 目前无用</span></span><br><span class="line">allocator&lt;<span class="keyword">int</span>&gt;().<span class="built_in">deallocate</span>(p4, <span class="number">3</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _BORLANDC_</span></span><br><span class="line"><span class="comment">// 以下两函数都是non-static的，需要通过object调用。以下分配5个int</span></span><br><span class="line"><span class="keyword">void</span>* p4 = allocator&lt;<span class="keyword">int</span>&gt;().<span class="built_in">allocate</span>(<span class="number">5</span>);</span><br><span class="line">allocator&lt;<span class="keyword">int</span>&gt;().deallocate&lt;p4, <span class="number">5</span>&gt;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _GNUC_</span></span><br><span class="line"><span class="comment">// 此为GNUC早期版本 </span></span><br><span class="line"><span class="comment">// 以下两函数都是static的，可通过全名调用。以下分配512 bytes</span></span><br><span class="line"><span class="keyword">void</span>* p4 = alloc::<span class="built_in">allocate</span>(<span class="number">512</span>);</span><br><span class="line">alloc::<span class="built_in">deallocate</span>(p4, <span class="number">512</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _GNUC_</span></span><br><span class="line"><span class="comment">// 新版GNUC</span></span><br><span class="line"><span class="comment">// 以下两函数都是non-static的，需要通过object调用。以下分配7个int</span></span><br><span class="line"><span class="keyword">void</span>* p4 = allocator&lt;<span class="keyword">int</span>&gt;().<span class="built_in">allocate</span>(<span class="number">7</span>);</span><br><span class="line">allocator&lt;<span class="keyword">int</span>&gt;().<span class="built_in">deallocate</span>((<span class="keyword">int</span>*)p4, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下两函数都是non-static的，需要通过object调用。一下分配9个int</span></span><br><span class="line"><span class="keyword">void</span>* p5 = _gnu_cxx::_pool_alloc&lt;<span class="keyword">int</span>&gt;().<span class="built_in">allocate</span>(<span class="number">9</span>);</span><br><span class="line">_gnu_cxx::_pool_alloc&lt;<span class="keyword">int</span>&gt;().<span class="built_in">deallocate</span>((<span class="keyword">int</span>*)p5, <span class="number">9</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="array-new-和-array-delete"><a href="#array-new-和-array-delete" class="headerlink" title="array new 和 array delete"></a>array new 和 array delete</h2><p><img src="https://i.loli.net/2021/07/26/xYs3LaVISlkdFDz.png" alt="image.png"></p><p>​    其中cookie会保存申请的内存的长度等信息，如果delete不加[] 会使得只释放第一或者最后一个内存块，导致内存泄漏。</p><p>​    在使用array new的时候并不能对对象进行想要的初始化，解决方法是使用palcement new。</p><p>Eg：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">A</span>() : <span class="built_in">id</span>(<span class="number">0</span>) &#123; cout&lt;&lt;<span class="string">&quot;default ctor.this=&quot;</span>&lt;&lt;<span class="keyword">this</span>&lt;&lt;<span class="string">&quot; id:&quot;</span>&lt;&lt;id&lt;&lt;endl; &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> i) : <span class="built_in">id</span>(i) &#123; cout&lt;&lt;<span class="string">&quot;ctor.this=&quot;</span>&lt;&lt;<span class="keyword">this</span>&lt;&lt;<span class="string">&quot; id:&quot;</span>&lt;&lt;id&lt;&lt;endl; &#125;</span><br><span class="line">    ~<span class="built_in">A</span>()             &#123; cout&lt;&lt;<span class="string">&quot;dtor.this=&quot;</span>&lt;&lt;<span class="keyword">this</span>&lt;&lt;<span class="string">&quot; id:&quot;</span>&lt;&lt;id&lt;&lt;endl; &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A* buf = <span class="keyword">new</span> A[<span class="number">3</span>];  <span class="comment">// 调用三次default ctor；</span></span><br><span class="line">    A* tmp = buf;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;buf = &quot;</span>&lt;&lt;buf&lt;&lt;<span class="string">&quot; tmp = &quot;</span>&lt;&lt;tmp&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span>(tmp++)<span class="built_in">A</span>(i);  <span class="comment">// ctor 3次</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;buf = &quot;</span>&lt;&lt;buf&lt;&lt;<span class="string">&quot; tmp = &quot;</span>&lt;&lt;tmp&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span>[] buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://i.loli.net/2021/07/26/bhSITMqziPGuERa.png" alt="image.png"></p><p>​    ctor的顺序和dtor顺序正好相反。</p><h2 id="new-expression-和-delete-expression"><a href="#new-expression-和-delete-expression" class="headerlink" title="new expression 和 delete expression:"></a>new expression 和 delete expression:</h2><h3 id="new-expression"><a href="#new-expression" class="headerlink" title="new expression"></a>new expression</h3> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Complex* pc =  <span class="keyword">new</span> <span class="built_in">Complex</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>编译器将其转换为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Complex *pc;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">void</span>* mem = <span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span>(<span class="built_in"><span class="keyword">sizeof</span></span>(Complex));<span class="comment">//allocate</span></span><br><span class="line">    pc = <span class="keyword">static_cast</span>&lt;Complex*&gt;(mem);               <span class="comment">// cast</span></span><br><span class="line">    pc-&gt;Complex::<span class="built_in">Complex</span>(<span class="number">1</span>, <span class="number">2</span>);                    <span class="comment">// construct</span></span><br><span class="line">    <span class="comment">// 只有编译器可以像上一行一样直接呼叫ctor；</span></span><br><span class="line">  <span class="comment">// 我们想直接调用构造函数可使用 placement new：   new(p)Complex(1, 2);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span>(std::bad_alloc) &#123;</span><br><span class="line">    <span class="comment">// 若allocation失败就不执行 constructor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="delete-expression"><a href="#delete-expression" class="headerlink" title="delete expression"></a>delete expression</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Complex* pc = <span class="keyword">new</span> <span class="built_in">Complex</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> pc;</span><br></pre></td></tr></table></figure><p>编译器转换为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pc-&gt;~<span class="built_in">Complex</span>();        <span class="comment">// 先析构</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(pc)</span></span>;   <span class="comment">// 然后释放内存</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>右值引用</title>
      <link href="2021/07/23/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"/>
      <url>2021/07/23/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h1><p>​    右值引用是为了支持移动操作，所谓右值引用就是必须绑定到右值的引用，右值引用只能绑定到一个将要销毁的对象，把即将销毁对象的内存、值等全都 “ 拿 ” 过来。</p><p>​    右值引用只能绑定右值。</p><p>Eg：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp;rr1 = <span class="number">42</span>;  <span class="comment">// 正确，字面值是右值</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr2 = rr1; <span class="comment">// 错误，表达式rr1是左值，变量是左值，即使这个变量是右值引用类型也不行</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr3 = std::<span class="built_in">move</span>(rr1); <span class="comment">// ok  ,move 将左值显式转换成右值行是，但这就意味着调用move后，除了对rr1进行赋值或者销毁外，我们将不再使用它。</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 右值引用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++程序编译过程</title>
      <link href="2021/07/21/C++%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/"/>
      <url>2021/07/21/C++%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="C-程序的编译过程（源码如何转化成二进制）"><a href="#C-程序的编译过程（源码如何转化成二进制）" class="headerlink" title="C++程序的编译过程（源码如何转化成二进制）"></a>C++程序的编译过程（源码如何转化成二进制）</h1><h2 id="编译过程分为四个步骤：编译（编译预处理、编译、优化），汇编，链接"><a href="#编译过程分为四个步骤：编译（编译预处理、编译、优化），汇编，链接" class="headerlink" title="编译过程分为四个步骤：编译（编译预处理、编译、优化），汇编，链接"></a>编译过程分为四个步骤：编译（编译预处理、编译、优化），汇编，链接</h2><ul><li><p>编译预处理：处理以 # 开头的指令。头文件展开，宏替换。</p></li><li><p>编译、优化：将源码 .cpp 文件翻译成 .s 汇编代码。在C++中，以下函数如果你没有定义但是被需要时，编译器会产生他们：默认构造函数、拷贝构造函数、析构函数、赋值运算符和一对取址运算符。</p></li><li><p>汇编：将汇编代码 .s 翻译成机器指令 .o 目标文件。目标文件以机器码的形式包含了编译单元里所有的函数和数据、导出符号表、未解决符号表、地址重定向表等。目标文件由段组成。通常一个目标文件中至少有两个段：</p><ul><li>代码段：该段中所包含的主要是程序的指令。该段一般是可读和可执行的，但一般却不可写。</li><li>数据段：主要存放程序中要用到的各种全局变量或静态的数据。一般数据段都是可读，可写，可执行的。</li></ul></li><li><p>链接：汇编程序生成的目标文件不会立即执行，可能有源文件中的函数引用了另一个源文件中定义的符号或者调用了某个库文件中的函数。链接的目的就是将这些目标文件连接成一个整体，生成一个可执行的.exe文件。C++使用链接器以确保用到的函数都只被定义一次，以及确保static objects只被定义一次，会将我们做了声明但却未曾定义的函数检测出来。</p></li></ul><p><img src="https://i.loli.net/2021/07/26/OS5yPWYLGnDjk9r.png" alt="编译过程"></p><h2 id="链接分为两种：静态和动态"><a href="#链接分为两种：静态和动态" class="headerlink" title="链接分为两种：静态和动态"></a>链接分为两种：静态和动态</h2><ul><li>静态链接：代码从其所在的静态链接库中拷贝到最终的可执行程序中，在该程序被执行时，这些代码会被装入到该进程的虚拟地址空间中。</li><li>动态链接：代码被放到动态链接库或共享对象的某个目标文件中，链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息。在程序执行时，动态链接库的全部内容会被映射到运行时相应进行的虚拟地址的空间。</li></ul><h2 id="二者优缺点"><a href="#二者优缺点" class="headerlink" title="二者优缺点"></a>二者优缺点</h2><ul><li>静态链接：<strong>浪费空间</strong>，每个可执行程序都会有目标文件的一个副本，这样如果目标文件进行了更新操作，就需要重新进行编译链接生成可执行程序（<strong>更新困难</strong>）；优点就是执行的时候运行速度快，因为可执行程序具备了程序运行的所有内容。</li><li>动态链接：节省内存、更新方便，但是动态链接是在程序运行时，每次执行任务都需要进行链接，性能会有一定的损失。</li></ul><p><strong>更为详尽的解释：<a href="https://blog.csdn.net/hycxag/article/details/82967579">https://blog.csdn.net/hycxag/article/details/82967579</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 编译 </tag>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C、C++区别</title>
      <link href="2021/05/31/C%E3%80%81C++/"/>
      <url>2021/05/31/C%E3%80%81C++/</url>
      
        <content type="html"><![CDATA[<h1 id="C和C-区别"><a href="#C和C-区别" class="headerlink" title="C和C++区别"></a>C和C++区别</h1><ul><li>C是面向用户的编程，特点是函数；C++是面向对象的编程，特点是类。<font color=blue>（特性）</font>    </li><li>C主要应用于嵌入式开发、驱动开发和硬件直接打交道的领域；C++可以应用于应用层的开发、用户界面开发等和操作系统直接打交道的领域。<font color=blue>（应用领域 ）</font></li><li>C++继承了C的底层操作特性，增加了面向对象的机制，增加而泛型编程 、异常处理、运算符重载，还增加了命名空间，避免了命名冲突。<font color=blue>（相较于C的升级）</font>    </li></ul><h1 id="C-相较于C的增强"><a href="#C-相较于C的增强" class="headerlink" title="C++相较于C的增强"></a>C++相较于C的增强</h1><ul><li>全局变量检测增强。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;  <span class="comment">// 在c语言中不会出现问题，在c++中会报错</span></span><br></pre></td></tr></table></figure><ul><li>函数的检测增强，参数类型增强，函数返回值检测增强，函数调用的参数检测异常。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getRectS</span><span class="params">(w, h)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// 在c语言中没问题，但是在c++中报错，需要增加返回值以及参数类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> test01（） &#123;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">getRectS</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>)&lt;&lt;endl; <span class="comment">// c语言没问题，但是c++中只能传递两个参数，会报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>类型转换检测增强</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span>* p = <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="number">64</span>)); <span class="comment">// malloc返回值是void*，在c语言中可以运行，c++不可</span></span><br><span class="line">    <span class="keyword">char</span>* p = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="number">64</span>)); <span class="comment">// 才可以</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>struct增强</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">plusAge</span><span class="params">()</span></span>; <span class="comment">// c语言中不可以加函数，在c中报错，c++可以</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p1</span>;</span> <span class="comment">// 在创建对象的时候c语言必须加struct关键字，c++不用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>bool类型的增强，c语言中没有bool类型，c++有， sizeof(bool) = 1，bool类型的非零值都会转换为1</li><li>三目运算符增强，c++返回的是变量，c语言返回的是值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    （a &gt; b ? a : b） = <span class="number">100</span>;  <span class="comment">// 在c语言中编译不通过，但是在c++通过，因为在c++中这行代码左边返回的是b，即b = 100，而c语言返回的是20；</span></span><br><span class="line">    cout&lt;&lt;b; <span class="comment">// 输出100；</span></span><br><span class="line">    <span class="comment">// c语言如果想实现相同的效果</span></span><br><span class="line">    *(a &gt; b ? &amp;a : &amp;b) = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>const增强，c++中不会给const分配空间，而是将m_B存入符号表中，在c中const默认为外部链接，c++中const默认为内部链接只能在当前作用域使用，要想在外部使用在定义时加extern关键字    </li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m_A = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test06</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    m_A = <span class="number">100</span>;  <span class="comment">// 全局的const不管c还是c++都不能修改，报错</span></span><br><span class="line">    <span class="keyword">const</span> m_B = <span class="number">10</span>; <span class="comment">// 在c中可以通过指针将m_B（伪常量）修改，不能初始化数组，c++中不管以什么方式都不能修改，可以初始化数组，因为没有分配内存，只有分配内存的才可以通过指针进行修改，例子见下面代码</span></span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span>*)&amp;m_B;</span><br><span class="line">    *p = <span class="number">200</span>;</span><br><span class="line">    <span class="comment">// 在c中上面两行代码相当于做了如下操作：</span></span><br><span class="line">    <span class="comment">// int tmp = m_B;   编译器临时开辟一块空间</span></span><br><span class="line">    <span class="comment">// int *p = (int*)&amp;tmp;</span></span><br><span class="line">    <span class="comment">// *p = 200；</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="string">&quot;    &quot;</span> &lt;&lt; m_B &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 输出200  10； </span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>const分配内存</p><ul><li>const在取地址得时候会分配临时内存</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> m_A = <span class="number">10</span>;  <span class="comment">// 不分配内存</span></span><br><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span>*) &amp;m_A; <span class="comment">// 分配临时内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>extern编译器也会给const变量分配内存</li><li>用变量初始化const变量会分配内存</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> b = a;  <span class="comment">// 会分配内存；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> * p =(<span class="keyword">int</span>*) &amp;b;</span><br><span class="line">*p = <span class="number">1000</span>;   <span class="comment">// 这里的b得值会被改成1000；  只有分配了内存才能通过指针对其进行修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>自定义数据类型加const也会分配内存</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">string m_Name;</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">const</span> Person p1;</span><br><span class="line"><span class="comment">// p1.m_Name = &quot;AAA&quot;;  // 报错，const变量不能直接修改，但是因为分配了内存，可以通过指针进行修改</span></span><br><span class="line">Person *p = (Person*)&amp;p1;</span><br><span class="line">p-&gt;m_Name = <span class="string">&quot;asd&quot;</span>;</span><br><span class="line">(*p).m_Age = <span class="number">19</span>;  <span class="comment">// 可以修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>引用是c++对c的重要扩充，引用就是取别名</p><ul><li>基本语法： Type &amp;别名 = 原名</li><li>引用必须初始化，初始化后不可再改为别人的别名</li><li>对数组建立引用</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span>(&amp;pArr)[<span class="number">10</span>] = arr; <span class="comment">// 方法一</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(ARRAYREF)</span>[10]</span>;</span><br><span class="line">    ARRAYREF &amp;pArr2 = arr; <span class="comment">// 方法二</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重写和重载</title>
      <link href="2021/05/31/%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E8%BD%BD/"/>
      <url>2021/05/31/%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="C-中重载和重写（覆盖）的区别"><a href="#C-中重载和重写（覆盖）的区别" class="headerlink" title="C++中重载和重写（覆盖）的区别"></a>C++中重载和重写（覆盖）的区别</h1><ul><li>对于类中函数的重载和重写而言，重载发生在同一个类内部，重写则发生在不同的类之间，子类和父类之间。</li><li>重载的函数需要与原函数有相同的函数名、不同的参数列表，不关注函数的返回值类型；重写的函数的函数名、参数列表和返回值类型都需要与原函数相同，父类中被重写的函数需要有virtual修饰。</li><li>virtual关键字：重写的函数基类中必须有virtual关键字的修饰，重载的函数可以有virtual关键字修饰也可以没有。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 重载 </tag>
            
            <tag> 重写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>new/delete和malloc/free用法及区别</title>
      <link href="2021/05/28/new%E3%80%81delete%E5%92%8Cmalloc/"/>
      <url>2021/05/28/new%E3%80%81delete%E5%92%8Cmalloc/</url>
      
        <content type="html"><![CDATA[<h1 id="new和delete的用法"><a href="#new和delete的用法" class="headerlink" title="new和delete的用法"></a>new和delete的用法</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//开辟一个空间</span></span><br><span class="line"><span class="keyword">int</span>* p1 = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> p1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开辟多个空间，通过new开辟数组，一定会调用默认构造函数，所以要提供默认构造函数，在堆区开辟数组不能调用有参构造函数，但是在栈区可以调用有参构造函数</span></span><br><span class="line"><span class="keyword">int</span>* p2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">Person pArray[<span class="number">2</span>] = &#123;<span class="built_in">Person</span>(<span class="number">1</span>), <span class="built_in">Person</span>(<span class="number">2</span>)&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">delete</span> []p2;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意事项，用void*接受new出来的指针，会出现释放问题。</span></span><br><span class="line">    <span class="keyword">void</span>* p = <span class="keyword">new</span> Person;</span><br><span class="line">    <span class="keyword">delete</span> p;   <span class="comment">// p无法释放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="malloc和free的用法"><a href="#malloc和free的用法" class="headerlink" title="malloc和free的用法"></a>malloc和free的用法</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//开辟一个空间</span></span><br><span class="line"><span class="keyword">int</span>* p1=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">if</span>(p1==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(p1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//开辟多个空间</span></span><br><span class="line"><span class="keyword">int</span>*p2=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)*<span class="number">4</span>);</span><br><span class="line"><span class="keyword">if</span>(p2==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="new和malloc的区别"><a href="#new和malloc的区别" class="headerlink" title="new和malloc的区别"></a>new和malloc的区别</h1><p>在使用的时候，new和delete搭配使用，malloc和free搭配使用，二者从功能上来看都是用来申请内存和回收内存的。</p><ul><li>属性：malloc/free是库函数，需要头文件的支持；new/delete是关键字，需要编译器的支持。</li><li>参数：new申请空间时，无需指定分配空间的大小，编译器会根据类型自行计算；malloc在申请空间时，需要确定所申请的空间大小。</li><li>返回值：new申请空间时，返回的类型是对象的指针类型，无需强制类型转换，故new是符合类型安全性的操作符。而malloc申请空间返回的是void*类型，需要进行强制类型转换，转化为对象类型的指针。</li><li>分配失败：new分配失败会抛出bad_alloc异常，malloc分配失败时返回空指针。</li><li>重载：new/delete是操作符，支持重载，只能在C++使用；malloc/free是函数，可以覆盖（重写），但不能重载，在C、C++都可以使用。</li><li>自定义类型实现：new首先调用operator new函数申请空间（底层通过malloc实现），然后调用构造函数进行初始化，最后返回自定义类型的指针；delete首先调用析构函数，然后调用operator delete释放空间（底层通过free实现）。malloc/free无法进行自定义类型对象的构造和析构。new分配一个对象，malloc分配一块内存。</li><li>内存区域：new操作符从自由存储区上为对象动态分配内存，malloc函数从堆上动态分配内存。（自由存储区 ≠ 堆）。</li></ul><p><a href="https://blog.csdn.net/weibo1230123/article/details/81980889">参考链接1</a></p><p><a href="https://www.cnblogs.com/maluning/p/7944231.html">参考链接2</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> new </tag>
            
            <tag> malloc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存分区模型</title>
      <link href="2021/05/21/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA%E6%A8%A1%E5%9E%8B/"/>
      <url>2021/05/21/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="内存分区模型"><a href="#内存分区模型" class="headerlink" title="内存分区模型"></a>内存分区模型</h1><p>目前网络上主要有两种内存分区方法：</p><h2 id="四区"><a href="#四区" class="headerlink" title="四区"></a>四区</h2><p>C++程序在执行时，将内存大方向分为四个区：</p><ul><li>代码区：存放函数体的二进制代码，由操作系统进行管理。<font color=blue>(共享、只读)</font></li><li>全局区：存放全局变量和静态变量以及常量。<font color=blue>（该区数据在程序结束后由操作系统释放）</font></li><li>栈区：由编译器自动分配释放，存放函数的参数值，局部变量等。<font color=blue>（注意函数不要返回局部变量的地址 ）</font></li><li>堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。<font color=blue>（可以把函数返回的地址保存住，用new来开辟内存）</font></li></ul><h2 id="五区"><a href="#五区" class="headerlink" title="五区"></a>五区</h2><p>分为五区：</p><ul><li>栈区：存放函数的局部变量，由编译器自动分配和释放。</li><li>堆区：动态申请的内存空间，由malloc分配的内存块，由程序员控制它的分配和释放，如果程序执行结束还没有释放，操作系统会自动回收。</li><li>自由存储区：和堆十分相似，存放由new分配的内存块，由delete释放内存。</li><li>全局区/静态区：存放全局变量和静态变量。</li><li>常量存储区：存放的是常量，不允许修改。</li></ul><p><strong>内存四区的意义：不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活性来编程。</strong></p><h2 id="堆和自由存储区的区别："><a href="#堆和自由存储区的区别：" class="headerlink" title="堆和自由存储区的区别："></a>堆和自由存储区的区别：</h2><ul><li>自由存储区是C++中通过new与delete动态分配和释放对象的抽象概念，而堆是C语言和操作系统的术语，是操作系统维护的一块动态分配内存。</li><li>new所申请的内存区域在C++中成为自由存储区，通过堆实现的自由存储，可以说new所申请的内存区域在堆上。</li><li>堆和自由存储区有区别，并非等价。使用new来分配内存，程序员也可以通过重载操作符，改用其他的内存来实现自由存储，例如全局变量做的对象池，这时自由存储区就区别于堆了。</li></ul><p><a href="https://www.cnblogs.com/QG-whz/p/5060894.html">参考链接</a></p><h1 id="堆和自由存储区定义："><a href="#堆和自由存储区定义：" class="headerlink" title="堆和自由存储区定义："></a>堆和自由存储区定义：</h1><blockquote><p>Free Store：<br>The free store is one of the two dynamic memory areas, allocated/freed by new/delete. Object lifetime can be less than the time the storage is allocated; that is, free store objects can have memory allocated without being immediately initialized, and can be destroyed without the memory being immediately deallocated. During the period when the storage is allocated but outside the object’s lifetime, the storage may be accessed and manipulated through a void* but none of the proto-object’s non-static members or member functions may be accessed, have their addresses taken, or be otherwise manipulated.</p></blockquote><blockquote><p>Heap：<br>The heap is the other dynamic memory area, allocated/freed by malloc/free and their variants. Note that while the default global new and delete might be implemented in terms of malloc and free by a particular compiler, the heap is not the same as free store and memory allocated in one area cannot be safely deallocated in the other. Memory allocated from the heap can be used for objects of class type by placement-new construction and explicit destruction. If so used, the notes about free store object lifetime apply similarly here.</p></blockquote><p>来源：<a href="http://www.gotw.ca/gotw/009.htm">http://www.gotw.ca/gotw/009.htm</a></p><p>个人理解：自由存储区就是我们所说的用new和delete动态进行内存分配和释放的区域，一般来说new的底层是通过malloc进行内存的分配，而malloc函数是从堆区上分配内存，所以在这种情况下自由存储区和堆区实际说的是一个地方，但是假如程序员通过重载等手段不通过malloc在堆区分配内存，从别的区分配，则二者就不一样了 ，如用全局变量做对象池。</p><h2 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h2><ul><li>申请方式：栈是系统自动分配的，而堆是程序员主动申请的。</li><li>申请后系统响应：分配栈空间，如果剩余空间大于申请空间则分配成功，否则分配失败栈溢出；申请堆空间，堆在内存中的呈现方式类似于链表（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序 ，将该节点从链表中删除，大多数系统会在该块空间的首地址处记录本次分配的大小，便于之后的delete语句释放内存。另外，找到的内存空间大小不一定正好等于申请空间大小，系统自动将多余部分重新放入空闲链表中。</li><li>栈在内存中是连续的一块空间（向低地址扩展）最大容量是系统预定好的，堆在内存中的空间（向高地址扩展）是不连续的。</li><li>申请效率：栈是由系统自动分配的，申请效率高但程序员无法控制；堆是由程序员主动申请的，效率低，使用起来方便但是容易产生碎片。</li><li>存放内容：栈中存放的是局部变量，函数的参数；堆中存放的内容是由程序员控制的。</li></ul><p><a href="https://blog.csdn.net/hairetz/article/details/4141043">参考链接</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 内存 </tag>
            
            <tag> 堆 </tag>
            
            <tag> 栈 </tag>
            
            <tag> 自由存储区 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>const小结</title>
      <link href="2021/05/16/const%E5%B0%8F%E7%BB%93/"/>
      <url>2021/05/16/const%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="const-分类"><a href="#const-分类" class="headerlink" title="const 分类"></a>const 分类</h1><h3 id="顶层const："><a href="#顶层const：" class="headerlink" title="顶层const："></a>顶层const：</h3><ul><li>顶层const可以表示任意的对象是常量，例如常量指针，指针本身为常量。<font color=#FF0000>顶层const作用于对象本身。</font></li></ul><h3 id="底层const："><a href="#底层const：" class="headerlink" title="底层const："></a>底层const：</h3><ul><li>底层const与指针和引用等复合类型部分有关，例如指针所指对象是常量。</li></ul><p><strong>Eg:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p1 = &amp;i;        <span class="comment">// 顶层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> c1 = <span class="number">42</span>;         <span class="comment">// 顶层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p2 = &amp;c1;       <span class="comment">// 底层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> p3 = p2; <span class="comment">// 左边底层， 右边顶层</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r = c1;         <span class="comment">// 用于声明引用的是底层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = <span class="number">42</span>;        <span class="comment">// 允许为一个常量引用绑定非常量的对象、字面值、甚至是个一般表达式</span></span><br></pre></td></tr></table></figure><h3 id="注："><a href="#注：" class="headerlink" title="注："></a><font color=red>注：</font></h3><ul><li>顶层const形参无法重载函数</li></ul><p><strong>Eg:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lookup</span><span class="params">(Phone)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Phone)</span></span>;  <span class="comment">// 等价的重复声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lookup</span><span class="params">(Phone*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lookup</span><span class="params">(Phone* <span class="keyword">const</span>)</span></span>; <span class="comment">// 等价的重复声明</span></span><br></pre></td></tr></table></figure><ul><li>底层const形参可实现函数重载</li></ul><p><strong>Eg：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lookup</span><span class="params">(Phone&amp;)</span></span>;       <span class="comment">// 作用于Phone的引用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Phone&amp;)</span></span>; <span class="comment">// 作用于Phone的常量引用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loohup</span><span class="params">(Phone*)</span></span>;       <span class="comment">// 作用于指向Phone的指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Phone*)</span></span>; <span class="comment">// 作用于指向Phone常量的指针</span></span><br></pre></td></tr></table></figure><p>当传递非常量对象或指向非常量对象的指针时，会优先选用非常量版本。</p><h1 id="const-用法"><a href="#const-用法" class="headerlink" title="const 用法"></a>const 用法</h1><ul><li><p>const修饰成员变量，定义成const常量，相较于宏常量，可进行类型检查，节省内存空间，提高了效率；const成员变量要进行初始化。</p></li><li><p>const修饰函数参数，使得传递过来的函数参数的值不能改变。</p></li><li><p>const修饰成员函数（常函数 void func() const {} ），使得成员函数不能修改任何类型的成员变量（mutable修饰的变量除外，函数参数也除外），也不能调用非const成员函数，因为非const成员函数可能会修改成员变量。</p></li><li><p>const修饰对象（常对象），只能调用常函数，不可调用普通成员函数，因为普通函数可以修改属性；同时不能对成员变量进行修改。</p></li></ul><h1 id="const注意事项"><a href="#const注意事项" class="headerlink" title="const注意事项"></a>const注意事项</h1><h2 id="const成员变量"><a href="#const成员变量" class="headerlink" title="const成员变量"></a>const成员变量</h2><ul><li><p>const成员变量只能在类内声明、定义，在构造函数初始化列表中初始化，注意在构造函数函数体内部叫赋值（经测试在声明时初始化也可，尽量不要，原因见下条）。</p></li><li><p>const成员变量只在某个对象的生存周期内是常量，对于整个类而言是可变的，因为类可以创建多个对象，不同对象的const成员变量值不同，所以不能在类的声明中初始化const成员变量，因为类的对象还没有创建，编译器不知道他的值。</p></li></ul><h2 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h2><ul><li>不能修改成员变量的值，除非有mutable修饰；只能访问成员变量。</li><li>不能调用非常量成员的函数，以防修改成员变量的值。</li></ul><h1 id="define和const的区别（编译阶段、安全性、内存占用等）"><a href="#define和const的区别（编译阶段、安全性、内存占用等）" class="headerlink" title="define和const的区别（编译阶段、安全性、内存占用等）"></a>define和const的区别（编译阶段、安全性、内存占用等）</h1><ul><li>编译阶段：define是在编译预处理阶段起作用，const是在编译阶段和程序运行阶段起作用。</li><li>安全性：define定义的宏常量没有数据类型，只是进行简单的替换，不会进行类型安全的检查；const定义的只读变量是有类型的，需要进行判断，可以避免一些低级错误。</li><li>内存占用：define定义的宏常量，在程序中使用多少次就会进行多少次替换，内存中有多个备份；const定义的只读变量在程序运行过程中只有一份。</li><li>调试：define定义的不能调试，因为在预编译阶段就进行替换了；const定义的可以进行调试。</li><li>define是没有作用域的，从声明到文件尾都是存活的，但是可以通过#undef A 来卸载宏常量A，而const是有作用域的。</li></ul><h1 id="const的优点"><a href="#const的优点" class="headerlink" title="const的优点"></a>const的优点</h1><ul><li>有数据类型，在定义时可进行安全性检查</li><li>可调试</li><li>占用较少的空间</li></ul><p>在《c和c++区别》这章也有关于const的内容</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> const </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
