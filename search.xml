<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>动态对象创建</title>
      <link href="2022/01/12/%E5%8A%A8%E6%80%81%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA/"/>
      <url>2022/01/12/%E5%8A%A8%E6%80%81%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 构造 </tag>
            
            <tag> 析构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>explicit关键字</title>
      <link href="2022/01/12/explicit%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>2022/01/12/explicit%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<ul><li>在创建对象的时候会存在隐式类型转换，添加explicit关键字后不能进行隐式类型转换。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">MyClass p = <span class="number">10</span>;  <span class="comment">// 如果在类中添加了explicit关键字，这行报错，不能进行隐式类型转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> explicit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象的构造和析构</title>
      <link href="2022/01/12/%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84/"/>
      <url>2022/01/12/%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h1><ul><li>构造函数：没有返回值，没有void，类名相同，可以发生重载，可以有参数。</li><li>析构函数：没有返回值，没有void，函数名称：~类名，不可以重载，不可以有参数。</li><li>系统会默认调用构造函数和析构函数且只调用一次。</li><li>若程序员不提供构造和析构函数，系统默认提供空实现。</li><li>构造和析构必须写在public下才可以调用到。</li></ul><h1 id="构造函数的分类和调用"><a href="#构造函数的分类和调用" class="headerlink" title="构造函数的分类和调用"></a>构造函数的分类和调用</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li>按参数分类<ul><li>无参构造函数（默认构造函数，调用默认构造函数创建对象时不加“()”，Person p1() 会被认成函数声明）</li><li>有参构造函数</li></ul></li><li>按类型分类<ul><li>普通构造函数</li><li>拷贝构造函数（注意浅拷贝问题，参数要加const）</li></ul></li></ul><h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Person p1;      <span class="comment">// 默认构造</span></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">1</span>)</span></span>;   <span class="comment">// 有参构造</span></span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(p1)</span></span>;<span class="comment">// 拷贝构造</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="number">100</span>);    <span class="comment">// 匿名对象，如果编译器发现匿名对象，那么在这行代码结束后就释放这个对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式法调用</span></span><br><span class="line">Person p4 = <span class="built_in">Person</span>(<span class="number">100</span>);</span><br><span class="line">Person p5 = <span class="built_in">Person</span>(p4);</span><br><span class="line"><span class="comment">// 不能用拷贝构造函数初始化匿名对象</span></span><br><span class="line"><span class="built_in">Person</span>(p5);    <span class="comment">// 如果这么写，编译器会认为成 Person p5； 对象的声明，但是可以写成右值</span></span><br><span class="line">Person p6 = <span class="built_in">Person</span>(p5);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式类型转换</span></span><br><span class="line">Person p7 = <span class="number">100</span>;  <span class="comment">// 相当于调用Person p7 = Person(100);</span></span><br><span class="line">Person p8 = p7;</span><br></pre></td></tr></table></figure><h1 id="拷贝构造函数的调用时机"><a href="#拷贝构造函数的调用时机" class="headerlink" title="拷贝构造函数的调用时机"></a>拷贝构造函数的调用时机</h1><ul><li>用已经创建好的对象来初始化新对象。</li><li>以值传递方式给函数参数传值。</li><li>以值方式返回局部对象。</li></ul><h1 id="构造函数的调用规则"><a href="#构造函数的调用规则" class="headerlink" title="构造函数的调用规则"></a>构造函数的调用规则</h1><ul><li><p>系统默认提供三个函数：默认构造函数、拷贝构造函数和析构函数。</p></li><li><p>当提供了有参的构造函数，那么系统不会给我们提供默认构造函数，仍提供默认的拷贝构造函数，进行简单的值拷贝。</p></li><li><p>当提供了拷贝构造函数，那么系统不会提供其他构造函数。</p></li></ul><h1 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h1><ul><li>系统默认提供的拷贝构造会进行简单的值拷贝。</li><li>如果属性里有指向堆区空间的数据，那么简单的浅拷贝会导致重复释放内存的异常。</li><li>解决上述问题需要自己提供拷贝构造函数进行深拷贝。</li></ul><h1 id="构造函数和析构函数的调用顺序（在类对象作为成员时）"><a href="#构造函数和析构函数的调用顺序（在类对象作为成员时）" class="headerlink" title="构造函数和析构函数的调用顺序（在类对象作为成员时）"></a>构造函数和析构函数的调用顺序（在类对象作为成员时）</h1><ul><li>首先对类内的类成员对象进行构造，然后在调用类的构造函数</li><li>析构的顺序正好和构造顺序相反</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">class <span class="title">Phone</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Phone</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Phone构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">    ~<span class="built_in">Phone</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Phone析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">class <span class="title">Game</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Game</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Game构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">    ~<span class="built_in">Game</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Game析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">class <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Phone phone;</span><br><span class="line">    Game game;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://s2.loli.net/2022/01/12/U6bW2kl7AvKzRyt.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 构造 </tag>
            
            <tag> 析构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++封装</title>
      <link href="2022/01/11/C++%E5%B0%81%E8%A3%85/"/>
      <url>2022/01/11/C++%E5%B0%81%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><ul><li>把变量（属性）和函数（操作）合成一个整体，封装在一个类中。</li><li>对变量和函数进行访问控制。</li></ul><h1 id="class和struct"><a href="#class和struct" class="headerlink" title="class和struct"></a>class和struct</h1><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>struct和class其实一样，唯一的区别是默认权限不同，struct默认public，class默认private。</p><h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><ul><li>private：私有权限，类内可以访问，类外不可访问，子类也不可访问。</li><li>public：共有权限，类内外都可以访问。</li><li>protected：保护权限，类内可访问，当前类的子类可以访问，类外不可访问。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四旋翼建模</title>
      <link href="2021/11/30/%E5%9B%9B%E6%97%8B%E7%BF%BC%E5%BB%BA%E6%A8%A1/"/>
      <url>2021/11/30/%E5%9B%9B%E6%97%8B%E7%BF%BC%E5%BB%BA%E6%A8%A1/</url>
      
        <content type="html"><![CDATA[<p><font color=red><em><strong>以下内容源于知乎，参考链接如下</strong></em></font></p><p><a href="https://zhuanlan.zhihu.com/p/332625724">https://zhuanlan.zhihu.com/p/332625724</a></p><p>先给出四旋翼建模和底层飞控的整体结构图：</p><p><img src="https://pic2.zhimg.com/80/v2-b0c8a97ed2d7865cab0865dd9fd80e29_1440w.png" alt="img"></p><p>上层控制器给出底层的控制指令，例如轨迹规划、协同控制算法等都算是上层控制器。</p><h2 id="1-坐标系"><a href="#1-坐标系" class="headerlink" title="1. 坐标系"></a><strong>1. 坐标系</strong></h2><h2 id="1-1-坐标系定义"><a href="#1-1-坐标系定义" class="headerlink" title="1.1 坐标系定义"></a><strong>1.1 坐标系定义</strong></h2><p>坐标系定义是最基础的前提，因为所有的公式变量都是以坐标系为前提的。</p><p>对于四旋翼模型来说，需要两个坐标系：</p><ul><li>全局坐标系/大地坐标系/惯性坐标系，符号表示： <img src="https://www.zhihu.com/equation?tex=%5CSigma%5E%5Cmathrm%7Bg%7D" alt="[公式]">  - （NED北东地)</li><li>机体坐标系，符号表示： <img src="https://www.zhihu.com/equation?tex=%5CSigma%5E%5Cmathrm%7Bb%7D" alt="[公式]">   - （前右下)</li></ul><p>全局坐标系是固连在大地上的；机体坐标系是固连到四旋翼机体上的，所以如果有很多个四旋翼，也就有很多个机体坐标系。</p><p>全局坐标系的原点一般来说是定义在飞机起飞点附近，在近距离的飞行时，可以忽略地球的曲率。机体坐标系的原点定义是飞机的重心位置。</p><p>全局坐标系的x,y,z轴的正方向分别是北东地（NED），所以无人机向上飞，其z轴坐标是负数。</p><p>机体坐标系的 x,y,z 轴的正方向分别是前右下，也就是飞机的正前方是x轴的正方向。</p><p>按照以上定义，如果全局坐标系的原点设在起飞点，无人机起飞前的初始位置的摆放是正前方对应北向，那么初始时，这两个坐标系是重合的。</p><h2 id="1-2-坐标变换"><a href="#1-2-坐标变换" class="headerlink" title="1.2 坐标变换"></a><strong>1.2 坐标变换</strong></h2><p>首先定义3个旋转矩阵：</p><p><img src="https://s2.loli.net/2022/01/10/72nOzGvLXJqNhoy.png" alt="旋转矩阵.png"></p><p>分别是绕x,y,z轴旋转 <img src="https://www.zhihu.com/equation?tex=%5Ctheta" alt="[公式]"> 角的旋转矩阵。</p><ul><li><p>全局到机体坐标变换公式为：<img src="https://www.zhihu.com/equation?tex=P%5Eb=R%5E%7Bg2b%7D(P%5Eg-T_%7Bb%7D%5Eg)" alt="[公式]"></p><p>其中，</p></li><li><ul><li><img src="https://www.zhihu.com/equation?tex=P%5Eg" alt="[公式]"> 是全局坐标系下的点的坐标，</li><li><img src="https://www.zhihu.com/equation?tex=P%5Eb" alt="[公式]">  是同样的点在机体坐标系下的坐标；</li><li><img src="https://www.zhihu.com/equation?tex=R%5E%7Bg2b%7D=R_xR_yR_z" alt="[公式]"> </li><li>飞机角度为， <img src="https://www.zhihu.com/equation?tex=%5Ctheta_x=roll,+%5Ctheta_y=pitch,%5Ctheta_z=yaw" alt="[公式]"> </li><li><img src="https://www.zhihu.com/equation?tex=T_b%5Eg" alt="[公式]"> 为飞机全局坐标系下的位置。</li></ul></li><li><p>机体到全局坐标变换公式为： <img src="https://www.zhihu.com/equation?tex=P%5Eg=R%5E%7Bb2g%7DP%5Eb+T_b%5Eg" alt="[公式]"></p></li><li><ul><li>其中， <img src="https://www.zhihu.com/equation?tex=R%5E%7Bb2g%7D=(R%5E%7Bg2b%7D)%5E%7B-1%7D=R_zR_yR_x" alt="[公式]"> </li><li>飞机角度为 <img src="https://www.zhihu.com/equation?tex=%5Ctheta_x=-roll,+%5Ctheta_y=-pitch,%5Ctheta_z=-yaw" alt="[公式]"></li></ul></li></ul><p>坐标变换有两种变换方法：先平移后旋转；先旋转后平移。</p><p>上面全局到机体的变换是先平移后旋转的方式，而机体到全局的变换是先旋转后平移的方式。两种方式都可以。</p><p>注意上面的变换中，从全局到机体和从机体到全局的变换是互逆的，两个旋转矩阵也是互逆的。但是如果两种变换都是用同样的方式（比如先旋转后平移），那么两个旋转矩阵就不是互逆的了。</p><h2 id="1-3-坐标变换的通俗解释"><a href="#1-3-坐标变换的通俗解释" class="headerlink" title="1.3 坐标变换的通俗解释"></a><strong>1.3 坐标变换的通俗解释</strong></h2><p>这一节是一个非常通俗的坐标变换的解释，对坐标变换比较熟悉的读者就不需要看了。</p><p>可能刚开始接触坐标系转换的同学对各种旋转矩阵搞得很头疼，其实只要搞明白源头，搞明白为什么要进行坐标系变换，搞明白坐标系变换的本质，就不难理解了。</p><p>其实说白了，<strong>坐标系变换就是用不同的方式来表示同一个点</strong>。让我们首先通俗的讲一下这个事情，我想表示二维平面中某一个点，这时我可以用手指或者画一个箭头指向这个点，那你就知道了我想表达的这个点了。但是如果有很多点怎么办，我如果对每一个点都画个箭头，那么就太乱了，这时，坐标系就出现了。我可以首先建立一个坐标，确定了原点所在的位置和两个轴的方向，然后我把这个坐标系告诉你，这样咱俩都知道了同一个坐标系，以后再相互表达某些点的时候，只需要讲这些点的坐标就可以了，你可以根据坐标，在提前商量好的坐标系中快速地找到这些点。但是，如果你和我都有自己喜欢的坐标系，而且这两个坐标系不一样，不是同一个坐标系，那么我将某个点的坐标告诉你，你在你喜欢的坐标系上是无法准确找到这个点的，这时就需要坐标变换了。所以<strong>坐标变换就是用不同的坐标系去表达同一个点</strong>。</p><h2 id="2-四旋翼建模"><a href="#2-四旋翼建模" class="headerlink" title="2. 四旋翼建模"></a><strong>2. 四旋翼建模</strong></h2><h2 id="2-1-四旋翼的状态量"><a href="#2-1-四旋翼的状态量" class="headerlink" title="2.1 四旋翼的状态量"></a><strong>2.1 四旋翼的状态量</strong></h2><p>首先我们使用到的四旋翼的状态量有18个量：</p><ul><li>位置（全局坐标系）： <img src="https://www.zhihu.com/equation?tex=%5Cbold%7Bp%7D%5E%5Cmathrm%7Bg%7D=%5Bx,y,z%5D%5ET" alt="[公式]"> </li><li>速度（全局坐标系）： <img src="https://www.zhihu.com/equation?tex=%5Cbold%7Bv%7D%5E%5Cmathrm%7Bg%7D+=+%5Bv_x,v_y,v_z%5D%5ET" alt="[公式]"></li><li>加速度（全局坐标系）： <img src="https://www.zhihu.com/equation?tex=%5Cbold%7Ba%7D%5E%5Cmathrm%7Bg%7D=%5Ba_x,a_y,a_z%5D%5ET" alt="[公式]"> </li><li>姿态角： <img src="https://www.zhihu.com/equation?tex=%5CTheta+=%5B%5Cphi,%5Ctheta,%5Cpsi%5D%5ET" alt="[公式]"> , (roll, pitch, yaw)</li><li>机体旋转角速度： <img src="https://www.zhihu.com/equation?tex=%5Cbold%7B%5Comega%7D%5Eb=%5Bp,q,r%5D%5ET" alt="[公式]"> </li><li>机体旋转角加速度： <img src="https://www.zhihu.com/equation?tex=%5Cbold%7B%5Cdot%7B%5Comega%7D%7D%5Eb=%5B%5Cdot%7Bp%7D,%5Cdot%7Bq%7D,%5Cdot%7Br%7D%5D%5ET" alt="[公式]"> </li></ul><p>其中姿态角是机体坐标系相对于全局坐标系的三个欧拉角，机体角速度和机体角加速度都是机体坐标系下的。</p><h2 id="2-2-四旋翼6自由度模型-动力学模型与运动学模型"><a href="#2-2-四旋翼6自由度模型-动力学模型与运动学模型" class="headerlink" title="2.2 四旋翼6自由度模型 - 动力学模型与运动学模型"></a><strong>2.2 四旋翼6自由度模型 - 动力学模型与运动学模型</strong></h2><p>四旋翼非线性建模分为运动学模型和动力学模型两部分。6自由度模型的意思是四旋翼有6个自由度，分别是3个方向的移动和3个方向的转动。下面将6自由度模型的公式罗列出来，本文不进行细节方面详细的讲解，只讲明白怎么使用。</p><ul><li>运动学模型</li></ul><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Baligned%7D+%5Cbold%7B%5Cdot%7Bp%7D%7D%5Eg&=%5Cbold%7Bv%7D%5Eg+%5C%5C+%5Cbold%7B%5Cdot%7B%5CTheta%7D%7D&=%5Cbold%7BW%7D%5Ccdot+%5Cbold%7B%5Comega%7D%5Eb+%5Cend%7Baligned%7D" alt="[公式]"></p><ul><li>动力学模型</li></ul><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Baligned%7D+%5Cbold%7B%5Cdot%7Bv%7D%7D&=g%5Cbold%7Be%7D_3-%5Cdfrac%7Bf%7D%7Bm%7D%5Cbold%7BR%7D%5E%7Bb2g%7D%5Cbold%7Be%7D_3%5C%5C+%5Cbold%7BJ%7D%5Ccdot+%5Cdot%7B%5Cbold%7B%5Comega%7D%7D%5Eb&=-%5Cbold%7B%5Comega%7D%5Eb%5Ctimes(%5Cbold%7BJ%7D%5Ccdot%5Cbold%7B%5Comega%7D%5Eb)+%5Cbold%7BG%7D_a+%5Cbold%7B%5Cbold%7B%5Ctau%7D%7D+%5Cend%7Baligned%7D" alt="[公式]"></p><ul><li><p>其中符号的解释</p></li><li><ul><li><p><img src="https://www.zhihu.com/equation?tex=%5Cbold%7Bp%7D%5Eg" alt="[公式]"> 和 <img src="https://www.zhihu.com/equation?tex=%5Cbold%7Bv%7D%5Eg" alt="[公式]"> 分别是飞机的全局位置和全局速度；</p></li><li><p><img src="https://www.zhihu.com/equation?tex=%5Cbold%7BW%7D" alt="[公式]"> 是表示姿态角速率与机体角速度之间关系的矩阵，</p><p> <img src="https://www.zhihu.com/equation?tex=%5Cbold%7BW%7D=+%5Cleft%5B+%5Cbegin%7Bmatrix%7D+1+&+%5Ctan%5Ctheta+%5Csin%5Cphi+&+%5Ctan%5Ctheta%5Ccos%5Cphi+%5C%5C+0+&+%5Ccos%5Cphi+&+-%5Csin%5Cphi+%5C%5C+0+&+%5Csin%5Cphi/%5Ccos%5Ctheta+&+%5Ccos%5Cphi/%5Ccos%5Ctheta+%5Cend%7Bmatrix%7D+%5Cright%5D" alt="[公式]"></p></li></ul></li></ul><p>应避免 <img src="https://www.zhihu.com/equation?tex=%5Ccos%5Ctheta=0" alt="[公式]"> ​的情况发生。<br>反过来可以得到：​ <img src="https://www.zhihu.com/equation?tex=%5Cbold%7B%5Comega%7D%5Eb=%5Cbold%7BW%7D%5E%7B-1%7D%5Cdot%7B%5CTheta%7D" alt="[公式]"></p><p>​            <img src="https://www.zhihu.com/equation?tex=+%09%09%09%09+%09%09%09%09+%09%09%09%09%5Cbold%7BW%7D%5E%7B-1%7D=2%5Cleft%5B3%5Cbegin%7Bmatrix%7D41+&+0+&+-%5Csin%5Ctheta+%5C%5C50+&+%5Ccos%5Cphi+&+%5Ccos%5Ctheta%5Csin%5Cphi+%5C%5C60+&+-%5Csin%5Cphi+&+%5Ccos%5Ctheta%5Ccos%5Cphi7%5Cend%7Bmatrix%7D8%5Cright%5D" alt="[公式]"></p><ul><li><ul><li> <img src="https://www.zhihu.com/equation?tex=%5Cdot%7B%5Cbold%7B%5CTheta%7D%7D" alt="[公式]"> 是姿态角速率， <img src="https://www.zhihu.com/equation?tex=%5Comega%5Eb" alt="[公式]"> 是机体角速度；</li><li> <img src="https://www.zhihu.com/equation?tex=%5Cbold%7Be%7D_3=%5B0,0,1%5D%5ET" alt="[公式]"> 表示单位列向量;</li><li> <img src="https://www.zhihu.com/equation?tex=f" alt="[公式]"> 是四个电机的拉力总和，方向沿机体坐标系z轴负方向；</li><li> <img src="https://www.zhihu.com/equation?tex=%5Cbold%7BJ%7D" alt="[公式]"> 是四旋翼的惯性矩阵， <img src="https://www.zhihu.com/equation?tex=%5Cbold%7BJ%7D=diag(J_x,J_y,J_z)" alt="[公式]"> </li><li> <img src="https://www.zhihu.com/equation?tex=%5Cbold%7BG%7D_a" alt="[公式]"> 表示陀螺力矩，一般忽略不计；</li><li> <img src="https://www.zhihu.com/equation?tex=%5Cbold%7B%5Ctau%7D=%5B%5Ctau_x,%5Ctau_y,%5Ctau_z%5D" alt="[公式]"> 表示螺旋桨在机体轴上产生的外力矩。</li></ul></li></ul><h2 id="2-3-四旋翼6自由度模型的使用"><a href="#2-3-四旋翼6自由度模型的使用" class="headerlink" title="2.3 四旋翼6自由度模型的使用"></a><strong>2.3 四旋翼6自由度模型的使用</strong></h2><p>有了6自由度模型，输入飞机的整体拉力（ <img src="https://www.zhihu.com/equation?tex=f" alt="[公式]"> ）和3个方向的力矩（ <img src="https://www.zhihu.com/equation?tex=%5Ctau" alt="[公式]"> ），再加上上一时刻四旋翼的状态，就可以计算出下一时刻四旋翼的状态量（位置、速度、加速度、姿态角、机体角速率、机体角加速度）。</p><p>从写代码的计算过程来看，先使用动力学模型两个公式，输入拉力和力矩（ <img src="https://www.zhihu.com/equation?tex=f" alt="[公式]"> , <img src="https://www.zhihu.com/equation?tex=%5Ctau" alt="[公式]"> ），计算飞机的加速度（ <img src="https://www.zhihu.com/equation?tex=%5Cbold%7B%5Cdot%7Bv%7D%7D" alt="[公式]"> ）和角加速度( <img src="https://www.zhihu.com/equation?tex=%5Cdot%7B%5Cbold%7B%5Comega%7D%7D%5Eb" alt="[公式]"> )，然后再使用运动学模型的两个公式，更新其他状态量。</p><h2 id="2-4-四旋翼电机模型"><a href="#2-4-四旋翼电机模型" class="headerlink" title="2.4 四旋翼电机模型"></a><strong>2.4 四旋翼电机模型</strong></h2><p>电机模型是用来对电机建模的，因为电机的响应非常快，所以可以忽略电机的延迟，等效认为对电机的转速指令能够瞬间达到。</p><p>四旋翼分为X型和十字型，分析过程相似，本文使用X型四旋翼来推导，</p><ul><li>四个电机的id号定义如下：(向上为前进方向)</li></ul><p><img src="https://pic2.zhimg.com/80/v2-1e5ef3aa664fe35bcddcbbff2e27a45d_1440w.jpg" alt="img"></p><ul><li><p>力、力矩与电机转速的转换如下：</p><p> <img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Baligned%7D+f&=c_T(%5Comega_1%5E2+%5Comega_2%5E2+%5Comega_3%5E2+%5Comega_4%5E2)%5C%5C+%5Ctau_x+&=lc_T(%5Cdfrac%7B%5Csqrt%7B2%7D%7D%7B2%7D%5Comega_1%5E2-%5Cdfrac%7B%5Csqrt%7B2%7D%7D%7B2%7D%5Comega_2%5E2-%5Cdfrac%7B%5Csqrt%7B2%7D%7D%7B2%7D%5Comega_3%5E2+%5Cdfrac%7B%5Csqrt%7B2%7D%7D%7B2%7D%5Comega_4%5E2)+%5C%5C+%5Ctau_y+&=lc_T(%5Cdfrac%7B%5Csqrt%7B2%7D%7D%7B2%7D%5Comega_1%5E2+%5Cdfrac%7B%5Csqrt%7B2%7D%7D%7B2%7D%5Comega_2%5E2-%5Cdfrac%7B%5Csqrt%7B2%7D%7D%7B2%7D%5Comega_3%5E2-%5Cdfrac%7B%5Csqrt%7B2%7D%7D%7B2%7D%5Comega_4%5E2)%5C%5C+%5Ctau_z+&=+c_M(%5Comega_1%5E2-%5Comega_2%5E2+%5Comega_3%5E2-%5Comega_4%5E2)+%5Cend%7Baligned%7D" alt="[公式]"></p></li></ul><p>其中， <img src="https://www.zhihu.com/equation?tex=l" alt="[公式]"> 为机体中心到任一电机的距离， <img src="https://www.zhihu.com/equation?tex=c_T" alt="[公式]"> 为拉力系数， <img src="https://www.zhihu.com/equation?tex=c_M" alt="[公式]"> 为扭矩系数。</p><h2 id="3-四旋翼底层飞控"><a href="#3-四旋翼底层飞控" class="headerlink" title="3. 四旋翼底层飞控"></a><strong>3. 四旋翼底层飞控</strong></h2><h2 id="3-1-四旋翼底层飞控结构图"><a href="#3-1-四旋翼底层飞控结构图" class="headerlink" title="3.1 四旋翼底层飞控结构图"></a><strong>3.1 四旋翼底层飞控结构图</strong></h2><p>一般四旋翼的底层飞控都是用PID控制器，我这里在内环姿态回路用了LQR控制器，底层控制器整体结构图如下：</p><p><img src="https://pic2.zhimg.com/80/v2-66e3d3bea01271615f2e0c07bd21ab25_1440w.jpg" alt="img"></p><h2 id="3-2-简化的线性模型"><a href="#3-2-简化的线性模型" class="headerlink" title="3.2 简化的线性模型"></a><strong>3.2 简化的线性模型</strong></h2><p>在设计控制器之前，首先要对6自由度非线性模型进行线性化，这样设计出来控制器以后，可以先用线性化的模型计算控制器的收敛性，以此判断控制设计的好不好。最后再用设计好的控制器去控制非线性模型。</p><ul><li><p>假设条件：</p></li><li><ul><li><p>动力学模型忽略 <img src="https://www.zhihu.com/equation?tex=-%5Cbold%7B%5Comega%7D%5Eb%5Ctimes(%5Cbold%7BJ%7D%5Ccdot%5Cbold%7B%5Comega%7D%5Eb)+%5Cbold%7BG%7D_a" alt="[公式]"> </p></li><li><p>俯仰角和滚转角都非常小：</p></li><li><ul><li> <img src="https://www.zhihu.com/equation?tex=%5Csin(%5Cphi)%5Capprox+%5Cphi" alt="[公式]"></li><li> <img src="https://www.zhihu.com/equation?tex=%5Ccos(%5Cphi)%5Capprox+1" alt="[公式]"></li><li> <img src="https://www.zhihu.com/equation?tex=%5Csin(%5Ctheta)%5Capprox+%5Ctheta" alt="[公式]"></li><li> <img src="https://www.zhihu.com/equation?tex=%5Ccos(%5Ctheta)%5Capprox+1" alt="[公式]"></li></ul></li><li><p>总拉力约等于四旋翼的重力： <img src="https://www.zhihu.com/equation?tex=f%5Capprox+mg" alt="[公式]"></p></li><li><p>此时，运动学模型中的 <img src="https://www.zhihu.com/equation?tex=%5Cbold%7BW%7D%5Capprox%5Cbold%7BI%7D_3" alt="[公式]"></p></li><li><p>此时，动力学模型中的 <img src="https://www.zhihu.com/equation?tex=%5Cbold%7BR%7D%5E%7Bb2g%7D%5Cbold%7Be%7D_3%5Capprox+%5Cleft%5B%5Cbegin%7Bmatrix%7D+%5Ctheta%5Ccos%5Cpsi+%5Cphi%5Csin%5Cpsi+%5C%5C+%5Ctheta%5Csin%5Cpsi-%5Cphi%5Ccos%5Cpsi+%5C%5C+1+%5Cend%7Bmatrix%7D%5Cright%5D" alt="[公式]"></p></li></ul></li></ul><p>最终，忽略高阶项，原始模型解耦为三个线性模型：水平位置通道模型、高度通道模型、姿态模型</p><ul><li><p>水平位置通道模型： <img src="https://www.zhihu.com/equation?tex=%5Cleft%5C%7B%5Cbegin%7Baligned%7D+%5Cdot%7B%5Cbold%7Bp%7D%7D_h+&=+%5Cbold%7Bv%7D_h+%5C%5C+%5Cdot%7B%5Cbold%7Bv%7D%7D_h+&=+-g%5Cbold%7BA%7D_%5Cpsi%5Cbold%7B%5CTheta%7D_h+%5Cend%7Baligned%7D%5Cright." alt="[公式]"></p><p>其中， <img src="https://www.zhihu.com/equation?tex=%5Cbold%7Bp%7D_h=%5Cleft%5B%5Cbegin%7Bmatrix%7Dx%5C%5Cy%5Cend%7Bmatrix%7D%5Cright%5D" alt="[公式]">    <img src="https://www.zhihu.com/equation?tex=%5Cbold%7BA%7D_%5Cpsi=%5Cleft%5B%5Cbegin%7Bmatrix%7D%5Csin%5Cpsi+&+%5Ccos%5Cpsi+%5C%5C+-%5Ccos%5Cpsi+&+%5Csin%5Cpsi%5Cend%7Bmatrix%7D%5Cright%5D" alt="[公式]">       <img src="https://www.zhihu.com/equation?tex=%5Cbold%7B%5CTheta%7D_h=%5Cleft%5B%5Cbegin%7Bmatrix%7D%5Cphi%5C%5C+%5Ctheta%5Cend%7Bmatrix%7D%5Cright%5D" alt="[公式]"> </p></li><li><p>高度通道模型： <img src="https://www.zhihu.com/equation?tex=%5Cleft%5C%7B%5Cbegin%7Baligned%7D+%5Cdot%7Bz%7D+&=+v_z+%5C%5C+%5Cdot%7Bv%7D_z+&=+g-%5Cdfrac%7Bf%7D%7Bm%7D+%5Cend%7Baligned%7D%5Cright." alt="[公式]"></p></li><li><p>姿态模型： <img src="https://www.zhihu.com/equation?tex=%5Cleft%5C%7B%5Cbegin%7Baligned%7D+%5Cdot%7B%5Cbold%7B%5CTheta%7D%7D+&=+%5Cbold%7B%5Comega%7D+%5C%5C+%5Cbold%7BJ%7D%5Cdot%7B%5Cbold%7B%5Comega%7D%7D+&=+%5Cbold%7B%5Ctau%7D+%5Cend%7Baligned%7D%5Cright." alt="[公式]"></p></li></ul><h2 id="3-3-外环PID控制器"><a href="#3-3-外环PID控制器" class="headerlink" title="3.3 外环PID控制器"></a><strong>3.3 外环PID控制器</strong></h2><p>外环PID分为水平和垂直两个解耦的控制器。</p><p><strong>外环水平通道PID控制器</strong></p><p>外环水平通道控制器有三种情况：输入指令可以是，位置、速度、加速度。</p><ul><li><p>输入：期望水平方向的指令（三选一）位置、速度、加速度， <img src="https://www.zhihu.com/equation?tex=(p_h)_%7Bcmd%7D=%5Bx_%7Bcmd%7D,y_%7Bcmd%7D%5D%5ET" alt="[公式]"> <img src="https://www.zhihu.com/equation?tex=(%5Cbold%7Bv%7D_h)_%7Bcmd%7D=%5B(v_x)_%7Bcmd%7D,(v_y)_%7Bcmd%7D%5D%5ET" alt="[公式]"> , <img src="https://www.zhihu.com/equation?tex=(a_h)_%7Bcmd%7D=%5B(a_x)_%7Bcmd%7D,(a_y)_%7Bcmd%7D%5D%5ET" alt="[公式]"> </p></li><li><p>输出（给内环）：期望俯仰和滚转姿态角 <img src="https://www.zhihu.com/equation?tex=%5Cphi_%7Bdes%7D,%5Ctheta_%7Bdes%7D" alt="[公式]"> </p></li><li><p>控制器设计：</p></li><li><ul><li><p>位置控制：</p></li><li><ul><li><img src="https://www.zhihu.com/equation?tex=(%5Cbold%7Bv%7D_h)_%7Bdes%7D=%5Cbold%7BK%7D_%7Bp_h%7D%5Cleft((%5Cbold%7Bp%7D_h)_%7Bcmd%7D-%5Cbold%7Bp%7D_h%5Cright)" alt="[公式]"> , P控制器， 其中 <img src="https://www.zhihu.com/equation?tex=(%5Cbold%7Bv%7D_h)_%7Bdes%7D" alt="[公式]"> 要限幅</li><li><img src="https://www.zhihu.com/equation?tex=(%5Cbold%7Ba%7D_h)_%7Bdes%7D=(%5Cbold%7BK%7D_%7B%5Cbold%7Bv%7D_hp%7D%5Cbold%7Be%7D_%7B%5Cbold%7Bv%7D_h%7D+%5Cbold%7BK%7D_%7B%5Cbold%7Bv%7D_hi%7D%5Cint%5Cbold%7Be%7D_%7B%5Cbold%7Bv%7D_h%7D+%5Cbold%7BK%7D_%7B%5Cbold%7Bv%7D_hd%7D%5Cdot%7B%5Cbold%7Be%7D%7D_%7B%5Cbold%7Bv%7D_h%7D)" alt="[公式]"> , PID控制器，一般用PI即可，其中 <img src="https://www.zhihu.com/equation?tex=(%5Cbold%7Ba%7D_h)_%7Bdes%7D" alt="[公式]"> 要限幅</li><li><img src="https://www.zhihu.com/equation?tex=(%5Cbold%7B%5CTheta%7D_h)_%7Bdes%7D=g%5E%7B-1%7D%5Cbold%7BA%7D_%5Cpsi%5E%7B-1%7D(-%5Cbold%7Ba%7D_h)_%7Bdes%7D" alt="[公式]"> , 其中 <img src="https://www.zhihu.com/equation?tex=(%5Cbold%7B%5CTheta%7D_h)_%7Bdes%7D" alt="[公式]"> 要限幅。</li><li>其中 <img src="https://www.zhihu.com/equation?tex=%5Cbold%7BK%7D_%7Bp_h%7D,%5Cbold%7BK%7D_%7B%5Cbold%7Bv%7D_hp%7D,%5Cbold%7BK%7D_%7B%5Cbold%7Bv%7D_hi%7D,%5Cbold%7BK%7D_%7B%5Cbold%7Bv%7D_hd%7D%5Cin+R%5E%7B2%5Ctimes2%7D" alt="[公式]"> 是系数;<img src="https://www.zhihu.com/equation?tex=%5Cbold%7Be%7D_%7B%5Cbold%7Bv%7D_h%7D=(%5Cbold%7Bv%7D_h)_%7Bdes%7D-%5Cbold%7Bv%7D_h" alt="[公式]"></li></ul></li><li><p>速度控制：</p></li><li><ul><li><img src="https://www.zhihu.com/equation?tex=+(%5Cbold%7Ba%7D_h)_%7Bdes%7D=(%5Cbold%7BK%7D_%7B%5Cbold%7Bv%7D_hp%7D%5Cbold%7Be%7D_%7B%5Cbold%7Bv%7D_h%7D+%5Cbold%7BK%7D_%7B%5Cbold%7Bv%7D_hi%7D%5Cint%5Cbold%7Be%7D_%7B%5Cbold%7Bv%7D_h%7D+%5Cbold%7BK%7D_%7B%5Cbold%7Bv%7D_hd%7D%5Cdot%7B%5Cbold%7Be%7D%7D_%7B%5Cbold%7Bv%7D_h%7D)" alt="[公式]"> , PID控制器，一般用PI即可，其中 <img src="https://www.zhihu.com/equation?tex=(%5Cbold%7Ba%7D_h)_%7Bdes%7D" alt="[公式]"> 要限幅</li><li><img src="https://www.zhihu.com/equation?tex=(%5Cbold%7B%5CTheta%7D_h)_%7Bdes%7D=-g%5E%7B-1%7D%5Cbold%7BA%7D_%5Cpsi%5E%7B-1%7D(%5Cbold%7Ba%7D_h)_%7Bdes%7D" alt="[公式]"> , 其中 <img src="https://www.zhihu.com/equation?tex=(%5Cbold%7B%5CTheta%7D_h)_%7Bdes%7D" alt="[公式]"> 要限幅。</li><li>其中， <img src="https://www.zhihu.com/equation?tex=%5Cbold%7BK%7D_%7B%5Cbold%7Bv%7D_hp%7D,%5Cbold%7BK%7D_%7B%5Cbold%7Bv%7D_hi%7D,%5Cbold%7BK%7D_%7B%5Cbold%7Bv%7D_hd%7D%5Cin+R%5E%7B2%5Ctimes2%7D" alt="[公式]"> 是系数; <img src="https://www.zhihu.com/equation?tex=%5Cbold%7Be%7D_%7B%5Cbold%7Bv%7D_h%7D=(%5Cbold%7Bv%7D_h)_%7Bcmd%7D-%5Cbold%7Bv%7D_h" alt="[公式]"> </li></ul></li><li><p>加速度控制：</p></li><li><ul><li><img src="https://www.zhihu.com/equation?tex=(%5Cbold%7B%5CTheta%7D_h)_%7Bdes%7D=-g%5E%7B-1%7D%5Cbold%7BA%7D_%5Cpsi%5E%7B-1%7D(%5Cbold%7Ba%7D_h)_%7Bcmd%7D" alt="[公式]"> , 其中 <img src="https://www.zhihu.com/equation?tex=(%5Cbold%7B%5CTheta%7D_h)_%7Bdes%7D" alt="[公式]"> 要限幅。</li></ul></li></ul></li><li><p>限幅：</p></li><li><ul><li>输入限幅： <img src="https://www.zhihu.com/equation?tex=%7C%7C(%5Cbold%7Bv%7D_h)_%7Bdes%7D%7C%7C%5Cle+%5Cmax+v_h" alt="[公式]"> </li><li>输出限幅： <img src="https://www.zhihu.com/equation?tex=%5Cphi_%7Bdes%7D,%5Ctheta_%7Bdes%7D%5Cle+%5Cmax+%5Ctheta" alt="[公式]"> </li></ul></li></ul><p><strong>外环高度通道PID控制器</strong></p><ul><li><p>输入：期望高度 <img src="https://www.zhihu.com/equation?tex=z_%7Bdes%7D" alt="[公式]"> </p></li><li><p>输出：拉力 <img src="https://www.zhihu.com/equation?tex=f_%7Bdes%7D" alt="[公式]"> </p></li><li><p>控制器设计： <img src="https://www.zhihu.com/equation?tex=f_%7Bdes%7D=m(g+k_%7Bv_zp%7De_%7Bv_z%7D+k_%7Bv_zi%7D%5Cint+e_%7Bv_z%7D)" alt="[公式]"></p><p>其中， <img src="https://www.zhihu.com/equation?tex=k_%7Bv_zp%7D" alt="[公式]"> ,  <img src="https://www.zhihu.com/equation?tex=k_%7Bv_zi%7D" alt="[公式]"> 是系数， <img src="https://www.zhihu.com/equation?tex=e_%7Bv_z%7D=v_z-(v_z)_%7Bdes%7D" alt="[公式]"> 是速度差，<br>其中， <img src="https://www.zhihu.com/equation?tex=(v_z)_%7Bdes%7D=-k_z(z-z_%7Bdes%7D)" alt="[公式]"> ​</p></li><li><p>限幅： <img src="https://www.zhihu.com/equation?tex=(v_z)_%7Bdes%7D%5Cle%5Cmax+z_v" alt="[公式]"> , <img src="https://www.zhihu.com/equation?tex=f_%7Bdes%7D%5Cle%5Cmax+f" alt="[公式]"> </p></li></ul><h2 id="3-4-内环LQR控制器"><a href="#3-4-内环LQR控制器" class="headerlink" title="3.4 内环LQR控制器"></a><strong>3.4 内环LQR控制器</strong></h2><p><strong>输入输出</strong></p><ul><li>输入1（外环）：期望的俯仰滚转角， <img src="https://www.zhihu.com/equation?tex=%5Cphi_%7Bdes%7D,%5Ctheta_%7Bdes%7D" alt="[公式]"> </li><li>输入2：期望的偏航角 <img src="https://www.zhihu.com/equation?tex=%5Cpsi_%7Bdes%7D" alt="[公式]"> </li><li>输出：力矩， <img src="https://www.zhihu.com/equation?tex=%5Cbold%7B%5Ctau%7D_%7Bdes%7D" alt="[公式]"> </li></ul><p><strong>控制器设计</strong></p><ul><li><p>状态方程：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cleft%5B%5Cbegin%7Bmatrix%7D+%5Cdot%7B%5Cphi%7D+%5C%5C+%5Cdot%7B%5Ctheta%7D+%5C%5C+%5Cdot%7B%5Cpsi%7D+%5C%5C+%5Cdot%7Bp%7D%5C%5C+%5Cdot%7Bq%7D%5C%5C+%5Cdot%7Br%7D+%5Cend%7Bmatrix%7D%5Cright%5D=+%5Cleft%5B%5Cbegin%7Bmatrix%7D+0&0&0&1+&+%5Ctan%5Ctheta+%5Csin%5Cphi+&+%5Ctan%5Ctheta%5Ccos%5Cphi+%5C%5C+0&0&0&0+&+%5Ccos%5Cphi+&+-%5Csin%5Cphi+%5C%5C+0&0&0&0+&+%5Csin%5Cphi/%5Ccos%5Ctheta+&+%5Ccos%5Cphi/%5Ccos%5Ctheta+%5C%5C+0&0&0&0&0&0%5C%5C+0&0&0&0&0&0%5C%5C+0&0&0&0&0&0+%5Cend%7Bmatrix%7D%5Cright%5D+%5Cleft%5B%5Cbegin%7Bmatrix%7D+%5Cphi+%5C%5C+%5Ctheta+%5C%5C+%5Cpsi+%5C%5C+p%5C%5C+q%5C%5C+r+%5Cend%7Bmatrix%7D%5Cright%5D++%5Cleft%5B%5Cbegin%7Bmatrix%7D+0&0&0%5C%5C+0&0&0%5C%5C+0&0&0%5C%5C+1/J_x&0&0+%5C%5C+0&+1/J_y+&+0%5C%5C+0&0&1/J_z+%5Cend%7Bmatrix%7D%5Cright%5D+%5Cleft%5B%5Cbegin%7Bmatrix%7D+%5Ctau_x%5C%5C+%5Ctau_y%5C%5C+%5Ctau_z+%5Cend%7Bmatrix%7D%5Cright%5D" alt="[公式]"><br><img src="https://www.zhihu.com/equation?tex=%5Cdot%7Bx%7D=Ax+Bu" alt="[公式]"></p></li><li><ul><li>其中， <img src="https://www.zhihu.com/equation?tex=x=%5B%5Cphi,%5Ctheta,%5Cpsi,p,q,r%5D%5ET" alt="[公式]"> </li><li><img src="https://www.zhihu.com/equation?tex=u=%5B%5Ctau_x,%5Ctau_y,%5Ctau_z%5D%5ET" alt="[公式]"> </li><li><img src="https://www.zhihu.com/equation?tex=A=%5Cleft%5B%5Cbegin%7Bmatrix%7D%5Cbold%7B0%7D&%5Cbold%7BW%7D%5C%5C%5Cbold%7B0%7D&%5Cbold%7B0%7D%5Cend%7Bmatrix%7D%5Cright%5D" alt="[公式]"> </li><li> <img src="https://www.zhihu.com/equation?tex=B=%5Cleft%5B%5Cbegin%7Bmatrix%7D%5Cbold%7B0%7D%5C%5C+%5Cbold%7BJ%7D%5E%7B-1%7D%5Cend%7Bmatrix%7D%5Cright%5D" alt="[公式]"></li></ul></li><li><p>两个矩阵的参数选择： <img src="https://www.zhihu.com/equation?tex=Q=diag%5C%7B8,8,2,+2,+2,+0.1%5C%7D" alt="[公式]"> , <img src="https://www.zhihu.com/equation?tex=R=diag%5C%7B1,1,1%5C%7D" alt="[公式]"> </p></li><li><p>求中间矩阵 <img src="https://www.zhihu.com/equation?tex=P" alt="[公式]"> ，解方程： <img src="https://www.zhihu.com/equation?tex=A%5ETP+PA+Q-PBR%5E%7B-1%7DB%5ETP=0" alt="[公式]"> </p></li><li><p>解出系数矩阵 <img src="https://www.zhihu.com/equation?tex=K" alt="[公式]"> :  <img src="https://www.zhihu.com/equation?tex=K=R%5E%7B-1%7DB%5ETP" alt="[公式]"> </p></li><li><p>最后的解为：<br><img src="https://www.zhihu.com/equation?tex=%5Cbold%7B%5Ctau%7D_%7Bdes%7D=-K(x-x_%7Bdes%7D)" alt="[公式]"></p></li><li><p>限幅： <img src="https://www.zhihu.com/equation?tex=%5Cphi_%7Bdes%7D,%5Ctheta_%7Bdes%7D+%5Cle+%5Cmax%5Ctheta" alt="[公式]"> ,  <img src="https://www.zhihu.com/equation?tex=%5Ctau_%7Bdes%7D%5Cle+%5Cmax+%5Ctau" alt="[公式]"></p></li></ul><h2 id="4-四旋翼参数参考"><a href="#4-四旋翼参数参考" class="headerlink" title="4. 四旋翼参数参考"></a><strong>4. 四旋翼参数参考</strong></h2><p>下面列举的参数是我再仿真中用的参数，可以用来参考。</p><ul><li>参考3dr Robotics</li></ul><table><thead><tr><th>参数</th><th>数据 值/范围</th></tr></thead><tbody><tr><td>质量（kg）</td><td>1.4</td></tr><tr><td>轴距 (m)</td><td>0.56</td></tr><tr><td>转动惯量 (x,y,z) (kg/m^2)</td><td>[0.05,0.05,0.24]</td></tr><tr><td>滚转和俯仰角</td><td>-30 ~ 30</td></tr><tr><td>拉力 (N)</td><td>0 ~ 43.5</td></tr><tr><td>力矩 (x,y) (N.m)</td><td>-6.25 ~ 6.25</td></tr><tr><td>力矩 z</td><td>-2.25 ~ 2.25</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> UAV Simulation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UAV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>namespcae</title>
      <link href="2021/11/25/namespcae/"/>
      <url>2021/11/25/namespcae/</url>
      
        <content type="html"><![CDATA[<h1 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h1><ul><li>namespace用于解决命名冲突问题</li><li>namespace必须放在全局作用域下</li><li>命名空间下可以放变量、结构体、类、函数</li><li>命名空间可以嵌套命名空间</li><li>命名空间是开放的，可以随时往原来的命名空间添加内容</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A &#123;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> A &#123;  <span class="comment">// 此命名空间会和上面的命名空间合并</span></span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>无名/匿名命名空间相当与写了static，只能在当前文件内使用</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"><span class="keyword">int</span> m_A = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> m_B = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 相当于写了static int m_A; static int m_B;</span></span><br></pre></td></tr></table></figure><ul><li>命名空间可以起别名</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> veryLongName &#123;</span><br><span class="line">    <span class="keyword">int</span> m_A = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> test01 &#123;</span><br><span class="line"><span class="keyword">namespace</span> veryShortName = veryLongName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> namespace </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象</title>
      <link href="2021/11/25/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>2021/11/25/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p>面向对象编程的思想核心：功能分解，自上而下，逐层细化<font color=red>（程序=数据结构+算法）</font></p><h1 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h1><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>把客观事物封装成抽象的类。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>表达的是类之间的关系，对象可以继承另一个对象的特征和能力。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>一个接口，多种方法，程序在运行时才决定调用的方法。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="2021/11/24/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>2021/11/24/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>inline函数</title>
      <link href="2021/11/24/%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"/>
      <url>2021/11/24/%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="内联函数的引出–宏函数的缺陷"><a href="#内联函数的引出–宏函数的缺陷" class="headerlink" title="内联函数的引出–宏函数的缺陷"></a>内联函数的引出–宏函数的缺陷</h1><ul><li><p>第一个问题在c中也会出现的，宏看起来像一个函数调用，但是有一些隐藏的难以发现的错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MyAdd(int a, int b) a+b</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">MyAdd</span>(a, b) &lt;&lt; endl;  <span class="comment">// 输出30；</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">MyAdd</span>(a, b) * <span class="number">10</span> &lt;&lt; endl;  <span class="comment">// 预期结果300，但是输出210； </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MyCompare(int a, int b) a &gt; b ? a : b</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">MyCompare</span>(a, b); <span class="comment">// 输出 20；</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">MyCompare</span>(++a, b); <span class="comment">// 预期21，输出22；</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>第二个问题是C++特有的，预处理器不能访问类的成员，所以预处理宏不能用作类的成员函数。</p></li><li><p>宏函数没有作用域。</p></li></ul><h1 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h1><ul><li>内联函数是一个真正的函数。</li><li>内联函数的声明和实现都需要加inline，否则会被认为成普通函数处理。</li><li>内联函数相当于空间换时间。</li><li>类内部的成员函数，默认前面会加inline关键字，即如果函数定义在类内部，自动成为内联函数<font color=blue>（同样受到最后一条的限制）</font>。</li><li>注意即使加了inline也不一定会变成内联函数，以下情况不会变成inline：``<ul><li>不能存在任何形式的循环语句；</li><li>不能存在过多的条件判断语句；</li><li>函数体不能过于庞大；</li><li>不能对函数进行取址操作；</li></ul></li></ul><p><font color=red>内联函数只是相当于给了编译器一个建议，但是编译器不一定会接受。</font></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> inline </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="2021/11/13/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>2021/11/13/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>并查集主要用于解决一些<strong>元素分组</strong>的问题。它管理一系列<strong>不相交的集合</strong>，并支持两种操作：</p><ul><li><strong>合并</strong>（Union）：把两个不相交的集合合并为一个集合。</li><li><strong>查询</strong>（Find）：查询两个元素是否在同一个集合中。</li></ul><p>元素之间具有<strong>传递性</strong>的关系以及<strong>只考虑连通性</strong>不考虑距离时，可考虑使用并查集。</p><h1 id="并查集的简介与实现"><a href="#并查集的简介与实现" class="headerlink" title="并查集的简介与实现"></a>并查集的简介与实现</h1><p><font color=red>/<em><strong>以下内容源于知乎，原文链接在末尾</strong></em>/</font></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>并查集的重要思想在于，<strong>用集合中的一个元素代表集合</strong>。我曾看过一个有趣的比喻，把集合比喻成<strong>帮派</strong>，而代表元素则是<strong>帮主</strong>。接下来我们利用这个比喻，看看并查集是如何运作的。</p><p><img src="https://pic4.zhimg.com/v2-09fa3fa35e5411444b327d9cb9a31057_r.jpg"></p><p>最开始，所有大侠各自为战。他们各自的帮主自然就是自己。<em>（对于只有一个元素的集合，代表元素自然是唯一的那个元素）</em></p><p>现在1号和3号比武，假设1号赢了（这里具体谁赢暂时不重要），那么3号就认1号作帮主<em>（合并1号和3号所在的集合，1号为代表元素）</em>。</p><p><img src="https://pic4.zhimg.com/v2-3bf6c1a6ecf87fa93f4dbab2012446c7_r.jpg" alt="img"></p><p>现在2号想和3号比武<em>（合并3号和2号所在的集合）</em>，但3号表示，别跟我打，让我帮主来收拾你<em>（合并代表元素）</em>。不妨设这次又是1号赢了，那么2号也认1号做帮主。</p><p><img src="https://pic4.zhimg.com/80/v2-be12a6c795572d2acd77dcd49de35127_720w.jpg"></p><p>现在我们假设4、5、6号也进行了一番帮派合并，江湖局势变成下面这样：</p><p><img src="https://pic1.zhimg.com/80/v2-3c353bc781c7f3553079d541a9cfdc28_720w.jpg" alt="img"></p><p>现在假设2号想与6号比，跟刚刚说的一样，喊帮主1号和4号出来打一架（帮主真辛苦啊）。1号胜利后，4号认1号为帮主，当然他的手下也都是跟着投降了。</p><p><img src="https://pic3.zhimg.com/80/v2-6362d8b13705d5ba17b19cdeee453022_720w.jpg" alt="img"></p><p>好了，比喻结束了。如果你有一点图论基础，相信你已经觉察到，这是一个<strong>树</strong>状的结构，要寻找集合的代表元素，只需要一层一层往上访问<strong>父节点</strong>（图中箭头所指的圆），直达树的<strong>根节点</strong>（图中橙色的圆）即可。根节点的父节点是它自己。我们可以直接把它画成一棵树：</p><p><img src="https://pic2.zhimg.com/80/v2-cca3ddf5806a221201ed78caf1d27041_720w.jpg" alt="img"></p><p>用这种方法，我们可以写出最简单版本的并查集代码。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fa[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        fa[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如有编号为1, 2, 3, …, n的n个元素，我们用一个数组fa[]来存储每个元素的父节点（因为每个元素有且只有一个父节点，所以这是可行的）。一开始，我们先将它们的父节点设为自己。</p><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x] == x)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们用递归的写法实现对代表元素的查询：一层一层访问父节点，直至根节点（根节点的标志就是父节点是本身）。要判断两个元素是否属于同一个集合，只需要看它们的根节点是否相同即可。</p><h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fa[find(i)] = find(j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合并操作也是很简单的，先找到两个集合的代表元素，然后将前者的父节点设为后者即可。当然也可以将后者的父节点设为前者，这里暂时不重要。本文末尾会给出一个更合理的比较方法。</p><h2 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h2><p>​    最简单的并查集效率是比较低的。例如，来看下面这个场景：</p><p><img src="https://pica.zhimg.com/v2-49b5dd7af650192373e96d29f9c4b8cf_720w.jpg?source=3af55fa1" alt="img"><img src="https://pica.zhimg.com/80/v2-49b5dd7af650192373e96d29f9c4b8cf_720w.jpg?source=3af55fa1" alt="img"></p><p>​    现在我们要merge(2,3)，于是从2找到1，fa[1]=3，于是变成了这样：</p><p><img src="https://pica.zhimg.com/v2-6f85fc7c5578aa20400ac56f0da31e37_720w.jpg?source=3af55fa1" alt="img"><img src="https://pica.zhimg.com/80/v2-6f85fc7c5578aa20400ac56f0da31e37_720w.jpg?source=3af55fa1" alt="img"></p><p>​    然后我们又找来一个元素4，并需要执行merge(2,4)：</p><p><img src="https://pic2.zhimg.com/v2-1d3ef8a42d424cbec76135ce8a494ff7_720w.jpg?source=3af55fa1" alt="img"><img src="https://pic2.zhimg.com/80/v2-1d3ef8a42d424cbec76135ce8a494ff7_720w.jpg?source=3af55fa1" alt="img"></p><p>​        从2找到1，再找到3，然后fa[3]=4，于是变成了这样：</p><p><img src="https://pica.zhimg.com/v2-23c367515ace6fc0603692dfd865849f_720w.jpg?source=3af55fa1" alt="img"><img src="https://pica.zhimg.com/80/v2-23c367515ace6fc0603692dfd865849f_720w.jpg?source=3af55fa1" alt="img"></p><p>​    大家应该有感觉了，这样可能会形成一条长长的<strong>链</strong>，随着链越来越长，我们想要从底部找到根节点会变得越来越难。</p><p>​    怎么解决呢？我们可以使用<strong>路径压缩</strong>的方法。既然我们只关心一个元素对应的<strong>根节点</strong>，那我们希望每个元素到根节点的路径尽可能短，最好只需要一步，像这样：</p><p><img src="https://pic3.zhimg.com/v2-c2f835398a3e54d8209bf5e034ac6820_720w.jpg?source=3af55fa1" alt="img"><img src="https://pic3.zhimg.com/80/v2-c2f835398a3e54d8209bf5e034ac6820_720w.jpg?source=3af55fa1" alt="img"></p><p>​    其实这说来也很好实现。只要我们在查询的过程中，<strong>把沿途的每个节点的父节点都设为根节点</strong>即可。下一次再查询时，我们就可以省很多事。这用递归的写法很容易实现：</p><h3 id="合并（路径压缩）"><a href="#合并（路径压缩）" class="headerlink" title="合并（路径压缩）"></a>合并（路径压缩）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == fa[x])</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        fa[x] = find(fa[x]);  <span class="comment">//父节点设为根节点</span></span><br><span class="line">        <span class="keyword">return</span> fa[x];         <span class="comment">//返回父节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    以上代码常常简写为一行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == fa[x] ? x : (fa[x] = find(fa[x]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    注意赋值运算符=的优先级没有三元运算符?:高，这里要加括号。</p><p>​    路径压缩优化后，并查集的时间复杂度已经比较低了，绝大多数不相交集合的合并查询问题都能够解决。然而，对于某些时间卡得很紧的题目，我们还可以进一步优化。</p><hr><h2 id="按秩合并"><a href="#按秩合并" class="headerlink" title="按秩合并"></a>按秩合并</h2><p>​    有些人可能有一个误解，以为路径压缩优化后，并查集始终都是一个<strong>菊花图</strong>（只有两层的树的俗称）。但其实，由于路径压缩只在查询时进行，也只压缩一条路径，所以并查集最终的结构仍然可能是比较复杂的。例如，现在我们有一棵较复杂的树需要与一个单元素的集合合并：</p><p><img src="https://pic3.zhimg.com/v2-d3ff42bb79a6bc751f47daf3fc70e0d9_720w.jpg?source=3af55fa1" alt="img"><img src="https://pic3.zhimg.com/80/v2-d3ff42bb79a6bc751f47daf3fc70e0d9_720w.jpg?source=3af55fa1" alt="img"></p><p>​    假如这时我们要merge(7,8)，如果我们可以选择的话，是把7的父节点设为8好，还是把8的父节点设为7好呢？</p><p>​    当然是后者。因为如果把7的父节点设为8，会使树的<strong>深度</strong>（树中最长链的长度）加深，原来的树中每个元素到根节点的距离都变长了，之后我们寻找根节点的路径也就会相应变长。虽然我们有路径压缩，但路径压缩也是会消耗时间的。而把8的父节点设为7，则不会有这个问题，因为它没有影响到不相关的节点。</p><p><img src="https://pica.zhimg.com/v2-96fbb25365b43f0a109bec6d55b3b899_720w.jpg?source=3af55fa1" alt="img"><img src="https://pica.zhimg.com/80/v2-96fbb25365b43f0a109bec6d55b3b899_720w.jpg?source=3af55fa1" alt="img"></p><p>​    这启发我们：我们应该把简单的树往复杂的树上合并，而不是相反。因为这样合并后，到根节点距离变长的节点个数比较少。</p><p>​    我们用一个数组rank[]记录每个根节点对应的树的深度（如果不是根节点，其rank相当于以它作为根节点的<strong>子树</strong>的深度）。一开始，把所有元素的rank（<strong>秩</strong>）设为1。合并时比较两个根节点，把rank较小者往较大者上合并。</p><p>路径压缩和按秩合并如果一起使用，时间复杂度接近 <img src="https://www.zhihu.com/equation?tex=O(n)" alt="[公式]"> ，但是很可能会破坏rank的准确性。</p><h3 id="初始化（按秩合并）"><a href="#初始化（按秩合并）" class="headerlink" title="初始化（按秩合并）"></a>初始化（按秩合并）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">        rank[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并（按秩合并）"><a href="#合并（按秩合并）" class="headerlink" title="合并（按秩合并）"></a>合并（按秩合并）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = find(i), y = find(j);    <span class="comment">//先找到两个根节点</span></span><br><span class="line">    <span class="keyword">if</span> (rank[x] &lt;= rank[y])</span><br><span class="line">        fa[x] = y;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fa[y] = x;</span><br><span class="line">    <span class="keyword">if</span> (rank[x] == rank[y] &amp;&amp; x != y)</span><br><span class="line">        rank[y]++;                   <span class="comment">//如果深度相同且根节点不同，则新的根节点的深度+1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    为什么深度相同，新的根节点深度要+1？如下图，我们有两个深度均为2的树，现在要merge(2,5)：</p><p><img src="https://pic1.zhimg.com/v2-de356190829600f438058e8615c7a5ac_720w.jpg?source=3af55fa1" alt="img"><img src="https://pic1.zhimg.com/80/v2-de356190829600f438058e8615c7a5ac_720w.jpg?source=3af55fa1" alt="img"></p><p>​    这里把2的父节点设为5，或者把5的父节点设为2，其实没有太大区别。我们选择前者，于是变成这样：</p><p><img src="https://pic3.zhimg.com/v2-a829932f008f000440942cb8df393662_720w.jpg?source=3af55fa1" alt="img"><img src="https://pic3.zhimg.com/80/v2-a829932f008f000440942cb8df393662_720w.jpg?source=3af55fa1" alt="img"></p><p>​        显然树的深度增加了1。另一种合并方式同样会让树的深度+1。</p><p><a href="https://zhuanlan.zhihu.com/p/93647900/">点我！！这是原文！！！！！！！！！！</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PX4、ROS、Gazebo安装</title>
      <link href="2021/11/03/PX4%E3%80%81ROS%E3%80%81Gazebo%E5%AE%89%E8%A3%85/"/>
      <url>2021/11/03/PX4%E3%80%81ROS%E3%80%81Gazebo%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="安装指南"><a href="#安装指南" class="headerlink" title="安装指南"></a>安装指南</h1><h2 id="前置步骤"><a href="#前置步骤" class="headerlink" title="前置步骤"></a>前置步骤</h2><h3 id="ubuntu换源："><a href="#ubuntu换源：" class="headerlink" title="ubuntu换源："></a>ubuntu换源：</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure><ul><li>以下几个源任选</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#  阿里镜像源</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 清华镜像源</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>更新</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update &amp;&amp; sudo apt-get upgrade</span><br></pre></td></tr></table></figure><h3 id="科学上网"><a href="#科学上网" class="headerlink" title="科学上网"></a>科学上网</h3><p>主机全局代理+虚拟机nat模式+虚拟机代理</p><h2 id="正式步骤"><a href="#正式步骤" class="headerlink" title="正式步骤"></a>正式步骤</h2><h3 id="ROS-MAVROS-Gazebo"><a href="#ROS-MAVROS-Gazebo" class="headerlink" title="ROS+MAVROS+Gazebo"></a>ROS+MAVROS+Gazebo</h3><ol><li><p>获取快速安装脚本，可能出现网络问题，自行百度，科学上网多试几次，换手机网可行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/PX4/Devguide/master/build_scripts/ubuntu_sim_ros_melodic.sh</span><br></pre></td></tr></table></figure></li><li><p>在脚本目录下运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash ubuntu_sim_ros_melodic.sh</span><br></pre></td></tr></table></figure><p>在运行过程中报错</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error downloading <span class="string">&#x27;install_geographiclib_datasets.sh&#x27;</span>. Sorry but I cannot proceed further :(</span><br></pre></td></tr></table></figure><p><a href="https://gitee.com/MrZhaosx/geographic-lib">https://gitee.com/MrZhaosx/geographic-lib</a></p><p>将链接中三个文件夹下载拷贝到 <strong>/usr/share/GeographicLib</strong> 文件夹下面，不能直接拖拽，先放到桌面用命令行sudo操作</p><p>然后运行 </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./install_geographiclib_datasets.sh</span><br></pre></td></tr></table></figure></li></ol><h3 id="PX4"><a href="#PX4" class="headerlink" title="PX4"></a>PX4</h3><ol><li><p>下载PX4源码</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/PX4/PX4-Autopilot.git --recursive</span><br></pre></td></tr></table></figure></li><li><p>运行ubuntu.sh，如果需要nuttx把–no-nuttx去除即可</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash ./PX4-Autopilot/Tools/setup/ubuntu.sh --no-nuttx</span><br></pre></td></tr></table></figure></li><li><p>重启</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> UAV Simulation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gazebo </tag>
            
            <tag> PX4 </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gazebo问题汇总</title>
      <link href="2021/09/24/Gazebo%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
      <url>2021/09/24/Gazebo%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="问题描述1"><a href="#问题描述1" class="headerlink" title="问题描述1"></a>问题描述1</h1><p><img src="https://i.loli.net/2021/09/24/FWRNOJ7iPm6Et5U.png" alt="image.png"></p><h1 id="解决方案1"><a href="#解决方案1" class="headerlink" title="解决方案1"></a>解决方案1</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unset LIBGL_ALWAYS_INDIRECT</span><br></pre></td></tr></table></figure><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>gazebo在Ardupilot下模型加载慢</p><p><img src="https://i.loli.net/2021/09/24/gRT3DWJmY69CUnt.png" alt="image.png"></p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>提前下载模型后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /usr/share/gazebo/setup.sh</span><br></pre></td></tr></table></figure><h1 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h1><p>运行roslaunch 文件报错</p><p><img src="https://i.loli.net/2021/09/24/vJWqMsb6Gx5CitL.png" alt="image.png"></p><h1 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br><span class="line">把自己创建的catwin那个注释掉</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> UAV Simulation </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gazebo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红黑树</title>
      <link href="2021/08/23/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
      <url>2021/08/23/%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p><img src="https://i.loli.net/2021/08/23/9tClpNzVPEginvd.png" alt="image.png"></p><p><strong>为什么有了二叉查找树/平衡树还需要红黑树</strong></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 红黑树 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>map, set</title>
      <link href="2021/08/23/map%EF%BC%8Cset/"/>
      <url>2021/08/23/map%EF%BC%8Cset/</url>
      
        <content type="html"><![CDATA[<h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p>​    map是关键字-值对的集合，又名关联数组。无重复关键字。</p><h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><p>​    set是关键字的简单集合。无重复关键字。</p><h1 id="map和set的区别"><a href="#map和set的区别" class="headerlink" title="map和set的区别"></a>map和set的区别</h1><ul><li><p>相同点：map和set都是 C++的关联容器，底层都是红黑树实现的。</p></li><li><p>元素：map的元素是key-value（键值-实值）对，关键字起到索引的作用，值表示与索引相关联的数据；set的元素是键值，没有实值。</p></li><li><p>迭代器：map的迭代器既不是const也不是mutable，map允许修改value实值，不允许修改key键值；set迭代器是const的，不允许修改键值。其原因在于map和 set是根据关键字来保证其有序性的，如果允许修改键值，那么首先要删除该键，调节平衡，然后再插入修改后的键值，调节平衡，这样一来破坏了map和set的结构，导致iterator失效。</p></li><li><p>下标操作：map支持下标操作，用关键字作为下标访问关键字对应的值，如果关键字不存在，它会自动将该关键字插入；set不支持下标操作。</p></li></ul><h1 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h1><p>​    用哈希函数组织的无序map。</p><h1 id="unordered-set"><a href="#unordered-set" class="headerlink" title="unordered_set"></a>unordered_set</h1><p>​    用哈希函数组织的无序set。</p><h1 id="unordered-map和map的区别"><a href="#unordered-map和map的区别" class="headerlink" title="unordered_map和map的区别"></a>unordered_map和map的区别</h1><ul><li>底层实现不同：<ul><li>unordered_map底层实现是一个哈希表，元素无序。</li><li>map底层实现是红黑树，其内部所有的元素都是有序的，因此对map的所有操作，其实都是对红黑树的操作。</li></ul></li><li>优缺点：<ul><li>unordered_map：查找效率高；但是建立哈希表比较耗费时间。</li><li>map：内部元素有序，查找和删除操作又是logn的时间复杂度；但是维护红黑树的存储结构需要占用一定的内存空间。</li></ul></li><li>适用情况：<ul><li>对于要求内部元素有序的用map，对于要求查找效率的用unordered_map。</li></ul></li></ul><h1 id="multimap"><a href="#multimap" class="headerlink" title="multimap"></a>multimap</h1><p>​    关键字可重复出现的map。</p><h1 id="multiset"><a href="#multiset" class="headerlink" title="multiset"></a>multiset</h1><p>​    关键字可重复出现的set。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> map </tag>
            
            <tag> set </tag>
            
            <tag> unordered_map </tag>
            
            <tag> unordered_set </tag>
            
            <tag> multiset </tag>
            
            <tag> multimap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迭代和递归</title>
      <link href="2021/08/13/%E8%BF%AD%E4%BB%A3%E5%92%8C%E9%80%92%E5%BD%92/"/>
      <url>2021/08/13/%E8%BF%AD%E4%BB%A3%E5%92%8C%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>​    重复调用函数自身实现循环称为递归。典型问题：斐波那契数列，阶乘（n!）。</p><p>​    构成递归需具备的条件：</p><ol><li>子问题需与原问题为同样的事，且更为简单。</li><li>不能无限制的调用本身，需要有出口。</li></ol><h1 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h1><p>​    迭代法是一种不断用变量的旧值递推新值的过程，典型问题：斐波那契数列，背包问题。</p><h1 id="二者关系与区别"><a href="#二者关系与区别" class="headerlink" title="二者关系与区别"></a>二者关系与区别</h1><p>​    从概念上讲，递归就是指程序调用自身的编程思想，即一个函数调用本身；迭代是利用已知的变量值，根据递推公式不断演进得到新变量值的编程思想。简单的说，递归是重复调用函数自身实现循环。迭代时函数内某段代码实现循环。</p><p>​    迭代与普通循环的区别：迭代时，循环代码中参与运算的变量同时是保存结果的变量，当前保存的结果作为下一次循环计算的初始值。</p><p>​    递归与普通循环的区别：递归是有去无回，而递归是有去有回。</p><p>​    <font color=red>迭代是顺序推导，用临时变量保存结果；递归是逆序推导，用相同函数嵌套调用。</font></p><p>​    </p><p><a href="https://blog.csdn.net/gaoyu1253401563/article/details/82384958?utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control">参考链接1</a>          <a href="https://blog.csdn.net/qq_40817827/article/details/89950325">参考链接2</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 迭代 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git权限管理</title>
      <link href="2021/07/28/git%E6%9D%83%E9%99%90/"/>
      <url>2021/07/28/git%E6%9D%83%E9%99%90/</url>
      
        <content type="html"><![CDATA[<p>​    运行Ardupilot出现permission denied错误解决方案：    git config core.filemode false + chmod</p><h3 id="忽略文件权限"><a href="#忽略文件权限" class="headerlink" title="忽略文件权限"></a>忽略文件权限</h3><p>​    有很多时候我们并不需要过多关注文件权限，特别是部署时会重置文件权限的情况，在开发时由于各环境不同，总是有文件权限的冲突，此时，我们可以忽略文件变更追踪。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config core.filemode <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>可以禁止 <code>Git</code> 跟踪文件权限。</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存管理（1）</title>
      <link href="2021/07/23/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%881%EF%BC%89/"/>
      <url>2021/07/23/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="C-memory-primitives"><a href="#C-memory-primitives" class="headerlink" title="C++ memory primitives"></a>C++ memory primitives</h1><table><thead><tr><th>分配</th><th>释放</th><th>类属</th><th>可否重载</th></tr></thead><tbody><tr><td>malloc()</td><td>free()</td><td>C函数</td><td>不可</td></tr><tr><td>new</td><td>delete</td><td>C++表达式（expressions）</td><td>不可</td></tr><tr><td>::operator new()</td><td>::operator delete()</td><td>C++函数</td><td>可</td></tr><tr><td>allocator<T>:: allocate()</td><td>allocator<T>:: deallocate()</td><td>C++标准库</td><td>可自由设计并搭配任何容器</td></tr></tbody></table><p>各用法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* malloc() and free() */</span></span><br><span class="line"><span class="keyword">void</span>* p1 = <span class="built_in">malloc</span>(<span class="number">512</span>);  <span class="comment">// 分配512个bytes</span></span><br><span class="line"><span class="built_in">free</span>(p1);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* new and delete expression */</span></span><br><span class="line">complex&lt;<span class="keyword">int</span>&gt;* p2 = <span class="keyword">new</span> complex&lt;<span class="keyword">int</span>&gt;; <span class="comment">// one object;</span></span><br><span class="line"><span class="keyword">delete</span> p2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* array new, array delete */</span></span><br><span class="line">Complex* pca = <span class="keyword">new</span> Complex[<span class="number">3</span>];  <span class="comment">// 这里的Complex为自己定义的；</span></span><br><span class="line"><span class="comment">// 调用三次ctor</span></span><br><span class="line"><span class="keyword">delete</span>[] pca;  <span class="comment">// 如果不加[]会导致内存泄漏</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ::operator new() and ::operator delete() */</span></span><br><span class="line"><span class="keyword">void</span>* p3 = ::<span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span>(<span class="number">512</span>); <span class="comment">// 512 bytes</span></span><br><span class="line">::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(p3)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* allocator&lt;T&gt;:: allocate() and allocator&lt;T&gt;:: deallocate() */</span></span><br><span class="line"><span class="comment">// 以下是使用c++标准库提供的allocators</span></span><br><span class="line"><span class="comment">// 不同三家的形式如下 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _MSC_VER</span></span><br><span class="line"><span class="comment">// 以下两函数都是non-static的，需要通过object调用。以下分配3个int</span></span><br><span class="line"><span class="keyword">int</span>* p4 = allocator&lt;<span class="keyword">int</span>&gt;().<span class="built_in">allocate</span>(<span class="number">3</span>, (<span class="keyword">int</span>*)<span class="number">0</span>)； <span class="comment">// 其中(int*)0 目前无用</span></span><br><span class="line">allocator&lt;<span class="keyword">int</span>&gt;().<span class="built_in">deallocate</span>(p4, <span class="number">3</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _BORLANDC_</span></span><br><span class="line"><span class="comment">// 以下两函数都是non-static的，需要通过object调用。以下分配5个int</span></span><br><span class="line"><span class="keyword">void</span>* p4 = allocator&lt;<span class="keyword">int</span>&gt;().<span class="built_in">allocate</span>(<span class="number">5</span>);</span><br><span class="line">allocator&lt;<span class="keyword">int</span>&gt;().deallocate&lt;p4, <span class="number">5</span>&gt;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _GNUC_</span></span><br><span class="line"><span class="comment">// 此为GNUC早期版本 </span></span><br><span class="line"><span class="comment">// 以下两函数都是static的，可通过全名调用。以下分配512 bytes</span></span><br><span class="line"><span class="keyword">void</span>* p4 = alloc::<span class="built_in">allocate</span>(<span class="number">512</span>);</span><br><span class="line">alloc::<span class="built_in">deallocate</span>(p4, <span class="number">512</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _GNUC_</span></span><br><span class="line"><span class="comment">// 新版GNUC</span></span><br><span class="line"><span class="comment">// 以下两函数都是non-static的，需要通过object调用。以下分配7个int</span></span><br><span class="line"><span class="keyword">void</span>* p4 = allocator&lt;<span class="keyword">int</span>&gt;().<span class="built_in">allocate</span>(<span class="number">7</span>);</span><br><span class="line">allocator&lt;<span class="keyword">int</span>&gt;().<span class="built_in">deallocate</span>((<span class="keyword">int</span>*)p4, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下两函数都是non-static的，需要通过object调用。一下分配9个int</span></span><br><span class="line"><span class="keyword">void</span>* p5 = _gnu_cxx::_pool_alloc&lt;<span class="keyword">int</span>&gt;().<span class="built_in">allocate</span>(<span class="number">9</span>);</span><br><span class="line">_gnu_cxx::_pool_alloc&lt;<span class="keyword">int</span>&gt;().<span class="built_in">deallocate</span>((<span class="keyword">int</span>*)p5, <span class="number">9</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="array-new-和-array-delete"><a href="#array-new-和-array-delete" class="headerlink" title="array new 和 array delete"></a>array new 和 array delete</h2><p><img src="https://i.loli.net/2021/07/26/xYs3LaVISlkdFDz.png" alt="image.png"></p><p>​    其中cookie会保存申请的内存的长度等信息，如果delete不加[] 会使得只释放第一或者最后一个内存块，导致内存泄漏。</p><p>​    在使用array new的时候并不能对对象进行想要的初始化，解决方法是使用palcement new。</p><p>Eg：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">A</span>() : <span class="built_in">id</span>(<span class="number">0</span>) &#123; cout&lt;&lt;<span class="string">&quot;default ctor.this=&quot;</span>&lt;&lt;<span class="keyword">this</span>&lt;&lt;<span class="string">&quot; id:&quot;</span>&lt;&lt;id&lt;&lt;endl; &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="keyword">int</span> i) : <span class="built_in">id</span>(i) &#123; cout&lt;&lt;<span class="string">&quot;ctor.this=&quot;</span>&lt;&lt;<span class="keyword">this</span>&lt;&lt;<span class="string">&quot; id:&quot;</span>&lt;&lt;id&lt;&lt;endl; &#125;</span><br><span class="line">    ~<span class="built_in">A</span>()             &#123; cout&lt;&lt;<span class="string">&quot;dtor.this=&quot;</span>&lt;&lt;<span class="keyword">this</span>&lt;&lt;<span class="string">&quot; id:&quot;</span>&lt;&lt;id&lt;&lt;endl; &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A* buf = <span class="keyword">new</span> A[<span class="number">3</span>];  <span class="comment">// 调用三次default ctor；</span></span><br><span class="line">    A* tmp = buf;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;buf = &quot;</span>&lt;&lt;buf&lt;&lt;<span class="string">&quot; tmp = &quot;</span>&lt;&lt;tmp&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span>(tmp++)<span class="built_in">A</span>(i);  <span class="comment">// ctor 3次</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;buf = &quot;</span>&lt;&lt;buf&lt;&lt;<span class="string">&quot; tmp = &quot;</span>&lt;&lt;tmp&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span>[] buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://i.loli.net/2021/07/26/bhSITMqziPGuERa.png" alt="image.png"></p><p>​    ctor的顺序和dtor顺序正好相反。</p><h2 id="new-expression-和-delete-expression"><a href="#new-expression-和-delete-expression" class="headerlink" title="new expression 和 delete expression:"></a>new expression 和 delete expression:</h2><h3 id="new-expression"><a href="#new-expression" class="headerlink" title="new expression"></a>new expression</h3> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Complex* pc =  <span class="keyword">new</span> <span class="built_in">Complex</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>编译器将其转换为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Complex *pc;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">void</span>* mem = <span class="keyword">operator</span> <span class="built_in"><span class="keyword">new</span></span>(<span class="built_in"><span class="keyword">sizeof</span></span>(Complex));<span class="comment">//allocate</span></span><br><span class="line">    pc = <span class="keyword">static_cast</span>&lt;Complex*&gt;(mem);               <span class="comment">// cast</span></span><br><span class="line">    pc-&gt;Complex::<span class="built_in">Complex</span>(<span class="number">1</span>, <span class="number">2</span>);                    <span class="comment">// construct</span></span><br><span class="line">    <span class="comment">// 只有编译器可以像上一行一样直接呼叫ctor；</span></span><br><span class="line">  <span class="comment">// 我们想直接调用构造函数可使用 placement new：   new(p)Complex(1, 2);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span>(std::bad_alloc) &#123;</span><br><span class="line">    <span class="comment">// 若allocation失败就不执行 constructor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="delete-expression"><a href="#delete-expression" class="headerlink" title="delete expression"></a>delete expression</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Complex* pc = <span class="keyword">new</span> <span class="built_in">Complex</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> pc;</span><br></pre></td></tr></table></figure><p>编译器转换为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pc-&gt;~<span class="built_in">Complex</span>();        <span class="comment">// 先析构</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(pc)</span></span>;   <span class="comment">// 然后释放内存</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>右值引用</title>
      <link href="2021/07/23/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"/>
      <url>2021/07/23/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h1><p>​    右值引用是为了支持移动操作，所谓右值引用就是必须绑定到右值的引用，右值引用只能绑定到一个将要销毁的对象，把即将销毁对象的内存、值等全都 “ 拿 ” 过来。</p><p>​    右值引用只能绑定右值。</p><p>Eg：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp;rr1 = <span class="number">42</span>;  <span class="comment">// 正确，字面值是右值</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr2 = rr1; <span class="comment">// 错误，表达式rr1是左值，变量是左值，即使这个变量是右值引用类型也不行</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr3 = std::<span class="built_in">move</span>(rr1); <span class="comment">// ok  ,move 将左值显式转换成右值行是，但这就意味着调用move后，除了对rr1进行赋值或者销毁外，我们将不再使用它。</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 右值引用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++程序编译过程</title>
      <link href="2021/07/21/C++%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/"/>
      <url>2021/07/21/C++%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="C-程序的编译过程（源码如何转化成二进制）"><a href="#C-程序的编译过程（源码如何转化成二进制）" class="headerlink" title="C++程序的编译过程（源码如何转化成二进制）"></a>C++程序的编译过程（源码如何转化成二进制）</h1><h2 id="编译过程分为四个步骤：编译（编译预处理、编译、优化），汇编，链接"><a href="#编译过程分为四个步骤：编译（编译预处理、编译、优化），汇编，链接" class="headerlink" title="编译过程分为四个步骤：编译（编译预处理、编译、优化），汇编，链接"></a>编译过程分为四个步骤：编译（编译预处理、编译、优化），汇编，链接</h2><ul><li>编译预处理：处理以 # 开头的指令。</li><li>编译、优化：将源码 .cpp 文件翻译成 .s 汇编代码。</li><li>汇编：将汇编代码 .s 翻译成机器指令 .o 文件。</li><li>链接：汇编程序生成的目标文件不会立即执行，可能有源文件中的函数引用了另一个源文件中定义的符号或者调用了某个库文件中的函数。链接的目的就是将这些目标文件连接成一个整体，生成一个可执行的.exe文件。</li></ul><p><img src="https://i.loli.net/2021/07/26/OS5yPWYLGnDjk9r.png" alt="编译过程"></p><h2 id="链接分为两种：静态和动态"><a href="#链接分为两种：静态和动态" class="headerlink" title="链接分为两种：静态和动态"></a>链接分为两种：静态和动态</h2><ul><li>静态链接：代码从其所在的动态链接库中拷贝到最终的可执行程序中，在该程序被执行时，这些代码会被装入到该进程的虚拟地址空间中。</li><li>动态链接：代码被放到动态链接库或共享对象的某个目标文件中，链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息。在程序执行时，动态链接库的全部内容会被映射到运行时相应进行的虚拟地址的空间。</li></ul><h2 id="二者优缺点"><a href="#二者优缺点" class="headerlink" title="二者优缺点"></a>二者优缺点</h2><ul><li>静态链接：<strong>浪费空间</strong>，每个可执行程序都会有目标文件的一个副本，这样如果目标文件进行了更新操作，就需要重新进行编译链接生成可执行程序（<strong>更新困难</strong>）；优点就是执行的时候运行速度快，因为可执行程序具备了程序运行的所有内容。</li><li>动态链接：节省内存、更新方便，但是动态链接是在程序运行时，每次执行任务都需要进行链接，性能会有一定的损失。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 编译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C、C++区别</title>
      <link href="2021/05/31/C%E3%80%81C++/"/>
      <url>2021/05/31/C%E3%80%81C++/</url>
      
        <content type="html"><![CDATA[<h1 id="C和C-区别"><a href="#C和C-区别" class="headerlink" title="C和C++区别"></a>C和C++区别</h1><ul><li>C是面向用户的编程，特点是函数；C++是面向对象的编程，特点是类。<font color=blue>（特性）</font>    </li><li>C主要应用于嵌入式开发、驱动开发和硬件直接打交道的领域；C++可以应用于应用层的开发、用户界面开发等和操作系统直接打交道的领域。<font color=blue>（应用领域 ）</font></li><li>C++继承了C的底层操作特性，增加了面向对象的机制，增加而泛型编程 、异常处理、运算符重载，还增加了命名空间，避免了命名冲突。<font color=blue>（相较于C的升级）</font>    </li></ul><h1 id="C-相较于C的增强"><a href="#C-相较于C的增强" class="headerlink" title="C++相较于C的增强"></a>C++相较于C的增强</h1><ul><li>全局变量检测增强。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;  <span class="comment">// 在c语言中不会出现问题，在c++中会报错</span></span><br></pre></td></tr></table></figure><ul><li>函数的检测增强，参数类型增强，函数返回值检测增强，函数调用的参数检测异常。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getRectS</span><span class="params">(w, h)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// 在c语言中没问题，但是在c++中报错，需要增加返回值以及参数类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> test01（） &#123;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">getRectS</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>)&lt;&lt;endl; <span class="comment">// c语言没问题，但是c++中只能传递两个参数，会报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>类型转换检测增强</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span>* p = <span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="number">64</span>)); <span class="comment">// malloc返回值是void*，在c语言中可以运行，c++不可</span></span><br><span class="line">    <span class="keyword">char</span>* p = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="number">64</span>)); <span class="comment">// 才可以</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>struct增强</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">plusAge</span><span class="params">()</span></span>; <span class="comment">// c语言中不可以加函数，在c中报错，c++可以</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p1</span>;</span> <span class="comment">// 在创建对象的时候c语言必须加struct关键字，c++不用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>bool类型的增强，c语言中没有bool类型，c++有， sizeof(bool) = 1，bool类型的非零值都会转换为1</li><li>三目运算符增强，c++返回的是变量，c语言返回的是值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test05</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    （a &gt; b ? a : b） = <span class="number">100</span>;  <span class="comment">// 在c语言中编译不通过，但是在c++通过，因为在c++中这行代码左边返回的是b，即b = 100，而c语言返回的是20；</span></span><br><span class="line">    cout&lt;&lt;b; <span class="comment">// 输出100；</span></span><br><span class="line">    <span class="comment">// c语言如果想实现相同的效果</span></span><br><span class="line">    *(a &gt; b ? &amp;a : &amp;b) = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>const增强，c++中不会给const分配空间，而是将m_B存入符号表中，在c中const默认为外部链接，c++中const默认为内部链接只能在当前作用域使用，要想在外部使用在定义时加extern关键字    </li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m_A = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test06</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    m_A = <span class="number">100</span>;  <span class="comment">// 全局的const不管c还是c++都不能修改，报错</span></span><br><span class="line">    <span class="keyword">const</span> m_B = <span class="number">10</span>; <span class="comment">// 在c中可以通过指针将m_B（伪常量）修改，不能初始化数组，c++中不管以什么方式都不能修改，可以初始化数组，因为没有分配内存，只有分配内存的才可以通过指针进行修改，例子见下面代码</span></span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span>*)&amp;m_B;</span><br><span class="line">    *p = <span class="number">200</span>;</span><br><span class="line">    <span class="comment">// 在c中上面两行代码相当于做了如下操作：</span></span><br><span class="line">    <span class="comment">// int tmp = m_B;   编译器临时开辟一块空间</span></span><br><span class="line">    <span class="comment">// int *p = (int*)&amp;tmp;</span></span><br><span class="line">    <span class="comment">// *p = 200；</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="string">&quot;    &quot;</span> &lt;&lt; m_B &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 输出200  10； </span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>const分配内存</p><ul><li>const在取地址得时候会分配临时内存</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> m_A = <span class="number">10</span>;  <span class="comment">// 不分配内存</span></span><br><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span>*) &amp;m_A; <span class="comment">// 分配临时内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>extern编译器也会给const变量分配内存</li><li>用变量初始化const变量会分配内存</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> b = a;  <span class="comment">// 会分配内存；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> * p =(<span class="keyword">int</span>*) &amp;b;</span><br><span class="line">*p = <span class="number">1000</span>;   <span class="comment">// 这里的b得值会被改成1000；  只有分配了内存才能通过指针对其进行修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>自定义数据类型加const也会分配内存</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">string m_Name;</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">const</span> Person p1;</span><br><span class="line"><span class="comment">// p1.m_Name = &quot;AAA&quot;;  // 报错，const变量不能直接修改，但是因为分配了内存，可以通过指针进行修改</span></span><br><span class="line">Person *p = (Person*)&amp;p1;</span><br><span class="line">p-&gt;m_Name = <span class="string">&quot;asd&quot;</span>;</span><br><span class="line">(*p).m_Age = <span class="number">19</span>;  <span class="comment">// 可以修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>引用是c++对c的重要扩充，引用就是取别名</p><ul><li>基本语法： Type &amp;别名 = 原名</li><li>引用必须初始化，初始化后不可再改为别人的别名</li><li>对数组建立引用</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span>(&amp;pArr)[<span class="number">10</span>] = arr; <span class="comment">// 方法一</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(ARRAYREF)</span>[10]</span>;</span><br><span class="line">    ARRAYREF &amp;pArr2 = arr; <span class="comment">// 方法二</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重写和重载</title>
      <link href="2021/05/31/%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E8%BD%BD/"/>
      <url>2021/05/31/%E9%87%8D%E5%86%99%E5%92%8C%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="C-中重载和重写（覆盖）的区别"><a href="#C-中重载和重写（覆盖）的区别" class="headerlink" title="C++中重载和重写（覆盖）的区别"></a>C++中重载和重写（覆盖）的区别</h1><ul><li>对于类中函数的重载和重写而言，重载发生在同一个类内部，重写则发生在不同的类之间，子类和父类之间。</li><li>重载的函数需要与原函数有相同的函数名、不同的参数列表，不关注函数的返回值类型；重写的函数的函数名、参数列表和返回值类型都需要与原函数相同，父类中被重写的函数需要有virtual修饰。</li><li>virtual关键字：重写的函数基类中必须有virtual关键字的修饰，重载的函数可以有virtual关键字修饰也可以没有。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 重写 </tag>
            
            <tag> 重载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>new/delete和malloc/free用法及区别</title>
      <link href="2021/05/28/new%E3%80%81delete%E5%92%8Cmalloc/"/>
      <url>2021/05/28/new%E3%80%81delete%E5%92%8Cmalloc/</url>
      
        <content type="html"><![CDATA[<h1 id="new和delete的用法"><a href="#new和delete的用法" class="headerlink" title="new和delete的用法"></a>new和delete的用法</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//开辟一个空间</span></span><br><span class="line"><span class="keyword">int</span>* p1 = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> p1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开辟多个空间，通过new开辟数组，一定会调用默认构造函数，所以要提供默认构造函数，在堆区开辟数组不能调用有参构造函数，但是在栈区可以调用有参构造函数</span></span><br><span class="line"><span class="keyword">int</span>* p2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">Person pArray[<span class="number">2</span>] = &#123;<span class="built_in">Person</span>(<span class="number">1</span>), <span class="built_in">Person</span>(<span class="number">2</span>)&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">delete</span> []p2;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意事项，用void*接受new出来的指针，会出现释放问题。</span></span><br><span class="line">    <span class="keyword">void</span>* p = <span class="keyword">new</span> Person;</span><br><span class="line">    <span class="keyword">delete</span> p;   <span class="comment">// p无法释放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="malloc和free的用法"><a href="#malloc和free的用法" class="headerlink" title="malloc和free的用法"></a>malloc和free的用法</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//开辟一个空间</span></span><br><span class="line"><span class="keyword">int</span>* p1=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">if</span>(p1==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(p1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//开辟多个空间</span></span><br><span class="line"><span class="keyword">int</span>*p2=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)*<span class="number">4</span>);</span><br><span class="line"><span class="keyword">if</span>(p2==<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="new和malloc的区别"><a href="#new和malloc的区别" class="headerlink" title="new和malloc的区别"></a>new和malloc的区别</h1><p>在使用的时候，new和delete搭配使用，malloc和free搭配使用，二者从功能上来看都是用来申请内存和回收内存的。</p><ul><li>属性：malloc/free是库函数，需要头文件的支持；new/delete是关键字，需要编译器的支持。</li><li>参数：new申请空间时，无需指定分配空间的大小，编译器会根据类型自行计算；malloc在申请空间时，需要确定所申请的空间大小。</li><li>返回值：new申请空间时，返回的类型是对象的指针类型，无需强制类型转换，故new是符合类型安全性的操作符。而malloc申请空间返回的是void*类型，需要进行强制类型转换，转化为对象类型的指针。</li><li>分配失败：new分配失败会抛出bad_alloc异常，malloc分配失败时返回空指针。</li><li>重载：new/delete是操作符，支持重载，只能在C++使用；malloc/free是函数，可以覆盖（重写），但不能重载，在C、C++都可以使用。</li><li>自定义类型实现：new首先调用operator new函数申请空间（底层通过malloc实现），然后调用构造函数进行初始化，最后返回自定义类型的指针；delete首先调用析构函数，然后调用operator delete释放空间（底层通过free实现）。malloc/free无法进行自定义类型对象的构造和析构。new分配一个对象，malloc分配一块内存。</li><li>内存区域：new操作符从自由存储区上为对象动态分配内存，malloc函数从堆上动态分配内存。（自由存储区 ≠ 堆）。</li></ul><p><a href="https://blog.csdn.net/weibo1230123/article/details/81980889">参考链接1</a></p><p><a href="https://www.cnblogs.com/maluning/p/7944231.html">参考链接2</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> new </tag>
            
            <tag> malloc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存分区模型</title>
      <link href="2021/05/21/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA%E6%A8%A1%E5%9E%8B/"/>
      <url>2021/05/21/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="内存分区模型"><a href="#内存分区模型" class="headerlink" title="内存分区模型"></a>内存分区模型</h1><p>目前网络上主要有两种内存分区方法：</p><h2 id="四区"><a href="#四区" class="headerlink" title="四区"></a>四区</h2><p>C++程序在执行时，将内存大方向分为四个区：</p><ul><li>代码区：存放函数体的二进制代码，由操作系统进行管理。<font color=blue>(共享、只读)</font></li><li>全局区：存放全局变量和静态变量以及常量。<font color=blue>（该区数据在程序结束后由操作系统释放）</font></li><li>栈区：由编译器自动分配释放，存放函数的参数值，局部变量等。<font color=blue>（注意函数不要返回局部变量的地址 ）</font></li><li>堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。<font color=blue>（可以把函数返回的地址保存住，用new来开辟内存）</font></li></ul><h2 id="五区"><a href="#五区" class="headerlink" title="五区"></a>五区</h2><p>分为五区：</p><ul><li>栈区：存放函数的局部变量，由编译器自动分配和释放。</li><li>堆区：动态申请的内存空间，由malloc分配的内存块，由程序员控制它的分配和释放，如果程序执行结束还没有释放，操作系统会自动回收。</li><li>自由存储区：和堆十分相似，存放由new分配的内存块，由delete释放内存。</li><li>全局区/静态区：存放全局变量和静态变量。</li><li>常量存储区：存放的是常量，不允许修改。</li></ul><p><strong>内存四区的意义：不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活性来编程。</strong></p><h2 id="堆和自由存储区的区别："><a href="#堆和自由存储区的区别：" class="headerlink" title="堆和自由存储区的区别："></a>堆和自由存储区的区别：</h2><ul><li>自由存储区是C++中通过new与delete动态分配和释放对象的抽象概念，而堆是C语言和操作系统的术语，是操作系统维护的一块动态分配内存。</li><li>new所申请的内存区域在C++中成为自由存储区，通过堆实现的自由存储，可以说new所申请的内存区域在堆上。</li><li>堆和自由存储区有区别，并非等价。使用new来分配内存，程序员也可以通过重载操作符，改用其他的内存来实现自由存储，例如全局变量做的对象池，这时自由存储区就区别于堆了。</li></ul><p><a href="https://www.cnblogs.com/QG-whz/p/5060894.html">参考链接</a></p><h1 id="堆和自由存储区定义："><a href="#堆和自由存储区定义：" class="headerlink" title="堆和自由存储区定义："></a>堆和自由存储区定义：</h1><blockquote><p>Free Store：<br>The free store is one of the two dynamic memory areas, allocated/freed by new/delete. Object lifetime can be less than the time the storage is allocated; that is, free store objects can have memory allocated without being immediately initialized, and can be destroyed without the memory being immediately deallocated. During the period when the storage is allocated but outside the object’s lifetime, the storage may be accessed and manipulated through a void* but none of the proto-object’s non-static members or member functions may be accessed, have their addresses taken, or be otherwise manipulated.</p></blockquote><blockquote><p>Heap：<br>The heap is the other dynamic memory area, allocated/freed by malloc/free and their variants. Note that while the default global new and delete might be implemented in terms of malloc and free by a particular compiler, the heap is not the same as free store and memory allocated in one area cannot be safely deallocated in the other. Memory allocated from the heap can be used for objects of class type by placement-new construction and explicit destruction. If so used, the notes about free store object lifetime apply similarly here.</p></blockquote><p>来源：<a href="http://www.gotw.ca/gotw/009.htm">http://www.gotw.ca/gotw/009.htm</a></p><h2 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h2><ul><li>申请方式：栈是系统自动分配的，而堆是程序员主动申请的。</li><li>申请后系统响应：分配栈空间，如果剩余空间大于申请空间则分配成功，否则分配失败栈溢出；申请堆空间，堆在内存中的呈现方式类似于链表（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序 ，将该节点从链表中删除，大多数系统会在该块空间的首地址处记录本次分配的大小，便于之后的delete语句释放内存。另外，找到的内存空间大小不一定正好等于申请空间大小，系统自动将多余部分重新放入空闲链表中。</li><li>栈在内存中是连续的一块空间（向低地址扩展）最大容量是系统预定好的，堆在内存中的空间（向高地址扩展）是不连续的。</li><li>申请效率：栈是由系统自动分配的，申请效率高但程序员无法控制；堆是由程序员主动申请的，效率低，使用起来方便但是容易产生碎片。</li><li>存放内容：栈中存放的是局部变量，函数的参数；堆中存放的内容是由程序员控制的。</li></ul><p><a href="https://blog.csdn.net/hairetz/article/details/4141043">参考链接</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 内存 </tag>
            
            <tag> 堆 </tag>
            
            <tag> 栈 </tag>
            
            <tag> 自由存储区 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>const小结</title>
      <link href="2021/05/16/const%E5%B0%8F%E7%BB%93/"/>
      <url>2021/05/16/const%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="const-分类"><a href="#const-分类" class="headerlink" title="const 分类"></a>const 分类</h1><h3 id="顶层const："><a href="#顶层const：" class="headerlink" title="顶层const："></a>顶层const：</h3><ul><li>顶层const可以表示任意的对象是常量，例如常量指针，指针本身为常量。<font color=#FF0000>顶层const作用于对象本身。</font></li></ul><h3 id="底层const："><a href="#底层const：" class="headerlink" title="底层const："></a>底层const：</h3><ul><li>底层const与指针和引用等复合类型部分有关，例如指针所指对象是常量。</li></ul><p><strong>Eg:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p1 = &amp;i;        <span class="comment">// 顶层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> c1 = <span class="number">42</span>;         <span class="comment">// 顶层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p2 = &amp;c1;       <span class="comment">// 底层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> p3 = p2; <span class="comment">// 左边底层， 右边顶层</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r = c1;         <span class="comment">// 用于声明引用的是底层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = <span class="number">42</span>;        <span class="comment">// 允许为一个常量引用绑定非常量的对象、字面值、甚至是个一般表达式</span></span><br></pre></td></tr></table></figure><h3 id="注："><a href="#注：" class="headerlink" title="注："></a><font color=red>注：</font></h3><ul><li>顶层const形参无法重载函数</li></ul><p><strong>Eg:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lookup</span><span class="params">(Phone)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Phone)</span></span>;  <span class="comment">// 等价的重复声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lookup</span><span class="params">(Phone*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lookup</span><span class="params">(Phone* <span class="keyword">const</span>)</span></span>; <span class="comment">// 等价的重复声明</span></span><br></pre></td></tr></table></figure><ul><li>底层const形参可实现函数重载</li></ul><p><strong>Eg：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lookup</span><span class="params">(Phone&amp;)</span></span>;       <span class="comment">// 作用于Phone的引用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Phone&amp;)</span></span>; <span class="comment">// 作用于Phone的常量引用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loohup</span><span class="params">(Phone*)</span></span>;       <span class="comment">// 作用于指向Phone的指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Phone*)</span></span>; <span class="comment">// 作用于指向Phone常量的指针</span></span><br></pre></td></tr></table></figure><p>当传递非常量对象或指向非常量对象的指针时，会优先选用非常量版本。</p><h1 id="const-用法"><a href="#const-用法" class="headerlink" title="const 用法"></a>const 用法</h1><ul><li><p>const修饰成员变量，定义成const常量，相较于宏常量，可进行类型检查，节省内存空间，提高了效率；const成员变量要进行初始化。</p></li><li><p>const修饰函数参数，使得传递过来的函数参数的值不能改变。</p></li><li><p>const修饰成员函数（常函数），使得成员函数不能修改任何类型的成员变量（mutable修饰的变量除外，函数参数也除外），也不能调用非const成员函数，因为非const成员函数可能会修改成员变量。</p></li><li><p>const修饰对象（常对象），只能调用常函数，不可调用普通成员函数，因为普通函数可以修改属性；同时不能对成员变量进行修改。</p></li></ul><h1 id="const注意事项"><a href="#const注意事项" class="headerlink" title="const注意事项"></a>const注意事项</h1><h2 id="const成员变量"><a href="#const成员变量" class="headerlink" title="const成员变量"></a>const成员变量</h2><ul><li><p>const成员变量只能在类内声明、定义，在构造函数初始化列表中初始化，注意在构造函数函数体内部叫赋值（经测试在声明时初始化也可，尽量不要，原因见下条）。</p></li><li><p>const成员变量只在某个对象的生存周期内是常量，对于整个类而言是可变的，因为类可以创建多个对象，不同对象的const成员变量值不同，所以不能在类的声明中初始化const成员变量，因为类的对象还没有创建，编译器不知道他的值。</p></li></ul><h2 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h2><ul><li>不能修改成员变量的值，除非有mutable修饰；只能访问成员变量。</li><li>不能调用非常量成员的函数，以防修改成员变量的值。</li></ul><h1 id="define和const的区别（编译阶段、安全性、内存占用等）"><a href="#define和const的区别（编译阶段、安全性、内存占用等）" class="headerlink" title="define和const的区别（编译阶段、安全性、内存占用等）"></a>define和const的区别（编译阶段、安全性、内存占用等）</h1><ul><li>编译阶段：define是在编译预处理阶段起作用，const是在编译阶段和程序运行阶段起作用。</li><li>安全性：define定义的宏常量没有数据类型，只是进行简单的替换，不会进行类型安全的检查；const定义的只读变量是有类型的，需要进行判断，可以避免一些低级错误。</li><li>内存占用：define定义的宏常量，在程序中使用多少次就会进行多少次替换，内存中有多个备份；const定义的只读变量在程序运行过程中只有一份。</li><li>调试：define定义的不能调试，因为在预编译阶段就进行替换了；const定义的可以进行调试。</li><li>define是没有作用域的，从声明到文件尾都是存活的，但是可以通过#undef A 来卸载宏常量A，而const是有作用域的。</li></ul><h1 id="const的优点"><a href="#const的优点" class="headerlink" title="const的优点"></a>const的优点</h1><ul><li>有数据类型，在定义时可进行安全性检查</li><li>可调试</li><li>占用较少的空间</li></ul><p>在《c和c++区别》这章也有关于const的内容</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> const </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
