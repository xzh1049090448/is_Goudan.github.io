<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>is_Goudan’s Blog</title>
  
  
  <link href="http://isgoudan.top/atom.xml" rel="self"/>
  
  <link href="http://isgoudan.top/"/>
  <updated>2022-01-16T12:40:31.475Z</updated>
  <id>http://isgoudan.top/</id>
  
  <author>
    <name>Gou Daner</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++继承</title>
    <link href="http://isgoudan.top/2022/01/15/C++%E7%BB%A7%E6%89%BF/"/>
    <id>http://isgoudan.top/2022/01/15/C++%E7%BB%A7%E6%89%BF/</id>
    <published>2022-01-15T07:10:38.731Z</published>
    <updated>2022-01-16T12:40:31.475Z</updated>
    
    <content type="html"><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><ul><li>解决代码的复用。</li><li>语法： class 子类 ： 继承方式  父类</li></ul><h1 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h1><ul><li>三种：public、private、protected</li></ul><p><img src="https://s2.loli.net/2022/01/16/x3k79EPCJQdefIL.png" alt="QQ截图20220116151208.png"></p><ul><li>子类会继承父类的所有内容，包括私有属性，只是被编译器隐藏起来，访问不到私有成员。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="keyword">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>()&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(Son) &lt;&lt; endl;   <span class="comment">// 输出16；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="继承中的构造和析构函数"><a href="#继承中的构造和析构函数" class="headerlink" title="继承中的构造和析构函数"></a>继承中的构造和析构函数</h1><ul><li>子类会继承父类的成员属性和成员函数，但是子类不会继承父类的构造函数和析构函数。只有父类自己知道如何构造和析构自己的属性，而子类不知道。另外operator=也不会继承下来。</li><li>子类创建对象时，会先调用父类的构造，然后调用自身的构造。</li><li>析构顺序和构造顺序正好相反。</li><li>当父类的构造函数有参数时，需要在子类初始化列表（参数列表）中显式调用父类的构造函数。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base2</span>(<span class="keyword">int</span> a) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;有参构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son2</span> :</span> <span class="keyword">public</span> Base2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// Son2() &#123;&#125;   // 报错，不存在无参构造</span></span><br><span class="line"><span class="built_in">Son2</span>(<span class="keyword">int</span> a) : <span class="built_in">Base2</span>(a) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="继承中的同名处理"><a href="#继承中的同名处理" class="headerlink" title="继承中的同名处理"></a>继承中的同名处理</h1><ul><li>如果子类和父类拥有同名的属性和函数，子类不会覆盖父类成员，加作用域就可调父类的。</li><li>如果子类与父类的成员函数名称相同，子类会把父类的<strong>所有</strong>同名版本都隐藏掉，想调用必须加作用域。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base</span>() &#123;</span><br><span class="line">m_A = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base func&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span> m_A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son</span>() &#123;</span><br><span class="line">m_A = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Son func&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span> m_A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Son S1;</span><br><span class="line">cout &lt;&lt; s1.m_A &lt;&lt; endl;  <span class="comment">// cout 200</span></span><br><span class="line">cout &lt;&lt; s1.Base::m_A &lt;&lt;endl;  <span class="comment">// cout 100</span></span><br><span class="line">    </span><br><span class="line">    s1.<span class="built_in">func</span>();</span><br><span class="line">    s1.Base::<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="继承中静态成员的处理"><a href="#继承中静态成员的处理" class="headerlink" title="继承中静态成员的处理"></a>继承中静态成员的处理</h1><ul><li>静态成员属性，子类可以继承下来。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Base::m_A = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; Son::m_A &lt;&lt;endl;  <span class="comment">// cout 10;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base func&quot;</span> &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base func(int)&quot;</span> &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Base::m_A = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Son func&quot;</span> &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Son::m_A = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; Son::m_A &lt;&lt;endl;  <span class="comment">// cout 20;</span></span><br><span class="line">    cout &lt;&lt; Base::m_A &lt;&lt;endl;  <span class="comment">// cout 10;</span></span><br><span class="line">    </span><br><span class="line">    Son::<span class="built_in">func</span>();  <span class="comment">// Son func</span></span><br><span class="line">    Base::<span class="built_in">func</span>();<span class="comment">// Base func</span></span><br><span class="line">    Son::Base::<span class="built_in">func</span>(<span class="number">10</span>);<span class="comment">// Base func(int)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h1><ul><li>多继承中很容易引发二义性问题</li><li>语法 ： class Son : public Base1, public Base2 {}</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base1</span>() &#123;</span><br><span class="line">m_A = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">int</span> m_A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base2</span>() &#123;</span><br><span class="line">m_A = <span class="number">20</span>;</span><br><span class="line">    &#125;A</span><br><span class="line"><span class="keyword">int</span> m_A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_C;</span><br><span class="line">    <span class="keyword">int</span> m_D;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(Son) &lt;&lt; endl; <span class="comment">// 16</span></span><br><span class="line">    </span><br><span class="line">    Son s1;</span><br><span class="line">    <span class="comment">// s1.m_A;// 二义性 error</span></span><br><span class="line">    cout &lt;&lt; s1.Base1::m_A &lt;&lt; endl;  <span class="comment">// 10</span></span><br><span class="line">    cout &lt;&lt; s1.Base2::m_A &lt;&lt; endl;  <span class="comment">// 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="菱形继承和虚继承"><a href="#菱形继承和虚继承" class="headerlink" title="菱形继承和虚继承"></a>菱形继承和虚继承</h1><ul><li>菱形继承存在部分数据重复继承两份的问题，为解决该问题，采用虚继承的方式。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tuo</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SheepTuo</span> :</span> <span class="keyword">public</span> Sheep, <span class="keyword">public</span> Tuo &#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SheepTuo st;</span><br><span class="line">    st.Sheep::m_Age = <span class="number">10</span>;</span><br><span class="line">    st.Tuo::m_Age = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">// 存在两份数据，造成资源浪费</span></span><br><span class="line">    cout &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;   <span class="comment">// 10</span></span><br><span class="line">    cout &lt;&lt; st.Tuo::m_Age &lt;&lt; endl;     <span class="comment">// 20;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用虚继承解决：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tuo</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SheepTuo</span> :</span> <span class="keyword">public</span> Sheep, <span class="keyword">public</span> Tuo &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 虚继承后操作一份共享数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SheepTou st;</span><br><span class="line">    st.Sheep::m_Age = <span class="number">10</span>;</span><br><span class="line">    st.Tuo::m_Age = <span class="number">20</span>;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;   <span class="comment">// 20</span></span><br><span class="line">    cout &lt;&lt; st.Tuo::m_Age &lt;&lt; endl;     <span class="comment">// 20;</span></span><br><span class="line">    cout &lt;&lt; st.m_Age &lt;&lt; endl; <span class="comment">// 此时可以直接访问，没有二义性的情况了，只有一份m_Age</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/01/16/TdmLwOuqiYxXVaM.png" alt="QQ截图20220116203008.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;解决代码的复用。&lt;/li&gt;
&lt;li&gt;语法： class 子类 ： 继承方式  父类&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;继承方</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>四旋翼仿真控制模块</title>
    <link href="http://isgoudan.top/2022/01/15/%E5%9B%9B%E6%97%8B%E7%BF%BC%E4%BB%BF%E7%9C%9F%E5%90%84%E6%A8%A1%E5%9D%97%E6%A2%B3%E7%90%86/"/>
    <id>http://isgoudan.top/2022/01/15/%E5%9B%9B%E6%97%8B%E7%BF%BC%E4%BB%BF%E7%9C%9F%E5%90%84%E6%A8%A1%E5%9D%97%E6%A2%B3%E7%90%86/</id>
    <published>2022-01-14T16:11:29.100Z</published>
    <updated>2022-01-15T02:58:45.788Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PositionControl"><a href="#PositionControl" class="headerlink" title="PositionControl"></a>PositionControl</h1><p>​        以下模块参照PX4源码。</p><h2 id="positionControl"><a href="#positionControl" class="headerlink" title="_positionControl"></a>_positionControl</h2><p>所需数据：_pos_sp 和 _pos 和 _gain_pos_p 和 _lim_vel_horizontal</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> PositionControl::_positionControl() &#123;</span><br><span class="line">    <span class="comment">// P-position controller  对位置进行p比例控制</span></span><br><span class="line">    Vector3f vel_sp_position = (_pos_sp - _pos).<span class="built_in">emult</span>(_gain_pos_p);</span><br><span class="line">    <span class="comment">// Position and feed-forward velocity setpoints or position states being NAN results in them not having an influence位置和前馈速度设定点或位置状态为 NAN 导致它们没有影响</span></span><br><span class="line">    _vel_sp += vel_sp_position;</span><br><span class="line">    <span class="comment">// 确保没有NAN</span></span><br><span class="line">    <span class="comment">// ControlMath::setZeroIfNanVector3f(vel_sp_position); </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过优先考虑沿方向的速度分量来约束水平速度</span></span><br><span class="line">    <span class="comment">// 前馈项上的期望位置设定值。</span></span><br><span class="line">    _vel_sp.<span class="built_in">xy</span>() = ControlMath::<span class="built_in">constrainXY</span>(vel_sp_position.<span class="built_in">xy</span>(), (_vel_sp - vel_sp_position).<span class="built_in">xy</span>(), _lim_vel_horizontal);  <span class="comment">// _lim_vel_horizontal水平速度限制</span></span><br><span class="line">    <span class="comment">// Constrain velocity in z-direction. 可以不考虑z轴</span></span><br><span class="line">    <span class="comment">// _vel_sp(2) = math::constrain(_vel_sp(2), -_lim_vel_up, _lim_vel_down);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="velocityControl"><a href="#velocityControl" class="headerlink" title="_velocityControl"></a>_velocityControl</h2><p>来自_positionControl： _vel_sp </p><p>所需数据： _vel 和 _gain_vel_p 和 _gain_vel_d</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> PositionControl::_velocityControl(<span class="keyword">const</span> <span class="keyword">float</span> dt) &#123;</span><br><span class="line"><span class="comment">// PID velocity control</span></span><br><span class="line">    Vector3f vel_error = _vel_sp - _vel;  <span class="comment">// 速度误差</span></span><br><span class="line">    Vector3f acc_sp_velocity = vel_error.<span class="built_in">emult</span>(_gain_vel_p) + _vel_int - _vel_dot.<span class="built_in">emult</span>(_gain_vel_d);  <span class="comment">// emult是乘 _gain_vel_p </span></span><br><span class="line">    <span class="comment">// 如果acc_sp_velocity不是NAN值，就加到期望加速度里，</span></span><br><span class="line">    _acc_sp += acc_sp_velocity； <span class="comment">// _acc_sp 期望加速度</span></span><br><span class="line"></span><br><span class="line">    _accelerationControl();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 垂直方向积分器抗饱和  感觉没用</span></span><br><span class="line"><span class="comment">//if ((_thr_sp(2) &gt;= -_lim_thr_min &amp;&amp; vel_error(2) &gt;= 0.0f) ||</span></span><br><span class="line"><span class="comment">//    (_thr_sp(2) &lt;= -_lim_thr_max &amp;&amp; vel_error(2) &lt;= 0.0f)) &#123;</span></span><br><span class="line"><span class="comment">//vel_error(2) = 0.f;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在保持水平边距的同时，优先考虑垂直控制</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> Vector2f <span class="title">thrust_sp_xy</span><span class="params">(_thr_sp)</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> thrust_sp_xy_norm = thrust_sp_xy.<span class="built_in">norm</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> thrust_max_squared = math::<span class="built_in">sq</span>(_lim_thr_max);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 确定在保持水平边距的情况下还剩下多少垂直推力  这部分应该不重要</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> allocated_horizontal_thrust = math::<span class="built_in">min</span>(thrust_sp_xy_norm, _lim_thr_xy_margin);  <span class="comment">// 分配的水平推力</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> thrust_z_max_squared = thrust_max_squared - math::<span class="built_in">sq</span>(allocated_horizontal_thrust);    <span class="comment">// 推力 z 最大平方</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 饱和最大垂直推力  感觉没用</span></span><br><span class="line">    _thr_sp(<span class="number">2</span>) = math::<span class="built_in">max</span>(_thr_sp(<span class="number">2</span>), -<span class="built_in">sqrtf</span>(thrust_z_max_squared));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 确定优先垂直控制后还剩多少水平推力</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> thrust_max_xy_squared = thrust_max_squared - math::<span class="built_in">sq</span>(_thr_sp(<span class="number">2</span>));</span><br><span class="line"><span class="keyword">float</span> thrust_max_xy = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (thrust_max_xy_squared &gt; <span class="number">0</span>) &#123;</span><br><span class="line">thrust_max_xy = <span class="built_in">sqrtf</span>(thrust_max_xy_squared);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 水平方向饱和推力</span></span><br><span class="line"><span class="keyword">if</span> (thrust_sp_xy_norm &gt; thrust_max_xy) &#123;</span><br><span class="line">_thr_sp.<span class="built_in">xy</span>() = thrust_sp_xy / thrust_sp_xy_norm * thrust_max_xy;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 水平方向使用跟踪 Anti-Windup：在饱和期间，积分器用于使输出不饱和</span></span><br><span class="line"><span class="comment">// see Anti-Reset Windup for PID controllers, L.Rundqwist, 1990</span></span><br><span class="line">    <span class="comment">// 参见 PID 控制器的防复位饱和，L.Rundqwist，1990</span></span><br><span class="line"><span class="keyword">const</span> Vector2f acc_sp_xy_limited = <span class="built_in">Vector2f</span>(_thr_sp) * (CONSTANTS_ONE_G / _hover_thrust);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> arw_gain = <span class="number">2.f</span> / _gain_vel_p(<span class="number">0</span>);</span><br><span class="line">vel_error.<span class="built_in">xy</span>() = <span class="built_in">Vector2f</span>(vel_error) - (arw_gain * (<span class="built_in">Vector2f</span>(_acc_sp) - acc_sp_xy_limited));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保积分不会得到 NAN</span></span><br><span class="line">ControlMath::<span class="built_in">setZeroIfNanVector3f</span>(vel_error);</span><br><span class="line"><span class="comment">// 更新速度控制的组成部分</span></span><br><span class="line">_vel_int += vel_error.<span class="built_in">emult</span>(_gain_vel_i) * dt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 限制推力积分</span></span><br><span class="line">_vel_int(<span class="number">2</span>) = math::<span class="built_in">min</span>(<span class="built_in">fabsf</span>(_vel_int(<span class="number">2</span>)), CONSTANTS_ONE_G) * <span class="built_in">sign</span>(_vel_int(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="accelerationControl"><a href="#accelerationControl" class="headerlink" title="_accelerationControl"></a>_accelerationControl</h2><p>最终给出期望推力</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> PositionControl::_accelerationControl()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 假设在垂直方向上由于重力产生的标准加速度用于姿态生成</span></span><br><span class="line">Vector3f body_z = <span class="built_in">Vector3f</span>(-_acc_sp(<span class="number">0</span>), -_acc_sp(<span class="number">1</span>), CONSTANTS_ONE_G).<span class="built_in">normalized</span>();</span><br><span class="line">ControlMath::<span class="built_in">limitTilt</span>(body_z, <span class="built_in">Vector3f</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>), _lim_tilt);</span><br><span class="line"><span class="comment">// 假设悬停推力产生标准重力的比例推力</span></span><br><span class="line"><span class="keyword">float</span> collective_thrust = _acc_sp(<span class="number">2</span>) * (_hover_thrust / CONSTANTS_ONE_G) - _hover_thrust;</span><br><span class="line"><span class="comment">// Project thrust to planned body attitude</span></span><br><span class="line">collective_thrust /= (<span class="built_in">Vector3f</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>).<span class="built_in">dot</span>(body_z));</span><br><span class="line">collective_thrust = math::<span class="built_in">min</span>(collective_thrust, -_lim_thr_min);</span><br><span class="line">_thr_sp = body_z * collective_thrust;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;PositionControl&quot;&gt;&lt;a href=&quot;#PositionControl&quot; class=&quot;headerlink&quot; title=&quot;PositionControl&quot;&gt;&lt;/a&gt;PositionControl&lt;/h1&gt;&lt;p&gt;​        以下模块参照PX4</summary>
      
    
    
    
    <category term="UAV Simulation" scheme="http://isgoudan.top/categories/UAV-Simulation/"/>
    
    
    <category term="UAV" scheme="http://isgoudan.top/tags/UAV/"/>
    
  </entry>
  
  <entry>
    <title>智能指针</title>
    <link href="http://isgoudan.top/2022/01/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <id>http://isgoudan.top/2022/01/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</id>
    <published>2022-01-14T11:43:39.996Z</published>
    <updated>2022-01-15T15:41:27.603Z</updated>
    
    <content type="html"><![CDATA[<h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><p>​        用来托管自定义类型的对象，让对象进行自动释放</p><p> <a href="%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD.md">运算符重载.md</a> 里有相关内容</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;智能指针&quot;&gt;&lt;a href=&quot;#智能指针&quot; class=&quot;headerlink&quot; title=&quot;智能指针&quot;&gt;&lt;/a&gt;智能指针&lt;/h1&gt;&lt;p&gt;​        用来托管自定义类型的对象，让对象进行自动释放&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;%E8%BF%90%E7%</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="智能指针" scheme="http://isgoudan.top/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>运算符重载</title>
    <link href="http://isgoudan.top/2022/01/14/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    <id>http://isgoudan.top/2022/01/14/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</id>
    <published>2022-01-14T08:03:59.128Z</published>
    <updated>2022-01-15T07:08:55.686Z</updated>
    
    <content type="html"><![CDATA[<h1 id="左移运算符重载"><a href="#左移运算符重载" class="headerlink" title="左移运算符重载"></a>左移运算符重载</h1><ul><li>必须写在写在全局函数中，如果重载时想访问类的私有成员，需要将全局函数作类的友元。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;cout, Person &amp;A) &#123;</span><br><span class="line">    cout &lt;&lt; A.mA;</span><br><span class="line">    <span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="加法运算符重载"><a href="#加法运算符重载" class="headerlink" title="加法运算符重载"></a>加法运算符重载</h1><ul><li>可以在成员函数进行重载，也可以在全局函数重载。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person <span class="keyword">operator</span>+(Person &amp;A, Person&amp; B) &#123;  <span class="comment">// 全局方式  ，局部只需要把参数改下，返回this指针就行</span></span><br><span class="line">Person temp;</span><br><span class="line">    temp.mA = A.mA + B.mA;</span><br><span class="line">    temp.mB = A.mB + B.mB;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="前置递增运算符重载"><a href="#前置递增运算符重载" class="headerlink" title="前置递增运算符重载"></a>前置递增运算符重载</h1><ul><li>可以在成员函数进行重载，也可以在全局函数重载。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInteger</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyInteger</span>() &#123;</span><br><span class="line">mNum = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MyInteger&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">        <span class="keyword">this</span>.mNum++;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mNum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyInteger&amp; <span class="keyword">operator</span>++(MyInteger&amp; A) &#123;</span><br><span class="line">    A.mNum++;</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="后置递增运算符重载"><a href="#后置递增运算符重载" class="headerlink" title="后置递增运算符重载"></a>后置递增运算符重载</h1><ul><li>可以在成员函数进行重载，也可以在全局函数重载。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInteger</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyInteger</span>() &#123;</span><br><span class="line">mNum = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MyInteger <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">        MyInteger tmp = *<span class="keyword">this</span>;</span><br><span class="line">        A.mNum++;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mNum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyInteger <span class="keyword">operator</span>++(MyInteger&amp; A, <span class="keyword">int</span>) &#123;</span><br><span class="line">    MyInteger tmp = A;</span><br><span class="line">    A.mNum++;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="指针运算符重载"><a href="#指针运算符重载" class="headerlink" title="指针运算符重载"></a>指针运算符重载</h1><h2 id="智能指针实现"><a href="#智能指针实现" class="headerlink" title="智能指针实现"></a>智能指针实现</h2><p>用来托管自定义类型的对象，让对象进行自动释放，new出来的对象自动释放。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;age：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;xigou&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 智能指针</span></span><br><span class="line"><span class="comment">// 用来托管自定义类型的对象，让对象进行自动释放</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">smartPointer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">smartPointer</span>(Person *person) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;person = person;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重载-&gt;让智能指针对象像Person *p一样使用</span></span><br><span class="line">    Person * <span class="keyword">operator</span>-&gt;() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;person;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  重载*</span></span><br><span class="line">    Person&amp; <span class="keyword">operator</span>*() &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>-&gt;person;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">smartPointer</span>(Person *person) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;person != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>-&gt;person;</span><br><span class="line">            <span class="keyword">this</span>-&gt;person = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Person *person;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">smartPointer <span class="title">sp</span><span class="params">(<span class="keyword">new</span> Person(<span class="number">10</span>))</span></span>;  <span class="comment">//  开辟到栈上，自动释放</span></span><br><span class="line">    sp-&gt;<span class="built_in">showAge</span>();  <span class="comment">// sp-&gt;-&gt;showAge(),  编译器优化了写法</span></span><br><span class="line">    </span><br><span class="line">    (*sp).<span class="built_in">showAge</span>();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h1><ul><li>系统默认提供给类的赋值运算符写法是简单的值拷贝。</li><li>如果有数据在堆区，可能会有深浅拷贝问题。</li><li>如果想链式编程需要返回return *this;</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">char</span>* name) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;pName = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(name) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;pName, name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;age：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> Person &amp; p) &#123;</span><br><span class="line">        <span class="comment">// 如果原来堆区有内容，先释放掉</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>-&gt;pName != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pName;</span><br><span class="line">            thsi-&gt;pName = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;pName = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(p.pName) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;pName, p.pName);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">Person</span>() &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>-&gt;pName != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pName;</span><br><span class="line">            thsi-&gt;pName = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span>* pName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;goudan&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;gousheng&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;&quot;</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    p3 = p2 = p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="运算符重载"><a href="#运算符重载" class="headerlink" title="[]运算符重载"></a>[]运算符重载</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;myArray[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="和-关系运算符重载"><a href="#和-关系运算符重载" class="headerlink" title="==和!=关系运算符重载"></a>==和!=关系运算符重载</h1><ul><li>类似加号运算符重载</li></ul><h1 id="函数调用运算符重载"><a href="#函数调用运算符重载" class="headerlink" title="函数调用运算符重载"></a>函数调用运算符重载</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">MyPrint <span class="title">myPrint</span><span class="params">()</span></span>;</span><br><span class="line"><span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);  <span class="comment">// 仿函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="amp-amp-和"><a href="#amp-amp-和" class="headerlink" title="&amp;&amp; 和 ||"></a>&amp;&amp; 和 ||</h1><ul><li>这两个不要重载，因为无法实现它们的短路规则。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;左移运算符重载&quot;&gt;&lt;a href=&quot;#左移运算符重载&quot; class=&quot;headerlink&quot; title=&quot;左移运算符重载&quot;&gt;&lt;/a&gt;左移运算符重载&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;必须写在写在全局函数中，如果重载时想访问类的私有成员，需要将全局函数作类的友元。&lt;/li</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="重载" scheme="http://isgoudan.top/tags/%E9%87%8D%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>友元</title>
    <link href="http://isgoudan.top/2022/01/14/%E5%8F%8B%E5%85%83/"/>
    <id>http://isgoudan.top/2022/01/14/%E5%8F%8B%E5%85%83/</id>
    <published>2022-01-14T06:58:25.290Z</published>
    <updated>2022-01-14T07:11:38.675Z</updated>
    
    <content type="html"><![CDATA[<h1 id="友元目的"><a href="#友元目的" class="headerlink" title="友元目的"></a>友元目的</h1><p>​        访问类中的私有成员属性。</p><h1 id="三种友元"><a href="#三种友元" class="headerlink" title="三种友元"></a>三种友元</h1><ul><li><p>全局函数做友元函数，在类中写friend void show();</p></li><li><p>整个类做友元类。在类中写friend class Person;</p><ul><li>注意事项：<ul><li>友元关系不能被继承。</li><li>友元关系是单向的，类A是类B的朋友，但是类B不一定是类A的朋友。</li><li>友元关系不具有传递性。类B是类A的朋友，类C是类B的朋友，但是类C和类A不一定是朋友。</li></ul></li></ul></li><li><p>成员函数做友元函数，在类中写friend void Person::show();</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;友元目的&quot;&gt;&lt;a href=&quot;#友元目的&quot; class=&quot;headerlink&quot; title=&quot;友元目的&quot;&gt;&lt;/a&gt;友元目的&lt;/h1&gt;&lt;p&gt;​        访问类中的私有成员属性。&lt;/p&gt;
&lt;h1 id=&quot;三种友元&quot;&gt;&lt;a href=&quot;#三种友元&quot; class=</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="friend" scheme="http://isgoudan.top/tags/friend/"/>
    
  </entry>
  
  <entry>
    <title>空指针访问成员函数</title>
    <link href="http://isgoudan.top/2022/01/14/%E7%A9%BA%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/"/>
    <id>http://isgoudan.top/2022/01/14/%E7%A9%BA%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/</id>
    <published>2022-01-13T16:53:24.348Z</published>
    <updated>2022-01-14T06:40:27.514Z</updated>
    
    <content type="html"><![CDATA[<ul><li>如果成员函数没有用到this，那么空指针可以直接访问。</li><li>如果成员函数用的this指针，需要加if判断，如果this为空，直接return。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;show&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shouAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; mAge &lt;&lt;  endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>() &#123;</span><br><span class="line">Person *p1 = <span class="literal">NULL</span>;</span><br><span class="line">    p1-&gt;<span class="built_in">show</span>();    <span class="comment">// 正常运行</span></span><br><span class="line">    p1-&gt;<span class="built_in">shouAge</span>();<span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;如果成员函数没有用到this，那么空指针可以直接访问。&lt;/li&gt;
&lt;li&gt;如果成员函数用的this指针，需要加if判断，如果this为空，直接return。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>内存对齐</title>
    <link href="http://isgoudan.top/2022/01/14/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"/>
    <id>http://isgoudan.top/2022/01/14/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</id>
    <published>2022-01-13T16:46:11.438Z</published>
    <updated>2022-01-13T16:50:35.914Z</updated>
    
    <content type="html"><![CDATA[<h1 id="结构体内存对齐方式"><a href="#结构体内存对齐方式" class="headerlink" title="结构体内存对齐方式"></a>结构体内存对齐方式</h1><p>​        结构体大小不是个数据成员之和，而是按照一定的对其数进行对齐存储，最后结构体的大小也是按照一定的对齐数进行对齐。</p><p>对齐规则：</p><ul><li>第一个成员在与结构体变量偏移量为0的地址。</li><li></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;结构体内存对齐方式&quot;&gt;&lt;a href=&quot;#结构体内存对齐方式&quot; class=&quot;headerlink&quot; title=&quot;结构体内存对齐方式&quot;&gt;&lt;/a&gt;结构体内存对齐方式&lt;/h1&gt;&lt;p&gt;​        结构体大小不是个数据成员之和，而是按照一定的对其数进行对齐存储，最</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="内存" scheme="http://isgoudan.top/tags/%E5%86%85%E5%AD%98/"/>
    
    <category term="面经" scheme="http://isgoudan.top/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>this指针</title>
    <link href="http://isgoudan.top/2022/01/13/this%E6%8C%87%E9%92%88/"/>
    <id>http://isgoudan.top/2022/01/13/this%E6%8C%87%E9%92%88/</id>
    <published>2022-01-13T08:37:27.138Z</published>
    <updated>2022-01-13T16:46:21.092Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>this指针指向被调用的成员函数所属的对象。</p></li><li><p>this是一种隐含指针，它隐含于每个类的非静态成员函数中，静态成员函数内部没有this指针，因此静态成员函数不能操作非静态成员变量。</p></li><li><p>当形参和成员变量同名时，可用this指针区分。</p></li><li><p>在类的非静态成员函数中返回对象本身，可使用 return *this。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;this指针指向被调用的成员函数所属的对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;this是一种隐含指针，它隐含于每个类的非静态成员函数中，静态成员函数内部没有this指针，因此静态成员函数不能操作非静态成员变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当形参和</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="this" scheme="http://isgoudan.top/tags/this/"/>
    
  </entry>
  
  <entry>
    <title>static静态成员变量</title>
    <link href="http://isgoudan.top/2022/01/13/static%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/"/>
    <id>http://isgoudan.top/2022/01/13/static%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/</id>
    <published>2022-01-13T05:53:15.251Z</published>
    <updated>2022-01-13T06:38:51.846Z</updated>
    
    <content type="html"><![CDATA[<h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><h2 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h2><ul><li>静态成员变量，属于某个类，所有成员共享，即一个类不管创建多少对象，他们都共用一个静态数据。</li><li>静态变量，在编译阶段就分配空间，对象还没创建时就已经分配了空间。</li><li>静态数据成员不属于某个对象，在为对象分配空间中不包括静态成员所占空间。</li><li><font color=red>静态成员变量必须在类中声明，类外定义。</font></li><li>静态成员变量也有权限。</li></ul><h2 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h2><ul><li>静态成员函数可以在类内实现。</li><li>静态成员函数不可以访问普通的成员变量，可以访问静态成员变量</li><li>静态成员函数也有权限。</li><li>普通成员函数可以访问静态成员变量和静态成员函数。</li></ul><h1 id="访问方式"><a href="#访问方式" class="headerlink" title="访问方式"></a>访问方式</h1><ul><li>通过对象访问</li><li>通过类名访问</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> m_Age; <span class="comment">// 类内声明</span></span><br><span class="line"><span class="keyword">int</span> m_A;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; m_A &lt;&lt; endl;  会报错，不能访问普通成员变量</span></span><br><span class="line">        cout &lt;&lt; m_other &lt;&lt; endl;  <span class="comment">// 可以访问静态成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_other;  <span class="comment">// 私有权限，类外不能访问，但是加上作用域可以在类外初始化</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Person::m_Age = <span class="number">10</span>;  <span class="comment">// 类外初始化</span></span><br><span class="line"><span class="keyword">int</span> Person::m_other = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Person p1;</span><br><span class="line">    Person p2;</span><br><span class="line">    p1.m_Age = <span class="number">20</span>;</span><br><span class="line">    p2.m_Age = <span class="number">30</span>;</span><br><span class="line">cout &lt;&lt; p1.m_Age &lt;&lt; endl;  <span class="comment">// 30</span></span><br><span class="line">    cout &lt;&lt; p2.m_Age &lt;&lt; endl;  <span class="comment">// 30</span></span><br><span class="line">cout &lt;&lt; Person::m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;static&quot;&gt;&lt;a href=&quot;#static&quot; class=&quot;headerlink&quot; title=&quot;static&quot;&gt;&lt;/a&gt;static&lt;/h1&gt;&lt;h2 id=&quot;静态成员变量&quot;&gt;&lt;a href=&quot;#静态成员变量&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="static" scheme="http://isgoudan.top/tags/static/"/>
    
  </entry>
  
  <entry>
    <title>explicit关键字</title>
    <link href="http://isgoudan.top/2022/01/12/explicit%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://isgoudan.top/2022/01/12/explicit%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2022-01-12T12:13:47.998Z</published>
    <updated>2022-01-12T12:20:47.072Z</updated>
    
    <content type="html"><![CDATA[<ul><li>在创建对象的时候会存在隐式类型转换，添加explicit关键字后不能进行隐式类型转换。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">MyClass p = <span class="number">10</span>;  <span class="comment">// 如果在类中添加了explicit关键字，这行报错，不能进行隐式类型转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;在创建对象的时候会存在隐式类型转换，添加explicit关键字后不能进行隐式类型转换。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="explicit" scheme="http://isgoudan.top/tags/explicit/"/>
    
  </entry>
  
  <entry>
    <title>对象的构造和析构</title>
    <link href="http://isgoudan.top/2022/01/12/%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84/"/>
    <id>http://isgoudan.top/2022/01/12/%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84/</id>
    <published>2022-01-12T06:35:19.485Z</published>
    <updated>2022-01-15T06:37:42.790Z</updated>
    
    <content type="html"><![CDATA[<h1 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h1><ul><li>构造函数：没有返回值，没有void，类名相同，可以发生重载，可以有参数。</li><li>析构函数：没有返回值，没有void，函数名称：~类名，不可以重载，不可以有参数。</li><li>系统会默认调用构造函数和析构函数且只调用一次。</li><li>若程序员不提供构造和析构函数，系统默认提供空实现。</li><li>构造和析构必须写在public下才可以调用到。</li></ul><h1 id="构造函数的分类和调用"><a href="#构造函数的分类和调用" class="headerlink" title="构造函数的分类和调用"></a>构造函数的分类和调用</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li>按参数分类<ul><li>无参构造函数（默认构造函数，调用默认构造函数创建对象时不加“()”，Person p1() 会被认成函数声明）</li><li>有参构造函数</li></ul></li><li>按类型分类<ul><li>普通构造函数</li><li>拷贝构造函数（注意浅拷贝问题，参数要加const）</li></ul></li></ul><h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Person p1;      <span class="comment">// 默认构造</span></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">1</span>)</span></span>;   <span class="comment">// 有参构造</span></span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(p1)</span></span>;<span class="comment">// 拷贝构造</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="number">100</span>);    <span class="comment">// 匿名对象，如果编译器发现匿名对象，那么在这行代码结束后就释放这个对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式法调用</span></span><br><span class="line">Person p4 = <span class="built_in">Person</span>(<span class="number">100</span>);</span><br><span class="line">Person p5 = <span class="built_in">Person</span>(p4);</span><br><span class="line"><span class="comment">// 不能用拷贝构造函数初始化匿名对象</span></span><br><span class="line"><span class="built_in">Person</span>(p5);    <span class="comment">// 如果这么写，编译器会认为成 Person p5； 对象的声明，但是可以写成右值</span></span><br><span class="line">Person p6 = <span class="built_in">Person</span>(p5);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式类型转换</span></span><br><span class="line">Person p7 = <span class="number">100</span>;  <span class="comment">// 相当于调用Person p7 = Person(100);</span></span><br><span class="line">Person p8 = p7;</span><br></pre></td></tr></table></figure><h1 id="拷贝构造函数的调用时机"><a href="#拷贝构造函数的调用时机" class="headerlink" title="拷贝构造函数的调用时机"></a>拷贝构造函数的调用时机</h1><ul><li>用已经创建好的对象来初始化新对象。</li><li>以值传递方式给函数参数传值。</li><li>以值方式返回局部对象。</li></ul><h1 id="构造函数的调用规则"><a href="#构造函数的调用规则" class="headerlink" title="构造函数的调用规则"></a>构造函数的调用规则</h1><ul><li><p>系统默认提供三个函数：默认构造函数、拷贝构造函数和析构函数。 其实四个，还有个operator=赋值运算符进行简单值传递。</p></li><li><p>当提供了有参的构造函数，那么系统不会给我们提供默认构造函数，仍提供默认的拷贝构造函数，进行简单的值拷贝。</p></li><li><p>当提供了拷贝构造函数，那么系统不会提供其他构造函数。</p></li></ul><h1 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h1><ul><li>系统默认提供的拷贝构造会进行简单的值拷贝。</li><li>如果属性里有指向堆区空间的数据，那么简单的浅拷贝会导致重复释放内存的异常。</li><li>解决上述问题需要自己提供拷贝构造函数进行深拷贝。</li></ul><h1 id="构造函数和析构函数的调用顺序（在类对象作为成员时）"><a href="#构造函数和析构函数的调用顺序（在类对象作为成员时）" class="headerlink" title="构造函数和析构函数的调用顺序（在类对象作为成员时）"></a>构造函数和析构函数的调用顺序（在类对象作为成员时）</h1><ul><li>首先对类内的类成员对象进行构造，然后在调用类的构造函数</li><li>析构的顺序正好和构造顺序相反</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">class <span class="title">Phone</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Phone</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Phone构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">    ~<span class="built_in">Phone</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Phone析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"><span class="function">class <span class="title">Game</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Game</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Game构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">    ~<span class="built_in">Game</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Game析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;；</span><br><span class="line"></span><br><span class="line"><span class="function">class <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Phone phone;</span><br><span class="line">    Game game;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://s2.loli.net/2022/01/12/U6bW2kl7AvKzRyt.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;构造函数和析构函数&quot;&gt;&lt;a href=&quot;#构造函数和析构函数&quot; class=&quot;headerlink&quot; title=&quot;构造函数和析构函数&quot;&gt;&lt;/a&gt;构造函数和析构函数&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;构造函数：没有返回值，没有void，类名相同，可以发生重载，可以有参数。</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="构造" scheme="http://isgoudan.top/tags/%E6%9E%84%E9%80%A0/"/>
    
    <category term="析构" scheme="http://isgoudan.top/tags/%E6%9E%90%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>C++封装</title>
    <link href="http://isgoudan.top/2022/01/11/C++%E5%B0%81%E8%A3%85/"/>
    <id>http://isgoudan.top/2022/01/11/C++%E5%B0%81%E8%A3%85/</id>
    <published>2022-01-11T09:07:08.954Z</published>
    <updated>2022-01-13T08:37:25.262Z</updated>
    
    <content type="html"><![CDATA[<h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><ul><li>把变量（属性）和函数（操作）合成一个整体，封装在一个类中。</li><li>成员变量和成员函数是分开存储的。</li><li>对变量和函数进行访问控制。</li><li>空类大小为1。 </li><li>只有非静态成员变量属于对象。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="comment">// 注释为加了该行后类的大小。</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_A;         <span class="comment">// 非静态成员变量，属于对象，   大小为4</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;;  <span class="comment">// 非静态成员函数，不属于对象， 大小为4   是通过this指针区分不同对象调用</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_B;  <span class="comment">// 静态成员变量，不属于对象，   大小为4</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;&#125;; <span class="comment">// 静态成员函数，不属于对象 大小4</span></span><br><span class="line">    <span class="keyword">double</span> m_C;      <span class="comment">// 12 错误  大小为16， double占8，但是因为字节对齐，int占4个补齐8个</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="class和struct"><a href="#class和struct" class="headerlink" title="class和struct"></a>class和struct</h1><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>struct和class其实一样，唯一的区别是默认权限不同，struct默认public，class默认private。</p><h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><ul><li>private：私有权限，类内可以访问，类外不可访问，子类也不可访问。</li><li>public：共有权限，类内外都可以访问。</li><li>protected：保护权限，类内可访问，当前类的子类可以访问，类外不可访问。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;封装&quot;&gt;&lt;a href=&quot;#封装&quot; class=&quot;headerlink&quot; title=&quot;封装&quot;&gt;&lt;/a&gt;封装&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;把变量（属性）和函数（操作）合成一个整体，封装在一个类中。&lt;/li&gt;
&lt;li&gt;成员变量和成员函数是分开存储的。&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>四旋翼建模</title>
    <link href="http://isgoudan.top/2021/11/30/%E5%9B%9B%E6%97%8B%E7%BF%BC%E5%BB%BA%E6%A8%A1/"/>
    <id>http://isgoudan.top/2021/11/30/%E5%9B%9B%E6%97%8B%E7%BF%BC%E5%BB%BA%E6%A8%A1/</id>
    <published>2021-11-30T07:06:47.524Z</published>
    <updated>2022-01-14T16:46:13.728Z</updated>
    
    <content type="html"><![CDATA[<p><font color=red><em><strong>以下内容源于知乎，参考链接如下</strong></em></font></p><p><a href="https://zhuanlan.zhihu.com/p/332625724">https://zhuanlan.zhihu.com/p/332625724</a></p><p>先给出四旋翼建模和底层飞控的整体结构图：</p><p><img src="https://pic2.zhimg.com/80/v2-b0c8a97ed2d7865cab0865dd9fd80e29_1440w.png" alt="img"></p><p>上层控制器给出底层的控制指令，例如轨迹规划、协同控制算法等都算是上层控制器。</p><h2 id="1-坐标系"><a href="#1-坐标系" class="headerlink" title="1. 坐标系"></a><strong>1. 坐标系</strong></h2><h2 id="1-1-坐标系定义"><a href="#1-1-坐标系定义" class="headerlink" title="1.1 坐标系定义"></a><strong>1.1 坐标系定义</strong></h2><p>坐标系定义是最基础的前提，因为所有的公式变量都是以坐标系为前提的。</p><p>对于四旋翼模型来说，需要两个坐标系：</p><ul><li>全局坐标系/大地坐标系/惯性坐标系，符号表示： <img src="https://www.zhihu.com/equation?tex=%5CSigma%5E%5Cmathrm%7Bg%7D" alt="[公式]">  - （NED北东地)</li><li>机体坐标系，符号表示： <img src="https://www.zhihu.com/equation?tex=%5CSigma%5E%5Cmathrm%7Bb%7D" alt="[公式]">   - （前右下)</li></ul><p>全局坐标系是固连在大地上的；机体坐标系是固连到四旋翼机体上的，所以如果有很多个四旋翼，也就有很多个机体坐标系。</p><p>全局坐标系的原点一般来说是定义在飞机起飞点附近，在近距离的飞行时，可以忽略地球的曲率。机体坐标系的原点定义是飞机的重心位置。</p><p>全局坐标系的x,y,z轴的正方向分别是北东地（NED），所以无人机向上飞，其z轴坐标是负数。</p><p>机体坐标系的 x,y,z 轴的正方向分别是前右下，也就是飞机的正前方是x轴的正方向。</p><p>按照以上定义，如果全局坐标系的原点设在起飞点，无人机起飞前的初始位置的摆放是正前方对应北向，那么初始时，这两个坐标系是重合的。</p><h2 id="1-2-坐标变换"><a href="#1-2-坐标变换" class="headerlink" title="1.2 坐标变换"></a><strong>1.2 坐标变换</strong></h2><p>首先定义3个旋转矩阵：</p><p><img src="https://s2.loli.net/2022/01/10/72nOzGvLXJqNhoy.png" alt="旋转矩阵.png"></p><p>分别是绕x,y,z轴旋转 <img src="https://www.zhihu.com/equation?tex=%5Ctheta" alt="[公式]"> 角的旋转矩阵。</p><ul><li><p>全局到机体坐标变换公式为：<img src="https://www.zhihu.com/equation?tex=P%5Eb=R%5E%7Bg2b%7D(P%5Eg-T_%7Bb%7D%5Eg)" alt="[公式]"></p><p>其中，</p></li><li><ul><li><img src="https://www.zhihu.com/equation?tex=P%5Eg" alt="[公式]"> 是全局坐标系下的点的坐标，</li><li><img src="https://www.zhihu.com/equation?tex=P%5Eb" alt="[公式]">  是同样的点在机体坐标系下的坐标；</li><li><img src="https://www.zhihu.com/equation?tex=R%5E%7Bg2b%7D=R_xR_yR_z" alt="[公式]"> </li><li>飞机角度为， <img src="https://www.zhihu.com/equation?tex=%5Ctheta_x=roll,+%5Ctheta_y=pitch,%5Ctheta_z=yaw" alt="[公式]"> </li><li><img src="https://www.zhihu.com/equation?tex=T_b%5Eg" alt="[公式]"> 为飞机全局坐标系下的位置。</li></ul></li><li><p>机体到全局坐标变换公式为： <img src="https://www.zhihu.com/equation?tex=P%5Eg=R%5E%7Bb2g%7DP%5Eb+T_b%5Eg" alt="[公式]"></p></li><li><ul><li>其中， <img src="https://www.zhihu.com/equation?tex=R%5E%7Bb2g%7D=(R%5E%7Bg2b%7D)%5E%7B-1%7D=R_zR_yR_x" alt="[公式]"> </li><li>飞机角度为 <img src="https://www.zhihu.com/equation?tex=%5Ctheta_x=-roll,+%5Ctheta_y=-pitch,%5Ctheta_z=-yaw" alt="[公式]"></li></ul></li></ul><p>坐标变换有两种变换方法：先平移后旋转；先旋转后平移。</p><p>上面全局到机体的变换是先平移后旋转的方式，而机体到全局的变换是先旋转后平移的方式。两种方式都可以。</p><p>注意上面的变换中，从全局到机体和从机体到全局的变换是互逆的，两个旋转矩阵也是互逆的。但是如果两种变换都是用同样的方式（比如先旋转后平移），那么两个旋转矩阵就不是互逆的了。</p><h2 id="1-3-坐标变换的通俗解释"><a href="#1-3-坐标变换的通俗解释" class="headerlink" title="1.3 坐标变换的通俗解释"></a><strong>1.3 坐标变换的通俗解释</strong></h2><p>这一节是一个非常通俗的坐标变换的解释，对坐标变换比较熟悉的读者就不需要看了。</p><p>可能刚开始接触坐标系转换的同学对各种旋转矩阵搞得很头疼，其实只要搞明白源头，搞明白为什么要进行坐标系变换，搞明白坐标系变换的本质，就不难理解了。</p><p>其实说白了，<strong>坐标系变换就是用不同的方式来表示同一个点</strong>。让我们首先通俗的讲一下这个事情，我想表示二维平面中某一个点，这时我可以用手指或者画一个箭头指向这个点，那你就知道了我想表达的这个点了。但是如果有很多点怎么办，我如果对每一个点都画个箭头，那么就太乱了，这时，坐标系就出现了。我可以首先建立一个坐标，确定了原点所在的位置和两个轴的方向，然后我把这个坐标系告诉你，这样咱俩都知道了同一个坐标系，以后再相互表达某些点的时候，只需要讲这些点的坐标就可以了，你可以根据坐标，在提前商量好的坐标系中快速地找到这些点。但是，如果你和我都有自己喜欢的坐标系，而且这两个坐标系不一样，不是同一个坐标系，那么我将某个点的坐标告诉你，你在你喜欢的坐标系上是无法准确找到这个点的，这时就需要坐标变换了。所以<strong>坐标变换就是用不同的坐标系去表达同一个点</strong>。</p><h2 id="2-四旋翼建模"><a href="#2-四旋翼建模" class="headerlink" title="2. 四旋翼建模"></a><strong>2. 四旋翼建模</strong></h2><h2 id="2-1-四旋翼的状态量"><a href="#2-1-四旋翼的状态量" class="headerlink" title="2.1 四旋翼的状态量"></a><strong>2.1 四旋翼的状态量</strong></h2><p>首先我们使用到的四旋翼的状态量有18个量：</p><ul><li>位置（全局坐标系）： <img src="https://www.zhihu.com/equation?tex=%5Cbold%7Bp%7D%5E%5Cmathrm%7Bg%7D=%5Bx,y,z%5D%5ET" alt="[公式]"> </li><li>速度（全局坐标系）： <img src="https://www.zhihu.com/equation?tex=%5Cbold%7Bv%7D%5E%5Cmathrm%7Bg%7D+=+%5Bv_x,v_y,v_z%5D%5ET" alt="[公式]"></li><li>加速度（全局坐标系）： <img src="https://www.zhihu.com/equation?tex=%5Cbold%7Ba%7D%5E%5Cmathrm%7Bg%7D=%5Ba_x,a_y,a_z%5D%5ET" alt="[公式]"> </li><li>姿态角： <img src="https://www.zhihu.com/equation?tex=%5CTheta+=%5B%5Cphi,%5Ctheta,%5Cpsi%5D%5ET" alt="[公式]"> , (roll, pitch, yaw)</li><li>机体旋转角速度： <img src="https://www.zhihu.com/equation?tex=%5Cbold%7B%5Comega%7D%5Eb=%5Bp,q,r%5D%5ET" alt="[公式]"> </li><li>机体旋转角加速度： <img src="https://www.zhihu.com/equation?tex=%5Cbold%7B%5Cdot%7B%5Comega%7D%7D%5Eb=%5B%5Cdot%7Bp%7D,%5Cdot%7Bq%7D,%5Cdot%7Br%7D%5D%5ET" alt="[公式]"> </li></ul><p>其中姿态角是机体坐标系相对于全局坐标系的三个欧拉角，机体角速度和机体角加速度都是机体坐标系下的。</p><h2 id="2-2-四旋翼6自由度模型-动力学模型与运动学模型"><a href="#2-2-四旋翼6自由度模型-动力学模型与运动学模型" class="headerlink" title="2.2 四旋翼6自由度模型 - 动力学模型与运动学模型"></a><strong>2.2 四旋翼6自由度模型 - 动力学模型与运动学模型</strong></h2><p>四旋翼非线性建模分为运动学模型和动力学模型两部分。6自由度模型的意思是四旋翼有6个自由度，分别是3个方向的移动和3个方向的转动。下面将6自由度模型的公式罗列出来，本文不进行细节方面详细的讲解，只讲明白怎么使用。</p><ul><li>运动学模型</li></ul><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Baligned%7D+%5Cbold%7B%5Cdot%7Bp%7D%7D%5Eg&=%5Cbold%7Bv%7D%5Eg+%5C%5C+%5Cbold%7B%5Cdot%7B%5CTheta%7D%7D&=%5Cbold%7BW%7D%5Ccdot+%5Cbold%7B%5Comega%7D%5Eb+%5Cend%7Baligned%7D" alt="[公式]"></p><ul><li>动力学模型</li></ul><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Baligned%7D+%5Cbold%7B%5Cdot%7Bv%7D%7D&=g%5Cbold%7Be%7D_3-%5Cdfrac%7Bf%7D%7Bm%7D%5Cbold%7BR%7D%5E%7Bb2g%7D%5Cbold%7Be%7D_3%5C%5C+%5Cbold%7BJ%7D%5Ccdot+%5Cdot%7B%5Cbold%7B%5Comega%7D%7D%5Eb&=-%5Cbold%7B%5Comega%7D%5Eb%5Ctimes(%5Cbold%7BJ%7D%5Ccdot%5Cbold%7B%5Comega%7D%5Eb)+%5Cbold%7BG%7D_a+%5Cbold%7B%5Cbold%7B%5Ctau%7D%7D+%5Cend%7Baligned%7D" alt="[公式]"></p><ul><li><p>其中符号的解释</p></li><li><ul><li><p><img src="https://www.zhihu.com/equation?tex=%5Cbold%7Bp%7D%5Eg" alt="[公式]"> 和 <img src="https://www.zhihu.com/equation?tex=%5Cbold%7Bv%7D%5Eg" alt="[公式]"> 分别是飞机的全局位置和全局速度；</p></li><li><p><img src="https://www.zhihu.com/equation?tex=%5Cbold%7BW%7D" alt="[公式]"> 是表示姿态角速率与机体角速度之间关系的矩阵，</p><p> <img src="https://www.zhihu.com/equation?tex=%5Cbold%7BW%7D=+%5Cleft%5B+%5Cbegin%7Bmatrix%7D+1+&+%5Ctan%5Ctheta+%5Csin%5Cphi+&+%5Ctan%5Ctheta%5Ccos%5Cphi+%5C%5C+0+&+%5Ccos%5Cphi+&+-%5Csin%5Cphi+%5C%5C+0+&+%5Csin%5Cphi/%5Ccos%5Ctheta+&+%5Ccos%5Cphi/%5Ccos%5Ctheta+%5Cend%7Bmatrix%7D+%5Cright%5D" alt="[公式]"></p></li></ul></li></ul><p>应避免 <img src="https://www.zhihu.com/equation?tex=%5Ccos%5Ctheta=0" alt="[公式]"> ​的情况发生。<br>反过来可以得到：​ <img src="https://www.zhihu.com/equation?tex=%5Cbold%7B%5Comega%7D%5Eb=%5Cbold%7BW%7D%5E%7B-1%7D%5Cdot%7B%5CTheta%7D" alt="[公式]"></p><p>​            <img src="https://www.zhihu.com/equation?tex=+%09%09%09%09+%09%09%09%09+%09%09%09%09%5Cbold%7BW%7D%5E%7B-1%7D=2%5Cleft%5B3%5Cbegin%7Bmatrix%7D41+&+0+&+-%5Csin%5Ctheta+%5C%5C50+&+%5Ccos%5Cphi+&+%5Ccos%5Ctheta%5Csin%5Cphi+%5C%5C60+&+-%5Csin%5Cphi+&+%5Ccos%5Ctheta%5Ccos%5Cphi7%5Cend%7Bmatrix%7D8%5Cright%5D" alt="[公式]"></p><ul><li><ul><li> <img src="https://www.zhihu.com/equation?tex=%5Cdot%7B%5Cbold%7B%5CTheta%7D%7D" alt="[公式]"> 是姿态角速率， <img src="https://www.zhihu.com/equation?tex=%5Comega%5Eb" alt="[公式]"> 是机体角速度；</li><li> <img src="https://www.zhihu.com/equation?tex=%5Cbold%7Be%7D_3=%5B0,0,1%5D%5ET" alt="[公式]"> 表示单位列向量;</li><li> <img src="https://www.zhihu.com/equation?tex=f" alt="[公式]"> 是四个电机的拉力总和，方向沿机体坐标系z轴负方向；</li><li> <img src="https://www.zhihu.com/equation?tex=%5Cbold%7BJ%7D" alt="[公式]"> 是四旋翼的惯性矩阵， <img src="https://www.zhihu.com/equation?tex=%5Cbold%7BJ%7D=diag(J_x,J_y,J_z)" alt="[公式]"> </li><li> <img src="https://www.zhihu.com/equation?tex=%5Cbold%7BG%7D_a" alt="[公式]"> 表示陀螺力矩，一般忽略不计；</li><li> <img src="https://www.zhihu.com/equation?tex=%5Cbold%7B%5Ctau%7D=%5B%5Ctau_x,%5Ctau_y,%5Ctau_z%5D" alt="[公式]"> 表示螺旋桨在机体轴上产生的外力矩。</li></ul></li></ul><h2 id="2-3-四旋翼6自由度模型的使用"><a href="#2-3-四旋翼6自由度模型的使用" class="headerlink" title="2.3 四旋翼6自由度模型的使用"></a><strong>2.3 四旋翼6自由度模型的使用</strong></h2><p>有了6自由度模型，输入飞机的整体拉力（ <img src="https://www.zhihu.com/equation?tex=f" alt="[公式]"> ）和3个方向的力矩（ <img src="https://www.zhihu.com/equation?tex=%5Ctau" alt="[公式]"> ），再加上上一时刻四旋翼的状态，就可以计算出下一时刻四旋翼的状态量（位置、速度、加速度、姿态角、机体角速率、机体角加速度）。</p><p>从写代码的计算过程来看，先使用动力学模型两个公式，输入拉力和力矩（ <img src="https://www.zhihu.com/equation?tex=f" alt="[公式]"> , <img src="https://www.zhihu.com/equation?tex=%5Ctau" alt="[公式]"> ），计算飞机的加速度（ <img src="https://www.zhihu.com/equation?tex=%5Cbold%7B%5Cdot%7Bv%7D%7D" alt="[公式]"> ）和角加速度( <img src="https://www.zhihu.com/equation?tex=%5Cdot%7B%5Cbold%7B%5Comega%7D%7D%5Eb" alt="[公式]"> )，然后再使用运动学模型的两个公式，更新其他状态量。</p><h2 id="2-4-四旋翼电机模型"><a href="#2-4-四旋翼电机模型" class="headerlink" title="2.4 四旋翼电机模型"></a><strong>2.4 四旋翼电机模型</strong></h2><p>电机模型是用来对电机建模的，因为电机的响应非常快，所以可以忽略电机的延迟，等效认为对电机的转速指令能够瞬间达到。</p><p>四旋翼分为X型和十字型，分析过程相似，本文使用X型四旋翼来推导，</p><ul><li>四个电机的id号定义如下：(向上为前进方向)</li></ul><p><img src="https://pic2.zhimg.com/80/v2-1e5ef3aa664fe35bcddcbbff2e27a45d_1440w.jpg" alt="img"></p><ul><li><p>力、力矩与电机转速的转换如下：</p><p> <img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Baligned%7D+f&=c_T(%5Comega_1%5E2+%5Comega_2%5E2+%5Comega_3%5E2+%5Comega_4%5E2)%5C%5C+%5Ctau_x+&=lc_T(%5Cdfrac%7B%5Csqrt%7B2%7D%7D%7B2%7D%5Comega_1%5E2-%5Cdfrac%7B%5Csqrt%7B2%7D%7D%7B2%7D%5Comega_2%5E2-%5Cdfrac%7B%5Csqrt%7B2%7D%7D%7B2%7D%5Comega_3%5E2+%5Cdfrac%7B%5Csqrt%7B2%7D%7D%7B2%7D%5Comega_4%5E2)+%5C%5C+%5Ctau_y+&=lc_T(%5Cdfrac%7B%5Csqrt%7B2%7D%7D%7B2%7D%5Comega_1%5E2+%5Cdfrac%7B%5Csqrt%7B2%7D%7D%7B2%7D%5Comega_2%5E2-%5Cdfrac%7B%5Csqrt%7B2%7D%7D%7B2%7D%5Comega_3%5E2-%5Cdfrac%7B%5Csqrt%7B2%7D%7D%7B2%7D%5Comega_4%5E2)%5C%5C+%5Ctau_z+&=+c_M(%5Comega_1%5E2-%5Comega_2%5E2+%5Comega_3%5E2-%5Comega_4%5E2)+%5Cend%7Baligned%7D" alt="[公式]"></p></li></ul><p>其中， <img src="https://www.zhihu.com/equation?tex=l" alt="[公式]"> 为机体中心到任一电机的距离， <img src="https://www.zhihu.com/equation?tex=c_T" alt="[公式]"> 为拉力系数， <img src="https://www.zhihu.com/equation?tex=c_M" alt="[公式]"> 为扭矩系数。</p><h2 id="3-四旋翼底层飞控"><a href="#3-四旋翼底层飞控" class="headerlink" title="3. 四旋翼底层飞控"></a><strong>3. 四旋翼底层飞控</strong></h2><h2 id="3-1-四旋翼底层飞控结构图"><a href="#3-1-四旋翼底层飞控结构图" class="headerlink" title="3.1 四旋翼底层飞控结构图"></a><strong>3.1 四旋翼底层飞控结构图</strong></h2><p>一般四旋翼的底层飞控都是用PID控制器，我这里在内环姿态回路用了LQR控制器，底层控制器整体结构图如下：</p><p><img src="https://pic2.zhimg.com/80/v2-66e3d3bea01271615f2e0c07bd21ab25_1440w.jpg" alt="img"></p><h2 id="3-2-简化的线性模型"><a href="#3-2-简化的线性模型" class="headerlink" title="3.2 简化的线性模型"></a><strong>3.2 简化的线性模型</strong></h2><p>在设计控制器之前，首先要对6自由度非线性模型进行线性化，这样设计出来控制器以后，可以先用线性化的模型计算控制器的收敛性，以此判断控制设计的好不好。最后再用设计好的控制器去控制非线性模型。</p><ul><li><p>假设条件：</p></li><li><ul><li><p>动力学模型忽略 <img src="https://www.zhihu.com/equation?tex=-%5Cbold%7B%5Comega%7D%5Eb%5Ctimes(%5Cbold%7BJ%7D%5Ccdot%5Cbold%7B%5Comega%7D%5Eb)+%5Cbold%7BG%7D_a" alt="[公式]"> </p></li><li><p>俯仰角和滚转角都非常小：</p></li><li><ul><li> <img src="https://www.zhihu.com/equation?tex=%5Csin(%5Cphi)%5Capprox+%5Cphi" alt="[公式]"></li><li> <img src="https://www.zhihu.com/equation?tex=%5Ccos(%5Cphi)%5Capprox+1" alt="[公式]"></li><li> <img src="https://www.zhihu.com/equation?tex=%5Csin(%5Ctheta)%5Capprox+%5Ctheta" alt="[公式]"></li><li> <img src="https://www.zhihu.com/equation?tex=%5Ccos(%5Ctheta)%5Capprox+1" alt="[公式]"></li></ul></li><li><p>总拉力约等于四旋翼的重力： <img src="https://www.zhihu.com/equation?tex=f%5Capprox+mg" alt="[公式]"></p></li><li><p>此时，运动学模型中的 <img src="https://www.zhihu.com/equation?tex=%5Cbold%7BW%7D%5Capprox%5Cbold%7BI%7D_3" alt="[公式]"></p></li><li><p>此时，动力学模型中的 <img src="https://www.zhihu.com/equation?tex=%5Cbold%7BR%7D%5E%7Bb2g%7D%5Cbold%7Be%7D_3%5Capprox+%5Cleft%5B%5Cbegin%7Bmatrix%7D+%5Ctheta%5Ccos%5Cpsi+%5Cphi%5Csin%5Cpsi+%5C%5C+%5Ctheta%5Csin%5Cpsi-%5Cphi%5Ccos%5Cpsi+%5C%5C+1+%5Cend%7Bmatrix%7D%5Cright%5D" alt="[公式]"></p></li></ul></li></ul><p>最终，忽略高阶项，原始模型解耦为三个线性模型：水平位置通道模型、高度通道模型、姿态模型</p><ul><li><p>水平位置通道模型： <img src="https://www.zhihu.com/equation?tex=%5Cleft%5C%7B%5Cbegin%7Baligned%7D+%5Cdot%7B%5Cbold%7Bp%7D%7D_h+&=+%5Cbold%7Bv%7D_h+%5C%5C+%5Cdot%7B%5Cbold%7Bv%7D%7D_h+&=+-g%5Cbold%7BA%7D_%5Cpsi%5Cbold%7B%5CTheta%7D_h+%5Cend%7Baligned%7D%5Cright." alt="[公式]"></p><p>其中， <img src="https://www.zhihu.com/equation?tex=%5Cbold%7Bp%7D_h=%5Cleft%5B%5Cbegin%7Bmatrix%7Dx%5C%5Cy%5Cend%7Bmatrix%7D%5Cright%5D" alt="[公式]">    <img src="https://www.zhihu.com/equation?tex=%5Cbold%7BA%7D_%5Cpsi=%5Cleft%5B%5Cbegin%7Bmatrix%7D%5Csin%5Cpsi+&+%5Ccos%5Cpsi+%5C%5C+-%5Ccos%5Cpsi+&+%5Csin%5Cpsi%5Cend%7Bmatrix%7D%5Cright%5D" alt="[公式]">       <img src="https://www.zhihu.com/equation?tex=%5Cbold%7B%5CTheta%7D_h=%5Cleft%5B%5Cbegin%7Bmatrix%7D%5Cphi%5C%5C+%5Ctheta%5Cend%7Bmatrix%7D%5Cright%5D" alt="[公式]"> </p></li><li><p>高度通道模型： <img src="https://www.zhihu.com/equation?tex=%5Cleft%5C%7B%5Cbegin%7Baligned%7D+%5Cdot%7Bz%7D+&=+v_z+%5C%5C+%5Cdot%7Bv%7D_z+&=+g-%5Cdfrac%7Bf%7D%7Bm%7D+%5Cend%7Baligned%7D%5Cright." alt="[公式]"></p></li><li><p>姿态模型： <img src="https://www.zhihu.com/equation?tex=%5Cleft%5C%7B%5Cbegin%7Baligned%7D+%5Cdot%7B%5Cbold%7B%5CTheta%7D%7D+&=+%5Cbold%7B%5Comega%7D+%5C%5C+%5Cbold%7BJ%7D%5Cdot%7B%5Cbold%7B%5Comega%7D%7D+&=+%5Cbold%7B%5Ctau%7D+%5Cend%7Baligned%7D%5Cright." alt="[公式]"></p></li></ul><h2 id="3-3-外环PID控制器"><a href="#3-3-外环PID控制器" class="headerlink" title="3.3 外环PID控制器"></a><strong>3.3 外环PID控制器</strong></h2><p>外环PID分为水平和垂直两个解耦的控制器。</p><p><strong>外环水平通道PID控制器</strong></p><p>外环水平通道控制器有三种情况：输入指令可以是，位置、速度、加速度。</p><ul><li><p>输入：期望水平方向的指令（三选一）位置、速度、加速度， <img src="https://www.zhihu.com/equation?tex=(p_h)_%7Bcmd%7D=%5Bx_%7Bcmd%7D,y_%7Bcmd%7D%5D%5ET" alt="[公式]"> <img src="https://www.zhihu.com/equation?tex=(%5Cbold%7Bv%7D_h)_%7Bcmd%7D=%5B(v_x)_%7Bcmd%7D,(v_y)_%7Bcmd%7D%5D%5ET" alt="[公式]"> , <img src="https://www.zhihu.com/equation?tex=(a_h)_%7Bcmd%7D=%5B(a_x)_%7Bcmd%7D,(a_y)_%7Bcmd%7D%5D%5ET" alt="[公式]"> </p></li><li><p>输出（给内环）：期望俯仰和滚转姿态角 <img src="https://www.zhihu.com/equation?tex=%5Cphi_%7Bdes%7D,%5Ctheta_%7Bdes%7D" alt="[公式]"> </p></li><li><p>控制器设计：</p></li><li><ul><li><p>位置控制：</p></li><li><ul><li><img src="https://www.zhihu.com/equation?tex=(%5Cbold%7Bv%7D_h)_%7Bdes%7D=%5Cbold%7BK%7D_%7Bp_h%7D%5Cleft((%5Cbold%7Bp%7D_h)_%7Bcmd%7D-%5Cbold%7Bp%7D_h%5Cright)" alt="[公式]"> , P控制器， 其中 <img src="https://www.zhihu.com/equation?tex=(%5Cbold%7Bv%7D_h)_%7Bdes%7D" alt="[公式]"> 要限幅</li><li><img src="https://www.zhihu.com/equation?tex=(%5Cbold%7Ba%7D_h)_%7Bdes%7D=(%5Cbold%7BK%7D_%7B%5Cbold%7Bv%7D_hp%7D%5Cbold%7Be%7D_%7B%5Cbold%7Bv%7D_h%7D+%5Cbold%7BK%7D_%7B%5Cbold%7Bv%7D_hi%7D%5Cint%5Cbold%7Be%7D_%7B%5Cbold%7Bv%7D_h%7D+%5Cbold%7BK%7D_%7B%5Cbold%7Bv%7D_hd%7D%5Cdot%7B%5Cbold%7Be%7D%7D_%7B%5Cbold%7Bv%7D_h%7D)" alt="[公式]"> , PID控制器，一般用PI即可，其中 <img src="https://www.zhihu.com/equation?tex=(%5Cbold%7Ba%7D_h)_%7Bdes%7D" alt="[公式]"> 要限幅</li><li><img src="https://www.zhihu.com/equation?tex=(%5Cbold%7B%5CTheta%7D_h)_%7Bdes%7D=g%5E%7B-1%7D%5Cbold%7BA%7D_%5Cpsi%5E%7B-1%7D(-%5Cbold%7Ba%7D_h)_%7Bdes%7D" alt="[公式]"> , 其中 <img src="https://www.zhihu.com/equation?tex=(%5Cbold%7B%5CTheta%7D_h)_%7Bdes%7D" alt="[公式]"> 要限幅。</li><li>其中 <img src="https://www.zhihu.com/equation?tex=%5Cbold%7BK%7D_%7Bp_h%7D,%5Cbold%7BK%7D_%7B%5Cbold%7Bv%7D_hp%7D,%5Cbold%7BK%7D_%7B%5Cbold%7Bv%7D_hi%7D,%5Cbold%7BK%7D_%7B%5Cbold%7Bv%7D_hd%7D%5Cin+R%5E%7B2%5Ctimes2%7D" alt="[公式]"> 是系数;<img src="https://www.zhihu.com/equation?tex=%5Cbold%7Be%7D_%7B%5Cbold%7Bv%7D_h%7D=(%5Cbold%7Bv%7D_h)_%7Bdes%7D-%5Cbold%7Bv%7D_h" alt="[公式]"></li></ul></li><li><p>速度控制：</p></li><li><ul><li><img src="https://www.zhihu.com/equation?tex=+(%5Cbold%7Ba%7D_h)_%7Bdes%7D=(%5Cbold%7BK%7D_%7B%5Cbold%7Bv%7D_hp%7D%5Cbold%7Be%7D_%7B%5Cbold%7Bv%7D_h%7D+%5Cbold%7BK%7D_%7B%5Cbold%7Bv%7D_hi%7D%5Cint%5Cbold%7Be%7D_%7B%5Cbold%7Bv%7D_h%7D+%5Cbold%7BK%7D_%7B%5Cbold%7Bv%7D_hd%7D%5Cdot%7B%5Cbold%7Be%7D%7D_%7B%5Cbold%7Bv%7D_h%7D)" alt="[公式]"> , PID控制器，一般用PI即可，其中 <img src="https://www.zhihu.com/equation?tex=(%5Cbold%7Ba%7D_h)_%7Bdes%7D" alt="[公式]"> 要限幅</li><li><img src="https://www.zhihu.com/equation?tex=(%5Cbold%7B%5CTheta%7D_h)_%7Bdes%7D=-g%5E%7B-1%7D%5Cbold%7BA%7D_%5Cpsi%5E%7B-1%7D(%5Cbold%7Ba%7D_h)_%7Bdes%7D" alt="[公式]"> , 其中 <img src="https://www.zhihu.com/equation?tex=(%5Cbold%7B%5CTheta%7D_h)_%7Bdes%7D" alt="[公式]"> 要限幅。</li><li>其中， <img src="https://www.zhihu.com/equation?tex=%5Cbold%7BK%7D_%7B%5Cbold%7Bv%7D_hp%7D,%5Cbold%7BK%7D_%7B%5Cbold%7Bv%7D_hi%7D,%5Cbold%7BK%7D_%7B%5Cbold%7Bv%7D_hd%7D%5Cin+R%5E%7B2%5Ctimes2%7D" alt="[公式]"> 是系数; <img src="https://www.zhihu.com/equation?tex=%5Cbold%7Be%7D_%7B%5Cbold%7Bv%7D_h%7D=(%5Cbold%7Bv%7D_h)_%7Bcmd%7D-%5Cbold%7Bv%7D_h" alt="[公式]"> </li></ul></li><li><p>加速度控制：</p></li><li><ul><li><img src="https://www.zhihu.com/equation?tex=(%5Cbold%7B%5CTheta%7D_h)_%7Bdes%7D=-g%5E%7B-1%7D%5Cbold%7BA%7D_%5Cpsi%5E%7B-1%7D(%5Cbold%7Ba%7D_h)_%7Bcmd%7D" alt="[公式]"> , 其中 <img src="https://www.zhihu.com/equation?tex=(%5Cbold%7B%5CTheta%7D_h)_%7Bdes%7D" alt="[公式]"> 要限幅。</li></ul></li></ul></li><li><p>限幅：</p></li><li><ul><li>输入限幅： <img src="https://www.zhihu.com/equation?tex=%7C%7C(%5Cbold%7Bv%7D_h)_%7Bdes%7D%7C%7C%5Cle+%5Cmax+v_h" alt="[公式]"> </li><li>输出限幅： <img src="https://www.zhihu.com/equation?tex=%5Cphi_%7Bdes%7D,%5Ctheta_%7Bdes%7D%5Cle+%5Cmax+%5Ctheta" alt="[公式]"> </li></ul></li></ul><p><strong>外环高度通道PID控制器</strong></p><ul><li><p>输入：期望高度 <img src="https://www.zhihu.com/equation?tex=z_%7Bdes%7D" alt="[公式]"> </p></li><li><p>输出：拉力 <img src="https://www.zhihu.com/equation?tex=f_%7Bdes%7D" alt="[公式]"> </p></li><li><p>控制器设计： <img src="https://www.zhihu.com/equation?tex=f_%7Bdes%7D=m(g+k_%7Bv_zp%7De_%7Bv_z%7D+k_%7Bv_zi%7D%5Cint+e_%7Bv_z%7D)" alt="[公式]"></p><p>其中， <img src="https://www.zhihu.com/equation?tex=k_%7Bv_zp%7D" alt="[公式]"> ,  <img src="https://www.zhihu.com/equation?tex=k_%7Bv_zi%7D" alt="[公式]"> 是系数， <img src="https://www.zhihu.com/equation?tex=e_%7Bv_z%7D=v_z-(v_z)_%7Bdes%7D" alt="[公式]"> 是速度差，<br>其中， <img src="https://www.zhihu.com/equation?tex=(v_z)_%7Bdes%7D=-k_z(z-z_%7Bdes%7D)" alt="[公式]"> ​</p></li><li><p>限幅： <img src="https://www.zhihu.com/equation?tex=(v_z)_%7Bdes%7D%5Cle%5Cmax+z_v" alt="[公式]"> , <img src="https://www.zhihu.com/equation?tex=f_%7Bdes%7D%5Cle%5Cmax+f" alt="[公式]"> </p></li></ul><h2 id="3-4-内环LQR控制器"><a href="#3-4-内环LQR控制器" class="headerlink" title="3.4 内环LQR控制器"></a><strong>3.4 内环LQR控制器</strong></h2><p><strong>输入输出</strong></p><ul><li>输入1（外环）：期望的俯仰滚转角， <img src="https://www.zhihu.com/equation?tex=%5Cphi_%7Bdes%7D,%5Ctheta_%7Bdes%7D" alt="[公式]"> </li><li>输入2：期望的偏航角 <img src="https://www.zhihu.com/equation?tex=%5Cpsi_%7Bdes%7D" alt="[公式]"> </li><li>输出：力矩， <img src="https://www.zhihu.com/equation?tex=%5Cbold%7B%5Ctau%7D_%7Bdes%7D" alt="[公式]"> </li></ul><p><strong>控制器设计</strong></p><ul><li><p>状态方程：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cleft%5B%5Cbegin%7Bmatrix%7D+%5Cdot%7B%5Cphi%7D+%5C%5C+%5Cdot%7B%5Ctheta%7D+%5C%5C+%5Cdot%7B%5Cpsi%7D+%5C%5C+%5Cdot%7Bp%7D%5C%5C+%5Cdot%7Bq%7D%5C%5C+%5Cdot%7Br%7D+%5Cend%7Bmatrix%7D%5Cright%5D=+%5Cleft%5B%5Cbegin%7Bmatrix%7D+0&0&0&1+&+%5Ctan%5Ctheta+%5Csin%5Cphi+&+%5Ctan%5Ctheta%5Ccos%5Cphi+%5C%5C+0&0&0&0+&+%5Ccos%5Cphi+&+-%5Csin%5Cphi+%5C%5C+0&0&0&0+&+%5Csin%5Cphi/%5Ccos%5Ctheta+&+%5Ccos%5Cphi/%5Ccos%5Ctheta+%5C%5C+0&0&0&0&0&0%5C%5C+0&0&0&0&0&0%5C%5C+0&0&0&0&0&0+%5Cend%7Bmatrix%7D%5Cright%5D+%5Cleft%5B%5Cbegin%7Bmatrix%7D+%5Cphi+%5C%5C+%5Ctheta+%5C%5C+%5Cpsi+%5C%5C+p%5C%5C+q%5C%5C+r+%5Cend%7Bmatrix%7D%5Cright%5D++%5Cleft%5B%5Cbegin%7Bmatrix%7D+0&0&0%5C%5C+0&0&0%5C%5C+0&0&0%5C%5C+1/J_x&0&0+%5C%5C+0&+1/J_y+&+0%5C%5C+0&0&1/J_z+%5Cend%7Bmatrix%7D%5Cright%5D+%5Cleft%5B%5Cbegin%7Bmatrix%7D+%5Ctau_x%5C%5C+%5Ctau_y%5C%5C+%5Ctau_z+%5Cend%7Bmatrix%7D%5Cright%5D" alt="[公式]"><br><img src="https://www.zhihu.com/equation?tex=%5Cdot%7Bx%7D=Ax+Bu" alt="[公式]"></p></li><li><ul><li>其中， <img src="https://www.zhihu.com/equation?tex=x=%5B%5Cphi,%5Ctheta,%5Cpsi,p,q,r%5D%5ET" alt="[公式]"> </li><li><img src="https://www.zhihu.com/equation?tex=u=%5B%5Ctau_x,%5Ctau_y,%5Ctau_z%5D%5ET" alt="[公式]"> </li><li><img src="https://www.zhihu.com/equation?tex=A=%5Cleft%5B%5Cbegin%7Bmatrix%7D%5Cbold%7B0%7D&%5Cbold%7BW%7D%5C%5C%5Cbold%7B0%7D&%5Cbold%7B0%7D%5Cend%7Bmatrix%7D%5Cright%5D" alt="[公式]"> </li><li> <img src="https://www.zhihu.com/equation?tex=B=%5Cleft%5B%5Cbegin%7Bmatrix%7D%5Cbold%7B0%7D%5C%5C+%5Cbold%7BJ%7D%5E%7B-1%7D%5Cend%7Bmatrix%7D%5Cright%5D" alt="[公式]"></li></ul></li><li><p>两个矩阵的参数选择： <img src="https://www.zhihu.com/equation?tex=Q=diag%5C%7B8,8,2,+2,+2,+0.1%5C%7D" alt="[公式]"> , <img src="https://www.zhihu.com/equation?tex=R=diag%5C%7B1,1,1%5C%7D" alt="[公式]"> </p></li><li><p>求中间矩阵 <img src="https://www.zhihu.com/equation?tex=P" alt="[公式]"> ，解方程： <img src="https://www.zhihu.com/equation?tex=A%5ETP+PA+Q-PBR%5E%7B-1%7DB%5ETP=0" alt="[公式]"> </p></li><li><p>解出系数矩阵 <img src="https://www.zhihu.com/equation?tex=K" alt="[公式]"> :  <img src="https://www.zhihu.com/equation?tex=K=R%5E%7B-1%7DB%5ETP" alt="[公式]"> </p></li><li><p>最后的解为：<br><img src="https://www.zhihu.com/equation?tex=%5Cbold%7B%5Ctau%7D_%7Bdes%7D=-K(x-x_%7Bdes%7D)" alt="[公式]"></p></li><li><p>限幅： <img src="https://www.zhihu.com/equation?tex=%5Cphi_%7Bdes%7D,%5Ctheta_%7Bdes%7D+%5Cle+%5Cmax%5Ctheta" alt="[公式]"> ,  <img src="https://www.zhihu.com/equation?tex=%5Ctau_%7Bdes%7D%5Cle+%5Cmax+%5Ctau" alt="[公式]"></p></li></ul><h2 id="4-四旋翼参数参考"><a href="#4-四旋翼参数参考" class="headerlink" title="4. 四旋翼参数参考"></a><strong>4. 四旋翼参数参考</strong></h2><p>下面列举的参数是我再仿真中用的参数，可以用来参考。</p><ul><li>参考3dr Robotics</li></ul><table><thead><tr><th>参数</th><th>数据 值/范围</th></tr></thead><tbody><tr><td>质量（kg）</td><td>1.4</td></tr><tr><td>轴距 (m)</td><td>0.56</td></tr><tr><td>转动惯量 (x,y,z) (kg/m^2)</td><td>[0.05,0.05,0.24]</td></tr><tr><td>滚转和俯仰角</td><td>-30 ~ 30</td></tr><tr><td>拉力 (N)</td><td>0 ~ 43.5</td></tr><tr><td>力矩 (x,y) (N.m)</td><td>-6.25 ~ 6.25</td></tr><tr><td>力矩 z</td><td>-2.25 ~ 2.25</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;font color=red&gt;&lt;em&gt;&lt;strong&gt;以下内容源于知乎，参考链接如下&lt;/strong&gt;&lt;/em&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/332625724&quot;&gt;https://zhuanlan</summary>
      
    
    
    
    <category term="UAV Simulation" scheme="http://isgoudan.top/categories/UAV-Simulation/"/>
    
    
    <category term="UAV" scheme="http://isgoudan.top/tags/UAV/"/>
    
  </entry>
  
  <entry>
    <title>namespcae</title>
    <link href="http://isgoudan.top/2021/11/25/namespcae/"/>
    <id>http://isgoudan.top/2021/11/25/namespcae/</id>
    <published>2021-11-25T03:16:06.125Z</published>
    <updated>2021-12-02T01:57:53.737Z</updated>
    
    <content type="html"><![CDATA[<h1 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h1><ul><li>namespace用于解决命名冲突问题</li><li>namespace必须放在全局作用域下</li><li>命名空间下可以放变量、结构体、类、函数</li><li>命名空间可以嵌套命名空间</li><li>命名空间是开放的，可以随时往原来的命名空间添加内容</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A &#123;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> A &#123;  <span class="comment">// 此命名空间会和上面的命名空间合并</span></span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>无名/匿名命名空间相当与写了static，只能在当前文件内使用</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"><span class="keyword">int</span> m_A = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> m_B = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 相当于写了static int m_A; static int m_B;</span></span><br></pre></td></tr></table></figure><ul><li>命名空间可以起别名</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> veryLongName &#123;</span><br><span class="line">    <span class="keyword">int</span> m_A = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> test01 &#123;</span><br><span class="line"><span class="keyword">namespace</span> veryShortName = veryLongName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;namespace&quot;&gt;&lt;a href=&quot;#namespace&quot; class=&quot;headerlink&quot; title=&quot;namespace&quot;&gt;&lt;/a&gt;namespace&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;namespace用于解决命名冲突问题&lt;/li&gt;
&lt;li&gt;namespa</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="namespace" scheme="http://isgoudan.top/tags/namespace/"/>
    
  </entry>
  
  <entry>
    <title>面向对象</title>
    <link href="http://isgoudan.top/2021/11/25/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>http://isgoudan.top/2021/11/25/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</id>
    <published>2021-11-25T02:42:36.987Z</published>
    <updated>2021-11-25T02:46:23.173Z</updated>
    
    <content type="html"><![CDATA[<p>面向对象编程的思想核心：功能分解，自上而下，逐层细化<font color=red>（程序=数据结构+算法）</font></p><h1 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h1><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>把客观事物封装成抽象的类。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>表达的是类之间的关系，对象可以继承另一个对象的特征和能力。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>一个接口，多种方法，程序在运行时才决定调用的方法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;面向对象编程的思想核心：功能分解，自上而下，逐层细化&lt;font color=red&gt;（程序=数据结构+算法）&lt;/font&gt;&lt;/p&gt;
&lt;h1 id=&quot;三大特性&quot;&gt;&lt;a href=&quot;#三大特性&quot; class=&quot;headerlink&quot; title=&quot;三大特性&quot;&gt;&lt;/a&gt;三大特性&lt;</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="http://isgoudan.top/2021/11/24/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://isgoudan.top/2021/11/24/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-11-24T02:44:21.189Z</published>
    <updated>2022-01-13T07:49:28.882Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>​        单例模式是一种软件设计模式，在它的核心结构中只包含一个被称为单例的特殊类，单例模式可以保证系统中一个类只有一个实例且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。如果希望系统中某个类的对象只能存在一个，用单例模式。</p><h1 id="静态成员实现单例模式"><a href="#静态成员实现单例模式" class="headerlink" title="静态成员实现单例模式"></a>静态成员实现单例模式</h1><ul><li>目的：为了让类中只有一个实例，实例不需要自己释放。</li><li>将默认构造和拷贝构造私有化。</li><li>内部维护一个对象指针。</li><li>私有化唯一指针。</li><li>对外提供getInstance方法来访问这个指针。</li><li>保证类中只能实例化唯一一个对象。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChairMan</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 构造函数进行私有化</span></span><br><span class="line">    <span class="built_in">ChairMan</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;creat ChairMan&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数也需要私有化</span></span><br><span class="line">    <span class="built_in">ChairMan</span>(<span class="keyword">const</span> ChairMan&amp;c)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> ChairMan * singleMan;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 提供get方法访问主席</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> ChairMan* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleMan;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ChairMan * ChairMan:;singleMan = <span class="keyword">new</span> ChairMan;  <span class="comment">// 静态变量编译阶段就创建</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ChairMan* cm1 = ChairMan::getInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;main函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果为：</span></span><br><span class="line"><span class="comment">// creat ChairMan</span></span><br><span class="line"><span class="comment">// main函数调用</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink&quot; title=&quot;单例模式&quot;&gt;&lt;/a&gt;单例模式&lt;/h1&gt;&lt;p&gt;​        单例模式是一种软件设计模式，在它的核心结构中只包含一个被称为单例的特殊类，单例模式可以保证系统中一个类只有</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="单例模式" scheme="http://isgoudan.top/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>inline函数</title>
    <link href="http://isgoudan.top/2021/11/24/%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"/>
    <id>http://isgoudan.top/2021/11/24/%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/</id>
    <published>2021-11-24T02:42:58.335Z</published>
    <updated>2022-01-13T05:40:05.241Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内联函数的引出–宏函数的缺陷"><a href="#内联函数的引出–宏函数的缺陷" class="headerlink" title="内联函数的引出–宏函数的缺陷"></a>内联函数的引出–宏函数的缺陷</h1><ul><li><p>第一个问题在c中也会出现的，宏看起来像一个函数调用，但是有一些隐藏的难以发现的错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MyAdd(int a, int b) a+b</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">MyAdd</span>(a, b) &lt;&lt; endl;  <span class="comment">// 输出30；</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">MyAdd</span>(a, b) * <span class="number">10</span> &lt;&lt; endl;  <span class="comment">// 预期结果300，但是输出210； </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MyCompare(int a, int b) a &gt; b ? a : b</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">MyCompare</span>(a, b); <span class="comment">// 输出 20；</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">MyCompare</span>(++a, b); <span class="comment">// 预期21，输出22；</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>第二个问题是C++特有的，预处理器不能访问类的成员，所以预处理宏不能用作类的成员函数。</p></li><li><p>宏函数没有作用域。</p></li></ul><h1 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h1><ul><li>内联函数是一个真正的函数。</li><li>内联函数的声明和实现都需要加inline，否则会被认为成普通函数处理。</li><li>内联函数相当于空间换时间。</li><li>类内部的成员函数，默认前面会加inline关键字，即如果函数定义在类内部，自动成为内联函数<font color=blue>（同样受到最后一条的限制）</font>。</li><li>注意即使加了inline也不一定会变成内联函数，以下情况不会变成inline：<ul><li>不能存在任何形式的循环语句；</li><li>不能存在过多的条件判断语句；</li><li>函数体不能过于庞大；</li><li>不能对函数进行取址操作；</li></ul></li></ul><p><font color=red>内联函数只是相当于给了编译器一个建议，但是编译器不一定会接受。</font></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;内联函数的引出–宏函数的缺陷&quot;&gt;&lt;a href=&quot;#内联函数的引出–宏函数的缺陷&quot; class=&quot;headerlink&quot; title=&quot;内联函数的引出–宏函数的缺陷&quot;&gt;&lt;/a&gt;内联函数的引出–宏函数的缺陷&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;第一个问题在c中也会出现的</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="inline" scheme="http://isgoudan.top/tags/inline/"/>
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="http://isgoudan.top/2021/11/13/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://isgoudan.top/2021/11/13/%E5%B9%B6%E6%9F%A5%E9%9B%86/</id>
    <published>2021-11-13T03:00:15.766Z</published>
    <updated>2021-11-14T02:04:06.368Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>并查集主要用于解决一些<strong>元素分组</strong>的问题。它管理一系列<strong>不相交的集合</strong>，并支持两种操作：</p><ul><li><strong>合并</strong>（Union）：把两个不相交的集合合并为一个集合。</li><li><strong>查询</strong>（Find）：查询两个元素是否在同一个集合中。</li></ul><p>元素之间具有<strong>传递性</strong>的关系以及<strong>只考虑连通性</strong>不考虑距离时，可考虑使用并查集。</p><h1 id="并查集的简介与实现"><a href="#并查集的简介与实现" class="headerlink" title="并查集的简介与实现"></a>并查集的简介与实现</h1><p><font color=red>/<em><strong>以下内容源于知乎，原文链接在末尾</strong></em>/</font></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>并查集的重要思想在于，<strong>用集合中的一个元素代表集合</strong>。我曾看过一个有趣的比喻，把集合比喻成<strong>帮派</strong>，而代表元素则是<strong>帮主</strong>。接下来我们利用这个比喻，看看并查集是如何运作的。</p><p><img src="https://pic4.zhimg.com/v2-09fa3fa35e5411444b327d9cb9a31057_r.jpg"></p><p>最开始，所有大侠各自为战。他们各自的帮主自然就是自己。<em>（对于只有一个元素的集合，代表元素自然是唯一的那个元素）</em></p><p>现在1号和3号比武，假设1号赢了（这里具体谁赢暂时不重要），那么3号就认1号作帮主<em>（合并1号和3号所在的集合，1号为代表元素）</em>。</p><p><img src="https://pic4.zhimg.com/v2-3bf6c1a6ecf87fa93f4dbab2012446c7_r.jpg" alt="img"></p><p>现在2号想和3号比武<em>（合并3号和2号所在的集合）</em>，但3号表示，别跟我打，让我帮主来收拾你<em>（合并代表元素）</em>。不妨设这次又是1号赢了，那么2号也认1号做帮主。</p><p><img src="https://pic4.zhimg.com/80/v2-be12a6c795572d2acd77dcd49de35127_720w.jpg"></p><p>现在我们假设4、5、6号也进行了一番帮派合并，江湖局势变成下面这样：</p><p><img src="https://pic1.zhimg.com/80/v2-3c353bc781c7f3553079d541a9cfdc28_720w.jpg" alt="img"></p><p>现在假设2号想与6号比，跟刚刚说的一样，喊帮主1号和4号出来打一架（帮主真辛苦啊）。1号胜利后，4号认1号为帮主，当然他的手下也都是跟着投降了。</p><p><img src="https://pic3.zhimg.com/80/v2-6362d8b13705d5ba17b19cdeee453022_720w.jpg" alt="img"></p><p>好了，比喻结束了。如果你有一点图论基础，相信你已经觉察到，这是一个<strong>树</strong>状的结构，要寻找集合的代表元素，只需要一层一层往上访问<strong>父节点</strong>（图中箭头所指的圆），直达树的<strong>根节点</strong>（图中橙色的圆）即可。根节点的父节点是它自己。我们可以直接把它画成一棵树：</p><p><img src="https://pic2.zhimg.com/80/v2-cca3ddf5806a221201ed78caf1d27041_720w.jpg" alt="img"></p><p>用这种方法，我们可以写出最简单版本的并查集代码。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fa[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        fa[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假如有编号为1, 2, 3, …, n的n个元素，我们用一个数组fa[]来存储每个元素的父节点（因为每个元素有且只有一个父节点，所以这是可行的）。一开始，我们先将它们的父节点设为自己。</p><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x] == x)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们用递归的写法实现对代表元素的查询：一层一层访问父节点，直至根节点（根节点的标志就是父节点是本身）。要判断两个元素是否属于同一个集合，只需要看它们的根节点是否相同即可。</p><h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fa[find(i)] = find(j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>合并操作也是很简单的，先找到两个集合的代表元素，然后将前者的父节点设为后者即可。当然也可以将后者的父节点设为前者，这里暂时不重要。本文末尾会给出一个更合理的比较方法。</p><h2 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h2><p>​    最简单的并查集效率是比较低的。例如，来看下面这个场景：</p><p><img src="https://pica.zhimg.com/v2-49b5dd7af650192373e96d29f9c4b8cf_720w.jpg?source=3af55fa1" alt="img"><img src="https://pica.zhimg.com/80/v2-49b5dd7af650192373e96d29f9c4b8cf_720w.jpg?source=3af55fa1" alt="img"></p><p>​    现在我们要merge(2,3)，于是从2找到1，fa[1]=3，于是变成了这样：</p><p><img src="https://pica.zhimg.com/v2-6f85fc7c5578aa20400ac56f0da31e37_720w.jpg?source=3af55fa1" alt="img"><img src="https://pica.zhimg.com/80/v2-6f85fc7c5578aa20400ac56f0da31e37_720w.jpg?source=3af55fa1" alt="img"></p><p>​    然后我们又找来一个元素4，并需要执行merge(2,4)：</p><p><img src="https://pic2.zhimg.com/v2-1d3ef8a42d424cbec76135ce8a494ff7_720w.jpg?source=3af55fa1" alt="img"><img src="https://pic2.zhimg.com/80/v2-1d3ef8a42d424cbec76135ce8a494ff7_720w.jpg?source=3af55fa1" alt="img"></p><p>​        从2找到1，再找到3，然后fa[3]=4，于是变成了这样：</p><p><img src="https://pica.zhimg.com/v2-23c367515ace6fc0603692dfd865849f_720w.jpg?source=3af55fa1" alt="img"><img src="https://pica.zhimg.com/80/v2-23c367515ace6fc0603692dfd865849f_720w.jpg?source=3af55fa1" alt="img"></p><p>​    大家应该有感觉了，这样可能会形成一条长长的<strong>链</strong>，随着链越来越长，我们想要从底部找到根节点会变得越来越难。</p><p>​    怎么解决呢？我们可以使用<strong>路径压缩</strong>的方法。既然我们只关心一个元素对应的<strong>根节点</strong>，那我们希望每个元素到根节点的路径尽可能短，最好只需要一步，像这样：</p><p><img src="https://pic3.zhimg.com/v2-c2f835398a3e54d8209bf5e034ac6820_720w.jpg?source=3af55fa1" alt="img"><img src="https://pic3.zhimg.com/80/v2-c2f835398a3e54d8209bf5e034ac6820_720w.jpg?source=3af55fa1" alt="img"></p><p>​    其实这说来也很好实现。只要我们在查询的过程中，<strong>把沿途的每个节点的父节点都设为根节点</strong>即可。下一次再查询时，我们就可以省很多事。这用递归的写法很容易实现：</p><h3 id="合并（路径压缩）"><a href="#合并（路径压缩）" class="headerlink" title="合并（路径压缩）"></a>合并（路径压缩）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == fa[x])</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        fa[x] = find(fa[x]);  <span class="comment">//父节点设为根节点</span></span><br><span class="line">        <span class="keyword">return</span> fa[x];         <span class="comment">//返回父节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    以上代码常常简写为一行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == fa[x] ? x : (fa[x] = find(fa[x]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    注意赋值运算符=的优先级没有三元运算符?:高，这里要加括号。</p><p>​    路径压缩优化后，并查集的时间复杂度已经比较低了，绝大多数不相交集合的合并查询问题都能够解决。然而，对于某些时间卡得很紧的题目，我们还可以进一步优化。</p><hr><h2 id="按秩合并"><a href="#按秩合并" class="headerlink" title="按秩合并"></a>按秩合并</h2><p>​    有些人可能有一个误解，以为路径压缩优化后，并查集始终都是一个<strong>菊花图</strong>（只有两层的树的俗称）。但其实，由于路径压缩只在查询时进行，也只压缩一条路径，所以并查集最终的结构仍然可能是比较复杂的。例如，现在我们有一棵较复杂的树需要与一个单元素的集合合并：</p><p><img src="https://pic3.zhimg.com/v2-d3ff42bb79a6bc751f47daf3fc70e0d9_720w.jpg?source=3af55fa1" alt="img"><img src="https://pic3.zhimg.com/80/v2-d3ff42bb79a6bc751f47daf3fc70e0d9_720w.jpg?source=3af55fa1" alt="img"></p><p>​    假如这时我们要merge(7,8)，如果我们可以选择的话，是把7的父节点设为8好，还是把8的父节点设为7好呢？</p><p>​    当然是后者。因为如果把7的父节点设为8，会使树的<strong>深度</strong>（树中最长链的长度）加深，原来的树中每个元素到根节点的距离都变长了，之后我们寻找根节点的路径也就会相应变长。虽然我们有路径压缩，但路径压缩也是会消耗时间的。而把8的父节点设为7，则不会有这个问题，因为它没有影响到不相关的节点。</p><p><img src="https://pica.zhimg.com/v2-96fbb25365b43f0a109bec6d55b3b899_720w.jpg?source=3af55fa1" alt="img"><img src="https://pica.zhimg.com/80/v2-96fbb25365b43f0a109bec6d55b3b899_720w.jpg?source=3af55fa1" alt="img"></p><p>​    这启发我们：我们应该把简单的树往复杂的树上合并，而不是相反。因为这样合并后，到根节点距离变长的节点个数比较少。</p><p>​    我们用一个数组rank[]记录每个根节点对应的树的深度（如果不是根节点，其rank相当于以它作为根节点的<strong>子树</strong>的深度）。一开始，把所有元素的rank（<strong>秩</strong>）设为1。合并时比较两个根节点，把rank较小者往较大者上合并。</p><p>路径压缩和按秩合并如果一起使用，时间复杂度接近 <img src="https://www.zhihu.com/equation?tex=O(n)" alt="[公式]"> ，但是很可能会破坏rank的准确性。</p><h3 id="初始化（按秩合并）"><a href="#初始化（按秩合并）" class="headerlink" title="初始化（按秩合并）"></a>初始化（按秩合并）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        fa[i] = i;</span><br><span class="line">        rank[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并（按秩合并）"><a href="#合并（按秩合并）" class="headerlink" title="合并（按秩合并）"></a>合并（按秩合并）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = find(i), y = find(j);    <span class="comment">//先找到两个根节点</span></span><br><span class="line">    <span class="keyword">if</span> (rank[x] &lt;= rank[y])</span><br><span class="line">        fa[x] = y;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fa[y] = x;</span><br><span class="line">    <span class="keyword">if</span> (rank[x] == rank[y] &amp;&amp; x != y)</span><br><span class="line">        rank[y]++;                   <span class="comment">//如果深度相同且根节点不同，则新的根节点的深度+1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    为什么深度相同，新的根节点深度要+1？如下图，我们有两个深度均为2的树，现在要merge(2,5)：</p><p><img src="https://pic1.zhimg.com/v2-de356190829600f438058e8615c7a5ac_720w.jpg?source=3af55fa1" alt="img"><img src="https://pic1.zhimg.com/80/v2-de356190829600f438058e8615c7a5ac_720w.jpg?source=3af55fa1" alt="img"></p><p>​    这里把2的父节点设为5，或者把5的父节点设为2，其实没有太大区别。我们选择前者，于是变成这样：</p><p><img src="https://pic3.zhimg.com/v2-a829932f008f000440942cb8df393662_720w.jpg?source=3af55fa1" alt="img"><img src="https://pic3.zhimg.com/80/v2-a829932f008f000440942cb8df393662_720w.jpg?source=3af55fa1" alt="img"></p><p>​        显然树的深度增加了1。另一种合并方式同样会让树的深度+1。</p><p><a href="https://zhuanlan.zhihu.com/p/93647900/">点我！！这是原文！！！！！！！！！！</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h1&gt;&lt;p&gt;并查集主要用于解决一些&lt;strong&gt;元素分组&lt;/strong&gt;的问题。它管理一系列&lt;strong&gt;不相交的集合&lt;/stro</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="并查集" scheme="http://isgoudan.top/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>PX4、ROS、Gazebo安装</title>
    <link href="http://isgoudan.top/2021/11/03/PX4%E3%80%81ROS%E3%80%81Gazebo%E5%AE%89%E8%A3%85/"/>
    <id>http://isgoudan.top/2021/11/03/PX4%E3%80%81ROS%E3%80%81Gazebo%E5%AE%89%E8%A3%85/</id>
    <published>2021-11-03T08:30:05.186Z</published>
    <updated>2021-11-03T10:57:01.537Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装指南"><a href="#安装指南" class="headerlink" title="安装指南"></a>安装指南</h1><h2 id="前置步骤"><a href="#前置步骤" class="headerlink" title="前置步骤"></a>前置步骤</h2><h3 id="ubuntu换源："><a href="#ubuntu换源：" class="headerlink" title="ubuntu换源："></a>ubuntu换源：</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure><ul><li>以下几个源任选</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#  阿里镜像源</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 清华镜像源</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>更新</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update &amp;&amp; sudo apt-get upgrade</span><br></pre></td></tr></table></figure><h3 id="科学上网"><a href="#科学上网" class="headerlink" title="科学上网"></a>科学上网</h3><p>主机全局代理+虚拟机nat模式+虚拟机代理</p><h2 id="正式步骤"><a href="#正式步骤" class="headerlink" title="正式步骤"></a>正式步骤</h2><h3 id="ROS-MAVROS-Gazebo"><a href="#ROS-MAVROS-Gazebo" class="headerlink" title="ROS+MAVROS+Gazebo"></a>ROS+MAVROS+Gazebo</h3><ol><li><p>获取快速安装脚本，可能出现网络问题，自行百度，科学上网多试几次，换手机网可行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/PX4/Devguide/master/build_scripts/ubuntu_sim_ros_melodic.sh</span><br></pre></td></tr></table></figure></li><li><p>在脚本目录下运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash ubuntu_sim_ros_melodic.sh</span><br></pre></td></tr></table></figure><p>在运行过程中报错</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error downloading <span class="string">&#x27;install_geographiclib_datasets.sh&#x27;</span>. Sorry but I cannot proceed further :(</span><br></pre></td></tr></table></figure><p><a href="https://gitee.com/MrZhaosx/geographic-lib">https://gitee.com/MrZhaosx/geographic-lib</a></p><p>将链接中三个文件夹下载拷贝到 <strong>/usr/share/GeographicLib</strong> 文件夹下面，不能直接拖拽，先放到桌面用命令行sudo操作</p><p>然后运行 </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./install_geographiclib_datasets.sh</span><br></pre></td></tr></table></figure></li></ol><h3 id="PX4"><a href="#PX4" class="headerlink" title="PX4"></a>PX4</h3><ol><li><p>下载PX4源码</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/PX4/PX4-Autopilot.git --recursive</span><br></pre></td></tr></table></figure></li><li><p>运行ubuntu.sh，如果需要nuttx把–no-nuttx去除即可</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash ./PX4-Autopilot/Tools/setup/ubuntu.sh --no-nuttx</span><br></pre></td></tr></table></figure></li><li><p>重启</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;安装指南&quot;&gt;&lt;a href=&quot;#安装指南&quot; class=&quot;headerlink&quot; title=&quot;安装指南&quot;&gt;&lt;/a&gt;安装指南&lt;/h1&gt;&lt;h2 id=&quot;前置步骤&quot;&gt;&lt;a href=&quot;#前置步骤&quot; class=&quot;headerlink&quot; title=&quot;前置步骤&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="UAV Simulation" scheme="http://isgoudan.top/categories/UAV-Simulation/"/>
    
    
    <category term="Gazebo" scheme="http://isgoudan.top/tags/Gazebo/"/>
    
    <category term="PX4" scheme="http://isgoudan.top/tags/PX4/"/>
    
    <category term="ROS" scheme="http://isgoudan.top/tags/ROS/"/>
    
  </entry>
  
  <entry>
    <title>Gazebo问题汇总</title>
    <link href="http://isgoudan.top/2021/09/24/Gazebo%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>http://isgoudan.top/2021/09/24/Gazebo%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</id>
    <published>2021-09-24T08:38:52.649Z</published>
    <updated>2021-11-03T08:32:26.105Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述1"><a href="#问题描述1" class="headerlink" title="问题描述1"></a>问题描述1</h1><p><img src="https://i.loli.net/2021/09/24/FWRNOJ7iPm6Et5U.png" alt="image.png"></p><h1 id="解决方案1"><a href="#解决方案1" class="headerlink" title="解决方案1"></a>解决方案1</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unset LIBGL_ALWAYS_INDIRECT</span><br></pre></td></tr></table></figure><h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>gazebo在Ardupilot下模型加载慢</p><p><img src="https://i.loli.net/2021/09/24/gRT3DWJmY69CUnt.png" alt="image.png"></p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>提前下载模型后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /usr/share/gazebo/setup.sh</span><br></pre></td></tr></table></figure><h1 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h1><p>运行roslaunch 文件报错</p><p><img src="https://i.loli.net/2021/09/24/vJWqMsb6Gx5CitL.png" alt="image.png"></p><h1 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bashrc</span><br><span class="line">把自己创建的catwin那个注释掉</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;问题描述1&quot;&gt;&lt;a href=&quot;#问题描述1&quot; class=&quot;headerlink&quot; title=&quot;问题描述1&quot;&gt;&lt;/a&gt;问题描述1&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/09/24/FWRNOJ7iPm6Et5U.pn</summary>
      
    
    
    
    <category term="UAV Simulation" scheme="http://isgoudan.top/categories/UAV-Simulation/"/>
    
    
    <category term="Gazebo" scheme="http://isgoudan.top/tags/Gazebo/"/>
    
  </entry>
  
</feed>
