<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>is_Goudan’s Blog</title>
  
  
  <link href="http://isgoudan.top/atom.xml" rel="self"/>
  
  <link href="http://isgoudan.top/"/>
  <updated>2021-05-28T03:25:07.262Z</updated>
  <id>http://isgoudan.top/</id>
  
  <author>
    <name>Gou Daner</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>new、delete和malloc</title>
    <link href="http://isgoudan.top/2021/05/28/new%E3%80%81delete%E5%92%8Cmalloc/"/>
    <id>http://isgoudan.top/2021/05/28/new%E3%80%81delete%E5%92%8Cmalloc/</id>
    <published>2021-05-28T03:20:16.000Z</published>
    <updated>2021-05-28T03:25:07.262Z</updated>
    
    <content type="html"><![CDATA[<h1 id="new和malloc的异同以及new和delete的实现"><a href="#new和malloc的异同以及new和delete的实现" class="headerlink" title="new和malloc的异同以及new和delete的实现"></a>new和malloc的异同以及new和delete的实现</h1><p>在使用的时候，new和delete搭配使用，malloc和free搭配使用。</p><ul><li>属性：</li></ul><p><font color=red><em><strong>未完待续</strong></em></font></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;new和malloc的异同以及new和delete的实现&quot;&gt;&lt;a href=&quot;#new和malloc的异同以及new和delete的实现&quot; class=&quot;headerlink&quot; title=&quot;new和malloc的异同以及new和delete的实现&quot;&gt;&lt;/a&gt;ne</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="new" scheme="http://isgoudan.top/tags/new/"/>
    
    <category term="malloc" scheme="http://isgoudan.top/tags/malloc/"/>
    
  </entry>
  
  <entry>
    <title>内存分区模型</title>
    <link href="http://isgoudan.top/2021/05/21/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA%E6%A8%A1%E5%9E%8B/"/>
    <id>http://isgoudan.top/2021/05/21/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA%E6%A8%A1%E5%9E%8B/</id>
    <published>2021-05-21T08:45:16.000Z</published>
    <updated>2021-05-28T02:41:37.043Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存分区模型"><a href="#内存分区模型" class="headerlink" title="内存分区模型"></a>内存分区模型</h1><p>目前网络上主要有两种内存分区方法：</p><h2 id="四区"><a href="#四区" class="headerlink" title="四区"></a>四区</h2><p>C++程序在执行时，将内存大方向分为四个区：</p><ul><li>代码区：存放函数体的二进制代码，由操作系统进行管理。<font color=blue>(共享、只读)</font></li><li>全局区：存放全局变量和静态变量以及常量。<font color=blue>（该区数据在程序结束后由操作系统释放）</font></li><li>栈区：由编译器自动分配释放，存放函数的参数值，局部变量等。<font color=blue>（注意函数不要返回局部变量的地址 ）</font></li><li>堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。<font color=blue>（可以把函数返回的地址保存住，用new来开辟内存）</font></li></ul><h2 id="五区"><a href="#五区" class="headerlink" title="五区"></a>五区</h2><p>分为五区：</p><ul><li>栈区：存放函数的局部变量，由编译器自动分配和释放。</li><li>堆区：动态申请的内存空间，由malloc分配的内存块，由程序员控制它的分配和释放，如果程序执行结束还没有释放，操作系统会自动回收。</li><li>自由存储区：和堆十分相似，存放由new分配的内存块，由delete释放内存。</li><li>全局区/静态区：存放全局变量和静态变量。</li><li>常量存储区：存放的是常量，不允许修改。</li></ul><p><strong>内存四区的意义：不同区域存放的数据，赋予不同的生命周期，给我们更大的灵活性来编程。</strong></p><h2 id="堆和自由存储区的区别："><a href="#堆和自由存储区的区别：" class="headerlink" title="堆和自由存储区的区别："></a>堆和自由存储区的区别：</h2><ul><li>自由存储区是C++中通过new与delete动态分配和释放对象的抽象概念，而堆是C语言和操作系统的术语，是操作系统维护的一块动态分配内存。</li><li>new所申请的内存区域在C++中成为自由存储区，通过堆实现的自由存储，可以说new所申请的内存区域在堆上。</li><li>堆和自由存储区有区别，并非等价。使用new来分配内存，程序员也可以通过重载操作符，改用其他的内存来实现自由存储，例如全局变量做的对象池，这时自由存储区就区别于堆了。</li></ul><p><a href="https://www.cnblogs.com/QG-whz/p/5060894.html">参考链接</a></p><h2 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h2><ul><li>申请方式：栈是系统自动分配的，而堆是程序员主动申请的。</li><li>申请后系统响应：分配栈空间，如果剩余空间大于申请空间则分配成功，否则分配失败栈溢出；申请堆空间，堆在内存中的呈现方式类似于链表（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序 ，将该节点从链表中删除，大多数系统会在该块空间的首地址处记录本次分配的大小，便于之后的delete语句释放内存。另外，找到的内存空间大小不一定正好等于申请空间大小，系统自动将多余部分重新放入空闲链表中。</li><li>栈在内存中是连续的一块空间（向低地址扩展）最大容量是系统预定好的，堆在内存中的空间（向高地址扩展）是不连续的。</li><li>申请效率：栈是由系统自动分配的，申请效率高但程序员无法控制；堆是由程序员主动申请的，效率低，使用起来方便但是容易产生碎片。</li><li>存放内容：栈中存放的是局部变量，函数的参数；堆中存放的内容是由程序员控制的。</li></ul><p><a href="https://blog.csdn.net/hairetz/article/details/4141043">参考链接</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;内存分区模型&quot;&gt;&lt;a href=&quot;#内存分区模型&quot; class=&quot;headerlink&quot; title=&quot;内存分区模型&quot;&gt;&lt;/a&gt;内存分区模型&lt;/h1&gt;&lt;p&gt;目前网络上主要有两种内存分区方法：&lt;/p&gt;
&lt;h2 id=&quot;四区&quot;&gt;&lt;a href=&quot;#四区&quot; class=</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="内存" scheme="http://isgoudan.top/tags/%E5%86%85%E5%AD%98/"/>
    
    <category term="堆" scheme="http://isgoudan.top/tags/%E5%A0%86/"/>
    
    <category term="栈" scheme="http://isgoudan.top/tags/%E6%A0%88/"/>
    
    <category term="自由存储区" scheme="http://isgoudan.top/tags/%E8%87%AA%E7%94%B1%E5%AD%98%E5%82%A8%E5%8C%BA/"/>
    
  </entry>
  
  <entry>
    <title>const小结</title>
    <link href="http://isgoudan.top/2021/05/16/const%E5%B0%8F%E7%BB%93/"/>
    <id>http://isgoudan.top/2021/05/16/const%E5%B0%8F%E7%BB%93/</id>
    <published>2021-05-16T08:53:16.000Z</published>
    <updated>2021-05-28T08:58:18.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="const-分类"><a href="#const-分类" class="headerlink" title="const 分类"></a>const 分类</h1><h3 id="顶层const："><a href="#顶层const：" class="headerlink" title="顶层const："></a>顶层const：</h3><ul><li>顶层const可以表示任意的对象是常量，例如常量指针，指针本身为常量。<font color=#FF0000>顶层const作用于对象本身。</font></li></ul><h3 id="底层const："><a href="#底层const：" class="headerlink" title="底层const："></a>底层const：</h3><ul><li>底层const与指针和引用等复合类型部分有关，例如指针所指对象是常量。</li></ul><p><strong>Eg:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p1 = &amp;i;        <span class="comment">// 顶层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> c1 = <span class="number">42</span>;         <span class="comment">// 顶层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p2 = &amp;c1;       <span class="comment">// 底层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> p3 = p2; <span class="comment">// 左边底层， 右边顶层</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r = ci;         <span class="comment">// 用于声明引用的是底层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = <span class="number">42</span>;        <span class="comment">// 允许为一个常量引用绑定非常量的对象、字面值、甚至是个一般表达式</span></span><br></pre></td></tr></table></figure><h4 id="注："><a href="#注：" class="headerlink" title="注："></a><font color=red>注：</font></h4><ul><li>顶层const形参无法重载函数</li></ul><p><strong>Eg:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lookup</span><span class="params">(Phone)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Phone)</span></span>;  <span class="comment">// 等价的重复声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lookup</span><span class="params">(Phone*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lookup</span><span class="params">(Phone* <span class="keyword">const</span>)</span></span>; <span class="comment">// 等价的重复声明</span></span><br></pre></td></tr></table></figure><ul><li>底层const形参可实现函数重载</li></ul><p><strong>Eg：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lookup</span><span class="params">(Phone&amp;)</span></span>;       <span class="comment">// 作用于Phone的引用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Phone&amp;)</span></span>; <span class="comment">// 作用于Phone的常量引用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loohup</span><span class="params">(Phone*)</span></span>;       <span class="comment">// 作用于指向Phone的指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Phone*)</span></span>; <span class="comment">// 作用于指向Phone常量的指针</span></span><br></pre></td></tr></table></figure><p>当传递非常量对象或指向非常量对象的指针时，会优先选用非常量版本。</p><h1 id="const-用法"><a href="#const-用法" class="headerlink" title="const 用法"></a>const 用法</h1><ul><li><p>const修饰成员变量，定义成const常量，相较于宏常量，可进行类型检查，节省内存空间，提高了效率；const成员变量要进行初始化。</p></li><li><p>const修饰函数参数，使得传递过来的函数参数的值不能改变。</p></li><li><p>const修饰成员函数（常函数），使得成员函数不能修改任何类型的成员变量（mutable修饰的变量除外，函数参数也除外），也不能调用非const成员函数，因为非const成员函数可能会修改成员变量。</p></li><li><p>const修饰对象（常对象），只能调用常函数，不可调用普通成员函数，因为普通函数可以修改属性；同时不能对成员变量进行修改。</p></li></ul><h1 id="const注意事项"><a href="#const注意事项" class="headerlink" title="const注意事项"></a>const注意事项</h1><h2 id="const成员变量"><a href="#const成员变量" class="headerlink" title="const成员变量"></a>const成员变量</h2><ul><li><p>const成员变量只能在类内声明、定义，在构造函数初始化列表中初始化，注意在构造函数函数体内部叫赋值（经测试在声明时初始化也可，尽量不要，原因见下条）。</p></li><li><p>const成员变量只在某个对象的生存周期内时常量，对于整个类而言是可变的，因为类可以创建多个对象，不同对象的const成员变量值不同，所以不能在类的声明中初始化const成员变量，因为类的对象还没有创建，编译器不知道他的值。</p></li></ul><h2 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h2><ul><li>不能修改成员变量的值，除非有mutable修饰；只能访问成员变量。</li><li>不能调用非常量成员的函数，以防修改成员变量的值。</li></ul><h1 id="define和const的区别（编译阶段、安全性、内存占用等）"><a href="#define和const的区别（编译阶段、安全性、内存占用等）" class="headerlink" title="define和const的区别（编译阶段、安全性、内存占用等）"></a>define和const的区别（编译阶段、安全性、内存占用等）</h1><ul><li>编译阶段：define是在编译预处理阶段起作用，const是在编译阶段和程序运行阶段起作用。</li><li>安全性：define定义的宏常量没有数据类型，只是进行简单的替换，不会进行类型安全的检查；const定义的只读变量是有类型的，需要进行判断，可以避免一些低级错误。</li><li>内存占用：define定义的宏常量，在程序中使用多少次就会进行多少次替换，内存中有多个备份；const定义的只读变量在程序运行过程中只有一份。</li><li>调试：define定义的不能调试，因为在预编译阶段就进行替换了；const定义的可以进行调试。</li></ul><h1 id="const的优点"><a href="#const的优点" class="headerlink" title="const的优点"></a>const的优点</h1><ul><li>有数据类型，在定义时可进行安全性检查</li><li>可调试</li><li>占用较少的空间</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;const-分类&quot;&gt;&lt;a href=&quot;#const-分类&quot; class=&quot;headerlink&quot; title=&quot;const 分类&quot;&gt;&lt;/a&gt;const 分类&lt;/h1&gt;&lt;h3 id=&quot;顶层const：&quot;&gt;&lt;a href=&quot;#顶层const：&quot; class=&quot;head</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="const" scheme="http://isgoudan.top/tags/const/"/>
    
  </entry>
  
</feed>
