<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>is_Goudan’s Blog</title>
  
  
  <link href="http://isgoudan.top/atom.xml" rel="self"/>
  
  <link href="http://isgoudan.top/"/>
  <updated>2022-02-25T06:56:44.849Z</updated>
  <id>http://isgoudan.top/</id>
  
  <author>
    <name>Gou Daner</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>适配器</title>
    <link href="http://isgoudan.top/2022/02/25/%E9%80%82%E9%85%8D%E5%99%A8/"/>
    <id>http://isgoudan.top/2022/02/25/%E9%80%82%E9%85%8D%E5%99%A8/</id>
    <published>2022-02-25T05:40:02.661Z</published>
    <updated>2022-02-25T06:56:44.849Z</updated>
    
    <content type="html"><![CDATA[<h1 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h1><h2 id="函数适配器"><a href="#函数适配器" class="headerlink" title="函数适配器"></a>函数适配器</h2><p><strong>一元转二元：</strong></p><ul><li>bind2nd 绑定第二个参数。</li><li>继承binary_function&lt;参数类型1, 参数类型2, 返回值类型&gt;。</li><li>const修饰operator()。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrint</span>:</span> <span class="keyword">public</span> binary_fuction&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">void</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> start)</span>  <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; num+start &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; a&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    cin&lt;&lt;start;</span><br><span class="line">    for_each(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">MyPront</span>(), start));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="取反适配器"><a href="#取反适配器" class="headerlink" title="取反适配器"></a>取反适配器</h2><p>一元取反：</p><ul><li>not1()。</li><li>继承unary_function&lt;参数类型1,  返回值类型 &gt;。</li><li>const修饰。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreaterFive</span>:</span> <span class="keyword">public</span> unary_function&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt; <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 一元取反</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">not1</span>(<span class="built_in">GreatrerFive</span>()));  <span class="comment">//  找不大于5的 返回0。</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数指针适配器"><a href="#函数指针适配器" class="headerlink" title="函数指针适配器"></a>函数指针适配器</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyPrint03</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; v+ start &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tets03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">ptr_fun</span>(<span class="built_in">MyPrint03</span>()), <span class="number">100</span>)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="成员函数适配器"><a href="#成员函数适配器" class="headerlink" title="成员函数适配器"></a>成员函数适配器</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">int</span> age) : <span class="built_in">mAge</span>(age) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; mAge &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;Person&gt; p;</span><br><span class="line">    p.<span class="built_in">push_back</span>(<span class="built_in">Person</span>(<span class="number">1</span>));</span><br><span class="line">    p.<span class="built_in">push_back</span>(<span class="built_in">Person</span>(<span class="number">2</span>));</span><br><span class="line">    p.<span class="built_in">push_back</span>(<span class="built_in">Person</span>(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    for_each(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>(), <span class="built_in">mem_fun_ref</span>(&amp;Person::showAge));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;适配器&quot;&gt;&lt;a href=&quot;#适配器&quot; class=&quot;headerlink&quot; title=&quot;适配器&quot;&gt;&lt;/a&gt;适配器&lt;/h1&gt;&lt;h2 id=&quot;函数适配器&quot;&gt;&lt;a href=&quot;#函数适配器&quot; class=&quot;headerlink&quot; title=&quot;函数适配器&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="适配器" scheme="http://isgoudan.top/tags/%E9%80%82%E9%85%8D%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>仿函数、谓词和lambda表达式</title>
    <link href="http://isgoudan.top/2022/02/25/%E4%BB%BF%E5%87%BD%E6%95%B0%E3%80%81%E8%B0%93%E8%AF%8D%E5%92%8Clambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://isgoudan.top/2022/02/25/%E4%BB%BF%E5%87%BD%E6%95%B0%E3%80%81%E8%B0%93%E8%AF%8D%E5%92%8Clambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2022-02-25T03:08:04.709Z</published>
    <updated>2022-02-25T05:40:22.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数对象（仿函数）"><a href="#函数对象（仿函数）" class="headerlink" title="函数对象（仿函数）"></a>函数对象（仿函数）</h1><p>​        重载函数调用操作符的类，其对象称为函数对象，即其行为类似函数的对象，又称为仿函数。重载了“（）”使其可以向函数一样调用。</p><p><strong>注意 ：</strong></p><ul><li>函数对象（仿函数）是一个类，不是一个函数。</li><li>函数对象（仿函数）重载了“（）”使其可以向函数一样调用。</li></ul><p><strong>分类：</strong></p><ul><li>一元仿函数：一个参数。</li><li>二元仿函数：两个参数。</li></ul><h1 id="内建仿函数"><a href="#内建仿函数" class="headerlink" title="内建仿函数"></a>内建仿函数</h1><ul><li>头文件：<code>#include&lt;functional&gt;</code></li><li>取反仿函数：<code>template&lt;class T&gt; T negate&lt;T&gt;</code></li><li>加法仿函数：<code>template&lt;class T&gt; T plus&lt;T&gt;</code> </li><li>大于仿函数：<code>template&lt;class T&gt; bool greater&lt;T&gt;</code></li><li>小于仿函数：<code>template&lt;class T&gt; bool less&lt;T&gt;</code></li><li>….</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">negate&lt;<span class="keyword">int</span>&gt; n;</span><br><span class="line">cout &lt;&lt; <span class="built_in">n</span>(<span class="number">10</span>) &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    plus&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">plus</span>(<span class="number">1</span>,<span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; a &#123;<span class="number">1</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());  <span class="comment">// 7 7 6 4 3 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h1><p>​        谓词就是一个判断式，是一个返回bool类型的函数，或者也可以是函数对象（仿函数）。一个参数是一元谓词，两个参数是二元谓词。</p><h1 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h1><ul><li>写法：<code>[](参数列表) &#123; 函数内容 &#125;</code>。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;函数对象（仿函数）&quot;&gt;&lt;a href=&quot;#函数对象（仿函数）&quot; class=&quot;headerlink&quot; title=&quot;函数对象（仿函数）&quot;&gt;&lt;/a&gt;函数对象（仿函数）&lt;/h1&gt;&lt;p&gt;​        重载函数调用操作符的类，其对象称为函数对象，即其行为类似函数的对象</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="仿函数" scheme="http://isgoudan.top/tags/%E4%BB%BF%E5%87%BD%E6%95%B0/"/>
    
    <category term="谓词" scheme="http://isgoudan.top/tags/%E8%B0%93%E8%AF%8D/"/>
    
    <category term="lambda" scheme="http://isgoudan.top/tags/lambda/"/>
    
  </entry>
  
  <entry>
    <title>Linux基础知识点</title>
    <link href="http://isgoudan.top/2022/02/24/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://isgoudan.top/2022/02/24/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2022-02-24T07:01:28.387Z</published>
    <updated>2022-02-26T07:02:41.218Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><table><thead><tr><th>命令</th><th>执行操作</th></tr></thead><tbody><tr><td>history</td><td>查看历史命令</td></tr><tr><td>ls</td><td>查看文件目录    -l 显示详细信息    -a 显示隐藏目录    -R递归显示子目录信息</td></tr><tr><td>cd</td><td>更改目录</td></tr><tr><td>pwd</td><td>查看当前的工作目录</td></tr><tr><td>mkdir</td><td>创建目录</td></tr><tr><td>tree</td><td>目录成树状显示</td></tr><tr><td>rmdir</td><td>删除目录，只能删非空目录</td></tr><tr><td>which</td><td>显示对应命令所在的路径</td></tr><tr><td>touch</td><td>创建文件，如果不存在创建，如果存在则只更改访问时间</td></tr><tr><td>rm</td><td>删除文件或者目录  -r 递归删除子目录    rm -rf * 强制删除目录下所有内容</td></tr><tr><td>cp</td><td>拷贝文件或者目录</td></tr><tr><td>mv</td><td>移动文件或者目录</td></tr><tr><td>cat</td><td>直接显示文件信息</td></tr><tr><td>more和less</td><td>分屏显示文件信息</td></tr><tr><td>head</td><td>head -n file 显示文件头n行，不加-n默认10行</td></tr><tr><td>tail</td><td>tail -n file 显示文件后n行；tail -f file 查看文件尾部内容，不退出，用于追踪日志</td></tr><tr><td>du</td><td>-h 查看文件占用空间</td></tr><tr><td>ln</td><td>建立硬连接   ln hello hello.hard1   见下图 ；  ln -s hello hello.hard3  建立软连接</td></tr><tr><td>unlink</td><td>删除软硬连接</td></tr><tr><td>chmod</td><td>改变文件权限</td></tr><tr><td>chown</td><td>改变文件所属权限  sudo chown   用户：组  文件名|目录</td></tr><tr><td>find</td><td>find dir [opt] 内容     opt：-name  -type  -size        按名字、类型、大小找文件</td></tr><tr><td>grep</td><td>过滤信息</td></tr><tr><td>xargs</td><td>将前一目录的输出分成小块输入给后面的命令</td></tr><tr><td>zip</td><td>zip -r zipname.zip filename1 filename2 …   压缩文件  -r递归子目录</td></tr><tr><td>unzip</td><td>unzip zipname.zip  解压文件</td></tr><tr><td>tar</td><td>tar zcvf zipname.tar.gz filename1 filename2 …  压缩文件 <br />tar zxvf zipname.tar.gz  解压文件</td></tr><tr><td>rar</td><td>rar a -r rarname（可以无后缀） filename1 filename2 …  压缩文件<br />rar x rarname.rar 解压文件</td></tr><tr><td></td><td></td></tr></tbody></table><h1 id="小知识点"><a href="#小知识点" class="headerlink" title="小知识点"></a>小知识点</h1><p><strong>通配符*和？：</strong>* 代表任意多个字符，? 代表任意一个字符。</p><p><strong>相对路径和绝对路径：</strong> 以”/“开头为绝对路径，否则为相对路径。 </p><p><font color=red>linux一切皆文件。</font></p><p><strong>文件权限表示法：</strong></p><p><img src="https://s2.loli.net/2022/02/26/aCGT69pZHrv8cnO.png" alt="image.png"></p><p><strong>硬连接：</strong></p><ul><li>文件指向同一块磁盘块，只要有一个文件内容变了，建立连接的文件也跟着变。</li></ul><p><strong>软连接：</strong></p><ul><li>相当于创建快捷方式。</li></ul><p><img src="https://s2.loli.net/2022/02/26/dSngu69ODZKw2Vp.png" alt="image.png"></p><p><strong>类unix系统目录结构：</strong></p><p><img src="https://s2.loli.net/2022/02/26/NRCgm4r6dMULqFb.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;常用命令&quot;&gt;&lt;a href=&quot;#常用命令&quot; class=&quot;headerlink&quot; title=&quot;常用命令&quot;&gt;&lt;/a&gt;常用命令&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;执行操作&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tb</summary>
      
    
    
    
    <category term="Linux" scheme="http://isgoudan.top/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://isgoudan.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>C++STL</title>
    <link href="http://isgoudan.top/2022/02/23/STL/"/>
    <id>http://isgoudan.top/2022/02/23/STL/</id>
    <published>2022-02-23T03:17:51.490Z</published>
    <updated>2022-02-24T06:23:21.752Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>​        STL广义上分为：容器（container）、算法（algorithm）、迭代器（iterator）。容器和算法通过迭代器进行无缝连接。</p><p>​        STL细分为六大组件：容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器。</p><ul><li>容器：各种数据结构，如vector、list、deque、set、map等，用来存放数据。从实现角度看，STL容器是一种class template。</li><li>算法：各种常用算法，如sort、find、copy、for_each。从实现角度看，STL算法是一种function template。</li><li>迭代器：扮演了容器和算法之间的调和剂，共5种类型（输入、输出、前向、双向、随机访问）。从实现角度看，迭代器是一种将operator*，operator-&gt;，operator++，operator–等指针相关操作予以重载的class template，所有的STL容器都有自己的专属迭代器。原生指针（native pointer）也是一种迭代器。</li><li>仿函数：行为类似函数，可作为算法的某种策略。从实现角度看，仿函数是一种重载了operator()的class或者class template。</li><li>适配器：一种用来修饰容器或者仿函数迭代器接口的东西。</li><li>空间配置器：负责空间的配置与管理。从实现角度看，配置器是一个实现了动态空间配置、空间管理、空间释放的class template。</li></ul><p>​        STL六大组件的交互关系：容器通过空间配置器取得数据存储空间，算法通过迭代器存储容器中的内容，仿函数可以协助算法完成不同策略得变化，适配器可以修饰仿函数。</p><h1 id="STL优点"><a href="#STL优点" class="headerlink" title="STL优点"></a>STL优点</h1><ul><li>STL为C++一部分，不用额外安装。</li><li>STL一个重要特性是将数据和操作分离，数据由容器类别加以管理，操作则由可定制的算法定义。迭代器在两者之间充当“粘合剂”，以使算法可以和容器交互运作。</li><li>程序员不用考虑STL内部实现，直接使用。</li><li>STL具有高可重用性，高性能，高移植性，跨平台的优点。<ul><li>高可重用性：STL几乎所有代码都采用模板类和模板函实现，相比于传统的函数和类提供了更好的代码重用机会。</li><li>高性能：如map可以高效从大量数据在检索指定记录，因为采用红黑树。</li><li>高移植性：如在项目A使用STL编写模块，可以直接移植到项目B。</li></ul></li></ul><h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><ul><li>序列式容器：强调值的顺序，每个元素均有固定位置，除非用插入删除操作改变，如vector、deque、list等。</li><li>关联式容器：非线性的二叉树结构，个元素间没有严格的物理上得顺序关系，也就是说元素在容器中并没有保存元素置入容器时的逻辑顺序。关联式容器一个显著特点：在值中选择一个值作为关键字key，key起到索引的作用，方便查找。如set、multiset、map、multimap等。 </li></ul><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><ul><li>质变算法：运算过程中改变区间内元素内容。如拷贝，替换，删除等。</li><li>非质变算法：运算过程中不改变区间内元素内容。如查找，计数，遍历等。</li></ul><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>​        提供一种方法，使之能够依序遍历某个容器所含的各个元素，而又无需暴露该容器内部的表示方式。</p><table><thead><tr><th>名称</th><th>功能</th><th>支持操作</th></tr></thead><tbody><tr><td>输入迭代器</td><td>提供对数据的只读访问</td><td>只读，支持++，–，!=</td></tr><tr><td>输出迭代器</td><td>提供对数据的只写访问</td><td>只写，支持++</td></tr><tr><td>前向迭代器</td><td>提供读写操作，并向前推进迭代器</td><td>读写，支持++，==，!=</td></tr><tr><td>双向迭代器</td><td>提供读写操作，并能向前和向后操作</td><td>读写，支持++,–，==，!=</td></tr><tr><td>随机访问迭代器</td><td>提供读写操作，并能以跳跃的方式访问容器的任意数据，功能最强。</td><td>读写，支持++，–，[n]，-n，&lt;，&lt;=，&gt;，&gt;=, ==，!=</td></tr></tbody></table><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><ul><li>s[]访问和s.at()访问区别：[]访问越界会直接挂掉，at则抛出异常。</li><li>string -&gt; const char* :   <code>const char *p = s.c_str();</code> 。</li><li>const char* -&gt; string：<code>string s2(p);</code>。</li><li>C++存在const char*到string的隐式类型转换，不存在从string到const char*的隐式类型转换。</li></ul><h1 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h1><ul><li><p>vector所谓的动态增加大小，并不是在原有空间之后虚接新空间，而是找一块更大空间，将原数据拷贝，然后释放原空间。所以一旦引起空间配置，则原有的迭代器失效。</p></li><li><p>利用swap收缩空间：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;    <span class="comment">// &gt;10000</span></span><br><span class="line">    cout &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// = 10000</span></span><br><span class="line">    </span><br><span class="line">    v.<span class="built_in">resize</span>(<span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;    <span class="comment">// &gt;10000  和之前一样</span></span><br><span class="line">    cout &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// = 3</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 巧用swap</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;(v).<span class="built_in">swap</span>(v);<span class="comment">// v初始化匿名对象，交换两个指针，然后释放掉匿名对象（那个大的就被释放了）</span></span><br><span class="line">    cout &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;    <span class="comment">// = 3  </span></span><br><span class="line">    cout &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// = 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>reserve(int len);</code>容器预留len个元素长度，预留位置不初始化，元素不可访问。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(p != &amp;v[<span class="number">0</span>]) &#123;  <span class="comment">// 查看开辟10万个数据重新开辟多少次空间。</span></span><br><span class="line">            p = &amp;v[<span class="number">0</span>];</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; num &lt;&lt; endl; <span class="comment">// &gt;1,好多次</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 改进：</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    v1.<span class="built_in">reserve</span>(<span class="number">100000</span>);</span><br><span class="line">    <span class="keyword">int</span> *p1 = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(p1 != &amp;v[<span class="number">0</span>]) &#123;  <span class="comment">// 查看开辟10万个数据重新开辟多少次空间。</span></span><br><span class="line">            p1 = &amp;v[<span class="number">0</span>];</span><br><span class="line">            num1++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; num1 &lt;&lt; endl; <span class="comment">//  = 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>s[]访问和s.at()访问区别：[]访问越界会直接挂掉，at则抛出异常。</p></li></ul><h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><ul><li>没有迭代器，不提供遍历功能。</li></ul><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><ul><li><p>双向循环链表。</p></li><li><p>不支持随机访问。</p></li><li><p>所有不支持随机访问的迭代器，不可以用系统提供的算法，但是这个类内部会提供。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="keyword">int</span>&gt; L&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(L.<span class="built_in">begin</span>(), L.<span class="built_in">end</span>());  <span class="comment">// 报错</span></span><br><span class="line">L.<span class="built_in">sort</span>();</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;p&gt;​        STL广义上分为：容器（container）、算法（algorithm）、迭代器（iterator）。容器</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="STL" scheme="http://isgoudan.top/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>进程和线程</title>
    <link href="http://isgoudan.top/2022/02/22/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%EF%BC%88%EF%BC%89/"/>
    <id>http://isgoudan.top/2022/02/22/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%EF%BC%88%EF%BC%89/</id>
    <published>2022-02-22T12:09:07.884Z</published>
    <updated>2022-02-26T09:06:56.845Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>​        进程是操作系统中最重要的抽象概念之一，是资源分配的基本单位，是独立运行的基本单位。</p><p>​        进程的经典定义就是一个执行。中程序的实例。系统中的每个程序都运行在某个进程的上下文（context）中。上下文是由程序正确运行所需的状态组成。这个状态包括存放在内存中的程序代码和数据，他的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。</p><p>进程一般由以下部分组成：</p><ul><li>进程控制块PCB，是进程存在的唯一标志，包含进程标识符PID、进程当前状态、程序、数据地址、进程优先级、CPU现场保护区（用于进程切换）、占有的资源清单等等。</li><li>程序段。</li><li>数据段。</li></ul><h2 id="进程的基本操作"><a href="#进程的基本操作" class="headerlink" title="进程的基本操作"></a>进程的基本操作</h2><h2 id="简述进程间通信方法"><a href="#简述进程间通信方法" class="headerlink" title="简述进程间通信方法"></a>简述进程间通信方法</h2><p>​        每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程A把数据从用户空间拷到内核缓冲区，进程B再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信。</p><p>​        不同进程间的通信本质：进程之间可以看到一份公共资源；而提供这份资源的形式或者提供者不同，造成了通信方式的不同。</p><h2 id="进程的状态与状态转换"><a href="#进程的状态与状态转换" class="headerlink" title="进程的状态与状态转换"></a>进程的状态与状态转换</h2><h2 id="进程如何通过管道进行通信"><a href="#进程如何通过管道进行通信" class="headerlink" title="进程如何通过管道进行通信"></a>进程如何通过管道进行通信</h2><h2 id="进程如何通过共享内存通信"><a href="#进程如何通过共享内存通信" class="headerlink" title="进程如何通过共享内存通信"></a>进程如何通过共享内存通信</h2><h2 id="进程调度的时机"><a href="#进程调度的时机" class="headerlink" title="进程调度的时机"></a>进程调度的时机</h2><h2 id="不能进行进程调度的情况"><a href="#不能进行进程调度的情况" class="headerlink" title="不能进行进程调度的情况"></a>不能进行进程调度的情况</h2><h2 id="进程的调度策略"><a href="#进程的调度策略" class="headerlink" title="进程的调度策略"></a>进程的调度策略</h2><h2 id="进程调度策略的基本设计指标"><a href="#进程调度策略的基本设计指标" class="headerlink" title="进程调度策略的基本设计指标"></a>进程调度策略的基本设计指标</h2><h2 id="孤儿进程和僵尸进程"><a href="#孤儿进程和僵尸进程" class="headerlink" title="孤儿进程和僵尸进程"></a>孤儿进程和僵尸进程</h2><h2 id="进程同步的方法"><a href="#进程同步的方法" class="headerlink" title="进程同步的方法"></a>进程同步的方法</h2><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><h2 id="为什么需要线程"><a href="#为什么需要线程" class="headerlink" title="为什么需要线程"></a>为什么需要线程</h2><h2 id="线程同步的方法"><a href="#线程同步的方法" class="headerlink" title="线程同步的方法"></a>线程同步的方法</h2><h2 id="线程和进程的区别和联系"><a href="#线程和进程的区别和联系" class="headerlink" title="线程和进程的区别和联系"></a>线程和进程的区别和联系</h2><h2 id="进程和线程的基本API"><a href="#进程和线程的基本API" class="headerlink" title="进程和线程的基本API"></a>进程和线程的基本API</h2><h2 id="进程同步和线程同步的区别"><a href="#进程同步和线程同步的区别" class="headerlink" title="进程同步和线程同步的区别"></a>进程同步和线程同步的区别</h2><h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><h2 id="什么是信号"><a href="#什么是信号" class="headerlink" title="什么是信号"></a>什么是信号</h2><h2 id="如何编写正确且安全的信号处理函数"><a href="#如何编写正确且安全的信号处理函数" class="headerlink" title="如何编写正确且安全的信号处理函数"></a>如何编写正确且安全的信号处理函数</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; title=&quot;进程&quot;&gt;&lt;/a&gt;进程&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;​  </summary>
      
    
    
    
    <category term="OS" scheme="http://isgoudan.top/categories/OS/"/>
    
    
    <category term="面经" scheme="http://isgoudan.top/tags/%E9%9D%A2%E7%BB%8F/"/>
    
    <category term="OS" scheme="http://isgoudan.top/tags/OS/"/>
    
    <category term="进程" scheme="http://isgoudan.top/tags/%E8%BF%9B%E7%A8%8B/"/>
    
    <category term="线程" scheme="http://isgoudan.top/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>内存泄露</title>
    <link href="http://isgoudan.top/2022/02/22/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <id>http://isgoudan.top/2022/02/22/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</id>
    <published>2022-02-22T12:06:36.573Z</published>
    <updated>2022-02-23T07:34:48.943Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h1><p>​        内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是<a href="http://baike.baidu.com/view/330120.htm">应用程序</a>分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。</p><h1 id="内存是如何泄露的？"><a href="#内存是如何泄露的？" class="headerlink" title="内存是如何泄露的？"></a>内存是如何泄露的？</h1><ul><li>堆区数据未被释放。</li></ul><h1 id="C-中的内存泄露该如何避免？"><a href="#C-中的内存泄露该如何避免？" class="headerlink" title="C++ 中的内存泄露该如何避免？"></a>C++ 中的内存泄露该如何避免？</h1><ul><li>避免在堆区开辟数据。</li><li>使用智能指针，而不是手动管理内存。</li><li>使用 std::string 来替代 char*。</li><li>善用 RAII（Resource Acquisition Is Initialization）思想：在类的构造函数中分配资源，在类的析构函数中释放资源。</li></ul><h1 id="如果发生了内存泄露，该如何定位问题代码？"><a href="#如果发生了内存泄露，该如何定位问题代码？" class="headerlink" title="如果发生了内存泄露，该如何定位问题代码？"></a>如果发生了内存泄露，该如何定位问题代码？</h1><ul><li>使用工具软件BoundsChecker，BoundsChecker是一个运行时错误检测工具，它主要定位程序运行时期发生的各种错误。</li><li>调试运行DEBUG版程序，运用以下技术：CRT(C run-time libraries)、运行时函数调用堆栈、内存泄漏时提示的内存分配序号(集成开发环境OUTPUT窗口)，综合分析内存泄漏的原因，排除内存泄漏。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;内存泄漏&quot;&gt;&lt;a href=&quot;#内存泄漏&quot; class=&quot;headerlink&quot; title=&quot;内存泄漏&quot;&gt;&lt;/a&gt;内存泄漏&lt;/h1&gt;&lt;p&gt;​        内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="面经" scheme="http://isgoudan.top/tags/%E9%9D%A2%E7%BB%8F/"/>
    
    <category term="内存" scheme="http://isgoudan.top/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>文件读写</title>
    <link href="http://isgoudan.top/2022/02/22/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/"/>
    <id>http://isgoudan.top/2022/02/22/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/</id>
    <published>2022-02-22T07:00:58.804Z</published>
    <updated>2022-02-22T07:17:31.528Z</updated>
    
    <content type="html"><![CDATA[<h1 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h1><ul><li>头文件<code>#include&lt;fstream&gt;</code></li></ul><h2 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// 以输出方式打开文件</span></span><br><span class="line">    <span class="comment">//  ofstream ofs(&quot;./test.txt&quot;, ios::out | ios::trunc);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 也可以后期指定打开方式</span></span><br><span class="line">    ofstream ofs;</span><br><span class="line">    ofs.<span class="built_in">open</span>(<span class="string">&quot;./test.txt&quot;</span>, ios::out | ios::trunc);</span><br><span class="line">    <span class="keyword">if</span>(!ofs.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;open fail&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ofs&lt;&lt;<span class="string">&quot;goudan&quot;</span>&lt;&lt;endl;</span><br><span class="line">    ofs&lt;&lt;<span class="string">&quot;11&quot;</span>&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// 以输出方式打开文件</span></span><br><span class="line">    <span class="comment">//  ifstream ifs(&quot;./test.txt&quot;, ios::in);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 也可以后期指定打开方式</span></span><br><span class="line">    ifstream ifs;</span><br><span class="line">    ifs.<span class="built_in">open</span>(<span class="string">&quot;./test.txt&quot;</span>, ios::out | ios::trunc);</span><br><span class="line">    <span class="keyword">if</span>(!ifs.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;open fail&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第一种方式</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span>(ifs&gt;&gt;buf) &#123; <span class="comment">// 按行读取</span></span><br><span class="line">cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第二种方式</span></span><br><span class="line">    <span class="keyword">char</span> buf2[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span>(ifs.<span class="built_in">eof</span>()) &#123;<span class="comment">// eof读到文件尾</span></span><br><span class="line">ifs.<span class="built_in">getline</span>(buf2, <span class="built_in"><span class="keyword">sizeof</span></span>(buf2));</span><br><span class="line">        cout &lt;&lt; buf2 &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第三种方式，不推荐，按单个字符读取</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">while</span>(c = ifs.<span class="built_in">get</span>() != EOF) &#123; <span class="comment">// EOF文件尾</span></span><br><span class="line">        cout &lt;&lt; c;</span><br><span class="line">    &#125;</span><br><span class="line">    ifs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;读写文件&quot;&gt;&lt;a href=&quot;#读写文件&quot; class=&quot;headerlink&quot; title=&quot;读写文件&quot;&gt;&lt;/a&gt;读写文件&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;头文件&lt;code&gt;#include&amp;lt;fstream&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 i</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="文件操作" scheme="http://isgoudan.top/tags/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>输入输出流</title>
    <link href="http://isgoudan.top/2022/02/22/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/"/>
    <id>http://isgoudan.top/2022/02/22/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/</id>
    <published>2022-02-22T06:44:12.954Z</published>
    <updated>2022-02-22T07:01:12.360Z</updated>
    
    <content type="html"><![CDATA[<h1 id="标准输入流"><a href="#标准输入流" class="headerlink" title="标准输入流"></a>标准输入流</h1><ul><li><code>cin.get(一个参数)</code>缓冲区中读取一个字符。</li><li><code> cin.get(两个参数)</code>读取字符串，不读换行符。</li><li><code>cin.getline()</code>读取字符串，读取换行符并扔掉。</li><li><code>cin.ignore(N)</code>忽略N个字符。</li><li><code>cin.peek()</code>偷窥，偷看一个字符然后放回缓冲区 。</li><li><code>cin.putback(c)</code>把字符c放回缓冲区。</li><li><code>cin.fail()</code>看标志位，0正常，1不正常。</li><li><code>cin.clear()</code>重置标志位。</li><li><code>cib.sync()</code>清空缓冲区。</li></ul><h1 id="标准输出流"><a href="#标准输出流" class="headerlink" title="标准输出流"></a>标准输出流</h1><ul><li><code>cout.flush</code>刷新缓冲区，Linux有效。</li><li><code>cout.put()</code> 向缓冲区写字符。</li><li><code>cout.write()</code>从缓冲区写num个字节到当前输出流中。</li></ul><p><img src="https://s2.loli.net/2022/02/22/H1IZo4N5h6X7Dji.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;标准输入流&quot;&gt;&lt;a href=&quot;#标准输入流&quot; class=&quot;headerlink&quot; title=&quot;标准输入流&quot;&gt;&lt;/a&gt;标准输入流&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cin.get(一个参数)&lt;/code&gt;缓冲区中读取一个字符。&lt;/li&gt;
&lt;li&gt;&lt;code</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="IO" scheme="http://isgoudan.top/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>C++异常</title>
    <link href="http://isgoudan.top/2022/02/21/C++%E5%BC%82%E5%B8%B8/"/>
    <id>http://isgoudan.top/2022/02/21/C++%E5%BC%82%E5%B8%B8/</id>
    <published>2022-02-21T06:33:07.439Z</published>
    <updated>2022-02-22T06:44:11.033Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><ul><li>基本思想：将问题检测和问题处理相分离。</li><li>try试图执行try{}中的内容。</li><li>在可能出现异常的地方抛出异常 eg： throw -1； </li><li>try下面catch捕获异常。</li><li>catch(捕获类型)   …代表所有其他类型。</li><li>如果不能处理异常，继续向上抛出  thow；</li><li>如果没有任何处理异常的地方，那么程序调用terminate函数终止程序 。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myDevide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="number">-1</span>;  <span class="comment">// 抛出int异常</span></span><br><span class="line">        <span class="comment">// throw 3.14;  抛出double异常</span></span><br><span class="line">        <span class="comment">// throw &quot;a&quot;;</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="built_in">myDevide</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">int</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;int error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">double</span>) &#123;</span><br><span class="line">        <span class="comment">// throw;  如果加上这个，则异常向上反馈，最后只输出 main double error</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;double error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(...) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;other error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">test01</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">double</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;main double error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h1><h2 id="自己写类"><a href="#自己写类" class="headerlink" title="自己写类"></a>自己写类</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;自定义 error&quot;</span> &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myDevide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">MyException</span>();  <span class="comment">// 匿名对象    </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="built_in">myDevide</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(MyException e) &#123;</span><br><span class="line">e.<span class="built_in">prinError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承系统中自带的"><a href="#继承系统中自带的" class="headerlink" title="继承系统中自带的"></a>继承系统中自带的</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyOutOfRangeException</span> :</span> <span class="keyword">public</span> exception &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyOutOfRangeException</span>(string errorInfo) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_ErrorInfo = errorInfo;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">MyOutOfRangeException</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> cont <span class="keyword">char</span>* <span class="title">what</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_ErrorInfo.<span class="built_in">c_str</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    string m_ErrorInfo;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h1 id="栈解旋"><a href="#栈解旋" class="headerlink" title="栈解旋"></a>栈解旋</h1><ul><li>从try开始到throw抛出异常前，所有栈上的对象都会被释放，这个过程称为栈解旋。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;自定义 error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myDevide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 栈解旋</span></span><br><span class="line">        <span class="comment">// 从try开始到throw抛出异常前，所有栈上的对象都会被释放，这个过程称为栈解旋。</span></span><br><span class="line">        Person p1;</span><br><span class="line">        Person p2;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">MyException</span>();  <span class="comment">// 匿名对象    </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="built_in">myDevide</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(MyException e) &#123;</span><br><span class="line">e.<span class="built_in">prinError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">p1构造</span></span><br><span class="line"><span class="comment">p2构造</span></span><br><span class="line"><span class="comment">p2析构</span></span><br><span class="line"><span class="comment">p1析构</span></span><br><span class="line"><span class="comment">自定义 error</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="异常接口声明"><a href="#异常接口声明" class="headerlink" title="异常接口声明"></a>异常接口声明</h1><ul><li>抛出特定类型异常。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该代码不能在VS里运行，可以在QT和linux运行。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="title">throw</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span>)</span>  </span>&#123;<span class="comment">// throw(int)只能抛出int类型异常 throw()不抛出任何类型异常</span></span><br><span class="line"><span class="keyword">throw</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">int</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;int error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="异常变量的生命周期"><a href="#异常变量的生命周期" class="headerlink" title="异常变量的生命周期"></a>异常变量的生命周期</h1><ul><li>如果<code>catch(MyException e)</code> 会多开销一份数据，调用拷贝构造。</li><li>如果<code>catch(MyException *e)</code>，如果不new会提前释放对象，new需要自己释放delete。</li><li>推荐<code>catch(MyException &amp;e)</code>，只一份数据。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyException</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;MyException moren gouzao&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">MyException</span>(<span class="keyword">const</span> MyException &amp;e) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;MyException kaobei gouzao&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;自定义 error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">MyException</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;MyException xigou&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">MyException</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">doWork</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(MyException &amp;e) &#123; <span class="comment">// MyException e会多开销一份数据</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;catch error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">输出catch(MyException e)情况：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">MyException moren gouzao</span></span><br><span class="line"><span class="comment">MyException kaobei gouzao</span></span><br><span class="line"><span class="comment">catch error</span></span><br><span class="line"><span class="comment">MyException xigou</span></span><br><span class="line"><span class="comment">MyException xigou</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注：编译器会做优化，不会立刻将匿名对象释放掉，所以可以改为 catch(MyException &amp;e)减少开销。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="异常的多态使用"><a href="#异常的多态使用" class="headerlink" title="异常的多态使用"></a>异常的多态使用</h1><ul><li>利用多态实现<code>printError()</code>同一个接口调用。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseException</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">printError</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NullPointException</span> :</span> <span class="keyword">public</span> BaseException  &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt;  <span class="string">&quot;Null Point Error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">NullPointException</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">doWork</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(BaseException &amp;e) &#123;</span><br><span class="line">        e.<span class="built_in">printError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="系统标准异常使用"><a href="#系统标准异常使用" class="headerlink" title="系统标准异常使用"></a>系统标准异常使用</h1><ul><li>头文件<code>#include&lt;stdexcept&gt;</code>。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">if</span>(age &lt; <span class="number">0</span> || age &gt; <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;年龄越界！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span>  </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="number">1000</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(out_of_range &amp;e) &#123;</span><br><span class="line">        cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;  <span class="comment">// 年龄越界！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本思想&quot;&gt;&lt;a href=&quot;#基本思想&quot; class=&quot;headerlink&quot; title=&quot;基本思想&quot;&gt;&lt;/a&gt;基本思想&lt;/h1&gt;&lt;h1 id=&quot;异常&quot;&gt;&lt;a href=&quot;#异常&quot; class=&quot;headerlink&quot; title=&quot;异常&quot;&gt;&lt;/a&gt;异常&lt;/h</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="异常" scheme="http://isgoudan.top/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>C++类型转换</title>
    <link href="http://isgoudan.top/2022/02/20/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>http://isgoudan.top/2022/02/20/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</id>
    <published>2022-02-20T06:18:06.186Z</published>
    <updated>2022-02-21T06:33:04.791Z</updated>
    
    <content type="html"><![CDATA[<h1 id="静态类型转换（static-cast）"><a href="#静态类型转换（static-cast）" class="headerlink" title="静态类型转换（static_cast）"></a>静态类型转换（static_cast）</h1><ul><li><p>写法<code>static_cast&lt;目标类型&gt;(原始对象)</code>。</p></li><li><p>可以进行基础类型转换。</p></li><li><p>父与子的class可以转换。</p></li><li><p>没有父子关系的class不可以转换。</p></li></ul><h1 id="动态类型转换（dynamic-cast）"><a href="#动态类型转换（dynamic-cast）" class="headerlink" title="动态类型转换（dynamic_cast）"></a>动态类型转换（dynamic_cast）</h1><ul><li><p>写法<code>dynamic_cast&lt;目标类型&gt;(原始对象)</code>。</p></li><li><p>不可以转换基础数据类型。</p></li><li><p>父子间可以转换。</p><ul><li>一般父转子，不可以。</li><li>子转父，可以。</li><li>如果发生多态，都可以。</li></ul></li></ul><h1 id="常量转换（const-cast）"><a href="#常量转换（const-cast）" class="headerlink" title="常量转换（const_cast）"></a>常量转换（const_cast）</h1><ul><li><p>写法<code>const_cast&lt;目标类型&gt;(原始对象)</code>。</p></li><li><p>用来修改类型的const属性。</p><ul><li>常量指针和非常量指针相互转换，并且仍然指向原来对象。</li><li>常量引用和非常量引用相互转换，并且仍然指向原来对象。</li></ul></li></ul><p>​    <font color=red><strong>注意：不能对非指针和非引用的变量使用const_cast操作符去移除他的const。</strong></font></p><h1 id="重新解释转换（reinterpret-cast）"><a href="#重新解释转换（reinterpret-cast）" class="headerlink" title="重新解释转换（reinterpret_cast）"></a>重新解释转换（reinterpret_cast）</h1><ul><li><p>写法<code>reinterpret_cast&lt;目标类型&gt;(原始对象)</code>。</p></li><li><p>什么都可以转，最不安全，不推荐。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;静态类型转换（static-cast）&quot;&gt;&lt;a href=&quot;#静态类型转换（static-cast）&quot; class=&quot;headerlink&quot; title=&quot;静态类型转换（static_cast）&quot;&gt;&lt;/a&gt;静态类型转换（static_cast）&lt;/h1&gt;&lt;ul&gt;
</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="类型转换" scheme="http://isgoudan.top/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>C++模板</title>
    <link href="http://isgoudan.top/2022/02/18/C++%E6%A8%A1%E6%9D%BF/"/>
    <id>http://isgoudan.top/2022/02/18/C++%E6%A8%A1%E6%9D%BF/</id>
    <published>2022-02-18T06:45:18.207Z</published>
    <updated>2022-02-21T03:19:21.851Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h1><p>​        函数模板实际上是建立一个通用函数，其函数类型和形参类型不具体制定用一个虚拟的类型来代表，这个通用函数就是函数模板。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型参数化，泛型编程</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span>  <span class="comment">// 告诉编译器，T是一个通用类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap</span><span class="params">(T &amp;a, T &amp;b)</span> </span>&#123;</span><br><span class="line">    T tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// typename和class二者没啥区别,等价</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 自动类型推导</span></span><br><span class="line">    <span class="built_in">mySwap</span>(a, b);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 显式指定类型</span></span><br><span class="line">    mySwap&lt;<span class="keyword">int</span>&gt;(a, b);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 模板必须指定出T才可以使用。</span></span><br><span class="line">    <span class="built_in">func</span>();  <span class="comment">// 报错</span></span><br><span class="line">    func&lt;<span class="keyword">int</span>&gt;(); <span class="comment">// 正常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数模板和普通函数区别以及调用规则"><a href="#函数模板和普通函数区别以及调用规则" class="headerlink" title="函数模板和普通函数区别以及调用规则"></a>函数模板和普通函数区别以及调用规则</h1><p><strong>区别:</strong></p><ul><li>函数模板不能进行隐式类型转换，普通函数可以。</li></ul><p><strong>调用规则：</strong></p><ul><li>c++编译器优先考虑普通函数。</li><li>可以通过空模板实参列表的语法限定编译器只能通过模板匹配。</li><li>函数模板可以向普通函数一样被重载。</li><li>如果函数模板可以产生一个更好的匹配，优先使用函数模板。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt; </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPlus</span><span class="params">(T &amp;a, T &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPlus01</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">myPlus</span>(a, c); <span class="comment">// 报错，不能执行</span></span><br><span class="line">    <span class="built_in">myPlus2</span>(a, c); <span class="comment">// 可以执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数和函数模板的调用规则</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt; </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(T &amp;a, T &amp;b)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;函数模板print&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt; </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(T &amp;a, T &amp;b, T &amp;c)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;重载函数模板print&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;普通函数print&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果出现重载，优先使用普通函数调用，如果普通函数只声明没有实现，会出现错误</span></span><br><span class="line"><span class="built_in">myPrint</span>(a, b); <span class="comment">// 普通函数print</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果想强制使用模板，可以使用空参数列表</span></span><br><span class="line">    myPrint&lt;&gt;(a, b);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 函数模板可以发生重载</span></span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">30</span>;</span><br><span class="line">    <span class="built_in">myPrint</span>(a, b, c);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果函数模板可以产生更好的匹配，优先使用函数模板</span></span><br><span class="line">    <span class="keyword">char</span> d = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">    <span class="keyword">char</span> e = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line"><span class="built_in">myPrint</span>(d, e); <span class="comment">// 调用函数模板</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="模板机制"><a href="#模板机制" class="headerlink" title="模板机制"></a>模板机制</h1><ul><li>模板不是万能的，不能适用所有的数据类型。</li><li>函数模板通过具体类型产生不同的函数。</li><li>编译器对函数模板进行<strong>两次</strong>编译，在声明地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译（替换后代码称为模板函数）。</li></ul><h1 id="模板局限性及解决"><a href="#模板局限性及解决" class="headerlink" title="模板局限性及解决"></a>模板局限性及解决</h1><ul><li>模板不能解决所有的类型。</li><li>如果出现不能解决的类型，可以通过第三代具体化进行解决。</li><li>语法<code>template &lt;&gt; 返回值 函数名&lt;具体类型&gt;(参数)&#123;&#125;</code>       返回值和函数名必须和模板一致。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="keyword">int</span> age) : <span class="built_in">mName</span>(name), <span class="built_in">mAge</span>(age)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    string mName;</span><br><span class="line">    <span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCompare</span><span class="params">(T &amp;a, T &amp;b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a == b) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过第三代具体化自定义数据类型解决问题</span></span><br><span class="line"><span class="comment">// 如果具体化能够优先匹配，那么选择具体化</span></span><br><span class="line"><span class="comment">// 语法template &lt;&gt; 返回值 函数名&lt;具体类型&gt;(参数)      返回值和函数名必须和模板一致</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">bool</span> myCompare&lt;Person&gt;(Person &amp;a, Person &amp;b) &#123;</span><br><span class="line"><span class="keyword">if</span>(a.mAge == b.mAge) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;jerry&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="built_in">myCompare</span>(p1, p2);  <span class="comment">// 如果没具体化自定义实现会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h1><ul><li>写法：<code>template&lt;class T, ...&gt;</code> 紧跟着类。</li><li>相比于函数模板，类模板可以有默认类型参数。</li><li>函数模板可以进行自动类型推导，类模板不可以。</li><li>成员函数一开始不会创建，在运行时才会创建。</li></ul><p><strong>类模板做函数的参数的三种方式：</strong></p><ul><li>显式指定类型</li><li>参数模板化</li><li>整体模板化</li></ul><p><strong>查看类型名称的方式：</strong><code>typeid(T1).name</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">NameType</span>, <span class="keyword">class</span> <span class="title">AgeType</span> =</span> <span class="keyword">int</span>&gt;  <span class="comment">// 类模板可以有默认类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(NameType name, Agetype age) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;age:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    NameType m_Name;</span><br><span class="line">    AgeType m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 类模板不支持自动类型推导</span></span><br><span class="line">    <span class="comment">// Person p(&quot;goudan&quot;, 100);   会出错</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">Person&lt;string, <span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;goudan&quot;</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传参方式</span></span><br><span class="line"><span class="comment">// 1.指定传入类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork1</span><span class="params">(Person&lt;string, <span class="keyword">int</span>&gt; &amp;p)</span> </span>&#123;</span><br><span class="line">    p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.参数模板化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T1, class T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork2</span><span class="params">(Person&lt;T1, T2&gt; &amp;p)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 如何查看类型</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(T1).name &lt;&lt; endl;</span><br><span class="line">    p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.整体模板化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork3</span><span class="params">(T &amp;p)</span> </span>&#123;</span><br><span class="line">p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person&lt;string, <span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;goudan&quot;</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="built_in">doWork1</span>(p);</span><br><span class="line">    <span class="built_in">doWork2</span>(p);</span><br><span class="line">    <span class="built_in">doWork3</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类模板碰到继承的问题"><a href="#类模板碰到继承的问题" class="headerlink" title="类模板碰到继承的问题"></a>类模板碰到继承的问题</h1><ul><li>基类如果是模板类，必须让子类告诉编译器基类中的T是什么类型。否则无法分配内存，编译不通过。</li><li>利用参数列表<code>class Child : public Base&lt;int&gt;</code> </li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// child继承base必须告诉base中T的类型，否则无法分配内存</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Base&lt;<span class="keyword">int</span>&gt; &#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// child2 也是模板类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child2</span> :</span> <span class="keyword">public</span> Base&lt;T2&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T1 m_B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Child2&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt; c2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>类模板类外实现成员函数：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">NameType</span>, <span class="keyword">class</span> <span class="title">AgeType</span>&gt;</span>  <span class="comment">// 类模板可以有默认类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(NameType name, Agetype age); </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    NameType m_Name;</span><br><span class="line">    AgeType m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">NameType</span>, <span class="keyword">class</span> <span class="title">AgeType</span>&gt;</span></span><br><span class="line">Person&lt;NameType, AgeType&gt;::<span class="built_in">Person</span>(NameType name, Agetype age) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">NameType</span>, <span class="keyword">class</span> <span class="title">AgeType</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> Person&lt;NameType, AgeType&gt;::<span class="built_in">showPerson</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color=red><strong>注意：类模板不要用分文件编写，如果用正常的分文件编写会出现问题，因为类模板成员函数一开始不会创建，在运行时才会创建，导致包含.h头文件，不会创建函数实现，无法解析外部命令，所以在检查#include“Person.h”不会有问题，但是到链接阶段会链接不到成员函数，可以改成#include“Person.cpp”（但是一般不这么做，一般解决方案为：把实现和声明放在一个文件下，改名为hpp文件，hpp一般为模板）</strong></font></p><h1 id="类模板碰到友元函数"><a href="#类模板碰到友元函数" class="headerlink" title="类模板碰到友元函数"></a>类模板碰到友元函数</h1><p><strong>友元函数类内实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">printPerson</span><span class="params">(Person&lt;T1, T2&gt; &amp;p)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; p.m_Name &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(T1 name, T2 age) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;age:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 m_Name;</span><br><span class="line">    T2 m_Age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>友元函数类外实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 让编译器看到printPErson,否则编译器看不到他的声明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 让编译器看到Person类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span><span class="class"><span class="keyword">class</span> <span class="title">Person</span>;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span><span class="function"><span class="keyword">void</span> <span class="title">printPerson</span><span class="params">(Person&lt;T1, T2&gt; &amp;p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="comment">// 友元函数类外实现，利用空参数列表&lt;&gt;告诉编译器这是模板函数声明，否则是普通函数声明</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> printPerson&lt;&gt;(Person&lt;T1, T2&gt; &amp;p);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(T1 name, T2 age) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;age:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 m_Name;</span><br><span class="line">    T2 m_Age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T1, class T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPerson</span><span class="params">(Person&lt;T1, T2&gt; &amp;p)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; p.m_Name &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;函数模板&quot;&gt;&lt;a href=&quot;#函数模板&quot; class=&quot;headerlink&quot; title=&quot;函数模板&quot;&gt;&lt;/a&gt;函数模板&lt;/h1&gt;&lt;p&gt;​        函数模板实际上是建立一个通用函数，其函数类型和形参类型不具体制定用一个虚拟的类型来代表，这个通用函数就是函</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="模板" scheme="http://isgoudan.top/tags/%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>C++多态</title>
    <link href="http://isgoudan.top/2022/01/17/C++%E5%A4%9A%E6%80%81/"/>
    <id>http://isgoudan.top/2022/01/17/C++%E5%A4%9A%E6%80%81/</id>
    <published>2022-01-17T07:33:27.666Z</published>
    <updated>2022-02-18T06:35:35.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><ul><li><p>C++支持编译时多态（静态多态）和运行时多态（动态多态）。重载–静态多态。虚函数和继承–动态多态。</p></li><li><p>静态多态和动态多态的区别就是函数地址是早绑定（静态连编，编译阶段绑定好地址）还是晚绑定（动态联编，运行时绑定好地址）。</p></li><li><p>什么叫多态？</p><ul><li>父类的引用或指针指向子类对象。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;   <span class="comment">// 改为 virtual void speak()</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;animal speak&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cat</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;  <span class="comment">// 子类中的 virtual 可写可不写</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;cat speak&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数func里， speak函数的地址早就绑定好了，在编译阶段就确定了地址</span></span><br><span class="line"><span class="comment">// 如果像调用cat的speak，不能提前绑定好函数地址，所以需要在运行的时候再去确定函数地址</span></span><br><span class="line"><span class="comment">// 动态联编写法：把speak（）在父类声明为虚函数，就发生了多态</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Animal &amp;animal)</span> </span>&#123;</span><br><span class="line">    animal.<span class="built_in">speak</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Cat cat;</span><br><span class="line">    <span class="built_in">func</span>(cat);  <span class="comment">// animal speak;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="多态内部原理"><a href="#多态内部原理" class="headerlink" title="多态内部原理"></a>多态内部原理</h1><ul><li>Animal 内部结构<ul><li><p>Animal 内部存在一个vfptr（virtual function pointer）虚函数表指针。</p></li><li><p>虚函数表指针指向虚函数表。</p></li><li><p>当Cat中没有写speak函数时，Cat的vfptr指向Animal speak函数，如下图：</p></li><li><p><img src="https://s2.loli.net/2022/01/18/XW46U1CHu3JRas8.png" alt="image.png"></p></li><li><p>当Cat中重写了speak函数后，Cat的vfptr指向自己的cat speak函数（对象创建的时候，调用构造函数，将所有的虚函数指针都指向自己的虚函数表，这个操作我们看不到），如下图：</p></li><li><p><img src="https://s2.loli.net/2022/01/18/u7mxhFrbGjA6kvI.png" alt="image.png"></p></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(Animal) &lt;&lt; endl;  <span class="comment">// 没加virtual时是1，加了以后是4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>深入剖析内部调用</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Animal * animal = <span class="keyword">new</span> Cat;</span><br><span class="line">    <span class="comment">// (*(int *)*(int *)animal) 为函数地址</span></span><br><span class="line">    ((<span class="built_in"><span class="keyword">void</span></span>(*)()) (*(<span class="keyword">int</span> *)*(<span class="keyword">int</span> *)animal))();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h1><ul><li>如果父类有纯虚函数，子类继承父类，子类必须将其实现，否则子类也是一个抽象类。</li><li>如果父类有纯虚函数，那么父类不能实例化对象。</li><li>如果类有了纯虚函数，通常称为抽象类。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;   <span class="comment">// 虚函数</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;animal speak&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 纯虚函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h1><ul><li>虚析构解决问题：是为了delete基类指针指向派生类时防止子类的数据不会被释放造成内存泄露。</li><li>纯虚析构：<ul><li>纯虚析构，需要声明，还需要实现，类内声明，类外实现。</li><li>如果类中出现纯虚析构，那么这个类也算抽象类。</li><li>抽象类不能实例化对象。</li></ul></li><li>虚析构和纯虚析构区别：纯虚析构的类不能实例化对象。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Animal speak&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 普通析构 不会调用子类的析构，所以可能导致释放不干净</span></span><br><span class="line">    <span class="comment">// 利用虚析构解决该问题</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Animal xigou&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 纯虚析构</span></span><br><span class="line">    <span class="comment">// 纯虚析构，需要声明，还需要实现，类内声明，类外实现</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal::~<span class="built_in">Animal</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Animal chunxu&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cat</span>(<span class="keyword">const</span> <span class="keyword">char</span> * name) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;mName = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(name) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;name, name);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Cat speak&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">Cat</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Cat xigou&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;mName != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;mName;</span><br><span class="line">            <span class="keyword">this</span>-&gt;mName = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>* mName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Animal * cat = <span class="keyword">new</span> <span class="built_in">Cat</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    animal-&gt;<span class="built_in">speak</span>();   <span class="comment">// Cat speak</span></span><br><span class="line">    <span class="keyword">delete</span> animal;  <span class="comment">// 父类析构函数没加virtual：Animal xigou</span></span><br><span class="line">    <span class="comment">// 父类改成虚析构后： Cat xigou</span></span><br><span class="line">    <span class="comment">//   Animal xigou</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;多态&quot;&gt;&lt;a href=&quot;#多态&quot; class=&quot;headerlink&quot; title=&quot;多态&quot;&gt;&lt;/a&gt;多态&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;C++支持编译时多态（静态多态）和运行时多态（动态多态）。重载–静态多态。虚函数和继承–动态多态。&lt;/p&gt;
&lt;/li&gt;
&lt;</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="多态" scheme="http://isgoudan.top/tags/%E5%A4%9A%E6%80%81/"/>
    
    <category term="抽象类" scheme="http://isgoudan.top/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    
    <category term="纯虚函数" scheme="http://isgoudan.top/tags/%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
    <category term="虚函数" scheme="http://isgoudan.top/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>C++继承</title>
    <link href="http://isgoudan.top/2022/01/15/C++%E7%BB%A7%E6%89%BF/"/>
    <id>http://isgoudan.top/2022/01/15/C++%E7%BB%A7%E6%89%BF/</id>
    <published>2022-01-15T07:10:38.731Z</published>
    <updated>2022-02-18T06:19:42.645Z</updated>
    
    <content type="html"><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><ul><li>解决代码的复用。</li><li>语法： class 子类 ： 继承方式  父类</li></ul><h1 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h1><ul><li>三种：public、private、protected</li></ul><p><img src="https://s2.loli.net/2022/01/16/x3k79EPCJQdefIL.png" alt="QQ截图20220116151208.png"></p><ul><li>子类会继承父类的所有内容，包括私有属性，只是被编译器隐藏起来，访问不到私有成员。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>()&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(Son) &lt;&lt; endl;   <span class="comment">// 输出16；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="继承中的构造和析构函数"><a href="#继承中的构造和析构函数" class="headerlink" title="继承中的构造和析构函数"></a>继承中的构造和析构函数</h1><ul><li>子类会继承父类的成员属性和成员函数，但是子类不会继承父类的构造函数和析构函数。只有父类自己知道如何构造和析构自己的属性，而子类不知道。另外operator=也不会继承下来。</li><li>子类创建对象时，会先调用父类的构造，然后调用自身的构造。</li><li>析构顺序和构造顺序正好相反。</li><li>当父类的构造函数有参数时，需要在子类初始化列表（参数列表）中显式调用父类的构造函数。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base2</span>(<span class="keyword">int</span> a) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;有参构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son2</span> :</span> <span class="keyword">public</span> Base2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Son2() &#123;&#125;   // 报错，不存在无参构造</span></span><br><span class="line">    <span class="built_in">Son2</span>(<span class="keyword">int</span> a) : <span class="built_in">Base2</span>(a) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="继承中的同名处理"><a href="#继承中的同名处理" class="headerlink" title="继承中的同名处理"></a>继承中的同名处理</h1><ul><li>如果子类和父类拥有同名的属性和函数，子类不会覆盖父类成员，加作用域就可调父类的。</li><li>如果子类与父类的成员函数名称相同，子类会把父类的<strong>所有</strong>同名版本都隐藏掉，想调用必须加作用域。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123;</span><br><span class="line">        m_A = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base func&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Son</span>() &#123;</span><br><span class="line">        m_A = <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Son func&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Son S1;</span><br><span class="line">    cout &lt;&lt; s1.m_A &lt;&lt; endl;  <span class="comment">// cout 200</span></span><br><span class="line">    cout &lt;&lt; s1.Base::m_A &lt;&lt;endl;  <span class="comment">// cout 100</span></span><br><span class="line"></span><br><span class="line">    s1.<span class="built_in">func</span>();</span><br><span class="line">    s1.Base::<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="继承中静态成员的处理"><a href="#继承中静态成员的处理" class="headerlink" title="继承中静态成员的处理"></a>继承中静态成员的处理</h1><ul><li>静态成员属性，子类可以继承下来。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Base::m_A = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; Son::m_A &lt;&lt;endl;  <span class="comment">// cout 10;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base func&quot;</span> &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base func(int)&quot;</span> &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Base::m_A = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Son func&quot;</span> &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Son::m_A = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; Son::m_A &lt;&lt;endl;  <span class="comment">// cout 20;</span></span><br><span class="line">    cout &lt;&lt; Base::m_A &lt;&lt;endl;  <span class="comment">// cout 10;</span></span><br><span class="line"></span><br><span class="line">    Son::<span class="built_in">func</span>();      <span class="comment">// Son func</span></span><br><span class="line">    Base::<span class="built_in">func</span>();    <span class="comment">// Base func</span></span><br><span class="line">    Son::Base::<span class="built_in">func</span>(<span class="number">10</span>);    <span class="comment">// Base func(int)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h1><ul><li>多继承中很容易引发二义性问题</li><li>语法 ： class Son : public Base1, public Base2 {}</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base1</span>() &#123;</span><br><span class="line">        m_A = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base2</span>() &#123;</span><br><span class="line">        m_A = <span class="number">20</span>;</span><br><span class="line">    &#125;A</span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_C;</span><br><span class="line">    <span class="keyword">int</span> m_D;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(Son) &lt;&lt; endl;     <span class="comment">// 16</span></span><br><span class="line"></span><br><span class="line">    Son s1;</span><br><span class="line">    <span class="comment">// s1.m_A;        // 二义性 error</span></span><br><span class="line">    cout &lt;&lt; s1.Base1::m_A &lt;&lt; endl;  <span class="comment">// 10</span></span><br><span class="line">    cout &lt;&lt; s1.Base2::m_A &lt;&lt; endl;  <span class="comment">// 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="菱形继承和虚继承"><a href="#菱形继承和虚继承" class="headerlink" title="菱形继承和虚继承"></a>菱形继承和虚继承</h1><ul><li>菱形继承存在部分数据重复继承两份的问题，为解决该问题，采用虚继承的方式。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tuo</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SheepTuo</span> :</span> <span class="keyword">public</span> Sheep, <span class="keyword">public</span> Tuo &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SheepTuo st;</span><br><span class="line">    st.Sheep::m_Age = <span class="number">10</span>;</span><br><span class="line">    st.Tuo::m_Age = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">// 存在两份数据，造成资源浪费</span></span><br><span class="line">    cout &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;   <span class="comment">// 10</span></span><br><span class="line">    cout &lt;&lt; st.Tuo::m_Age &lt;&lt; endl;     <span class="comment">// 20;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用虚继承解决：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tuo</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SheepTuo</span> :</span> <span class="keyword">public</span> Sheep, <span class="keyword">public</span> Tuo &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 虚继承后操作一份共享数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SheepTou st;</span><br><span class="line">    st.Sheep::m_Age = <span class="number">10</span>;</span><br><span class="line">    st.Tuo::m_Age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;   <span class="comment">// 20</span></span><br><span class="line">    cout &lt;&lt; st.Tuo::m_Age &lt;&lt; endl;     <span class="comment">// 20;</span></span><br><span class="line">    cout &lt;&lt; st.m_Age &lt;&lt; endl;         <span class="comment">// 此时可以直接访问，没有二义性的情况了，只有一份m_Age</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/01/16/TdmLwOuqiYxXVaM.png" alt="QQ截图20220116203008.png"></p><h1 id="向上类型转换和向下类型转换"><a href="#向上类型转换和向下类型转换" class="headerlink" title="向上类型转换和向下类型转换"></a>向上类型转换和向下类型转换</h1><ul><li>基类转派生类。<ul><li>向下类型转换   安全的。</li></ul></li><li>派生类转基类。<ul><li>向上类型转换  不安全。</li></ul></li><li>如果发生了多态。<ul><li>总是安全的。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;解决代码的复用。&lt;/li&gt;
&lt;li&gt;语法： class 子类 ： 继承方式  父类&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;继承方</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="继承" scheme="http://isgoudan.top/tags/%E7%BB%A7%E6%89%BF/"/>
    
    <category term="父类子类转换" scheme="http://isgoudan.top/tags/%E7%88%B6%E7%B1%BB%E5%AD%90%E7%B1%BB%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>四旋翼仿真控制模块</title>
    <link href="http://isgoudan.top/2022/01/15/%E5%9B%9B%E6%97%8B%E7%BF%BC%E4%BB%BF%E7%9C%9F%E5%90%84%E6%A8%A1%E5%9D%97%E6%A2%B3%E7%90%86/"/>
    <id>http://isgoudan.top/2022/01/15/%E5%9B%9B%E6%97%8B%E7%BF%BC%E4%BB%BF%E7%9C%9F%E5%90%84%E6%A8%A1%E5%9D%97%E6%A2%B3%E7%90%86/</id>
    <published>2022-01-14T16:11:29.100Z</published>
    <updated>2022-01-15T02:58:45.788Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PositionControl"><a href="#PositionControl" class="headerlink" title="PositionControl"></a>PositionControl</h1><p>​        以下模块参照PX4源码。</p><h2 id="positionControl"><a href="#positionControl" class="headerlink" title="_positionControl"></a>_positionControl</h2><p>所需数据：_pos_sp 和 _pos 和 _gain_pos_p 和 _lim_vel_horizontal</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> PositionControl::_positionControl() &#123;</span><br><span class="line">    <span class="comment">// P-position controller  对位置进行p比例控制</span></span><br><span class="line">    Vector3f vel_sp_position = (_pos_sp - _pos).<span class="built_in">emult</span>(_gain_pos_p);</span><br><span class="line">    <span class="comment">// Position and feed-forward velocity setpoints or position states being NAN results in them not having an influence位置和前馈速度设定点或位置状态为 NAN 导致它们没有影响</span></span><br><span class="line">    _vel_sp += vel_sp_position;</span><br><span class="line">    <span class="comment">// 确保没有NAN</span></span><br><span class="line">    <span class="comment">// ControlMath::setZeroIfNanVector3f(vel_sp_position); </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过优先考虑沿方向的速度分量来约束水平速度</span></span><br><span class="line">    <span class="comment">// 前馈项上的期望位置设定值。</span></span><br><span class="line">    _vel_sp.<span class="built_in">xy</span>() = ControlMath::<span class="built_in">constrainXY</span>(vel_sp_position.<span class="built_in">xy</span>(), (_vel_sp - vel_sp_position).<span class="built_in">xy</span>(), _lim_vel_horizontal);  <span class="comment">// _lim_vel_horizontal水平速度限制</span></span><br><span class="line">    <span class="comment">// Constrain velocity in z-direction. 可以不考虑z轴</span></span><br><span class="line">    <span class="comment">// _vel_sp(2) = math::constrain(_vel_sp(2), -_lim_vel_up, _lim_vel_down);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="velocityControl"><a href="#velocityControl" class="headerlink" title="_velocityControl"></a>_velocityControl</h2><p>来自_positionControl： _vel_sp </p><p>所需数据： _vel 和 _gain_vel_p 和 _gain_vel_d</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> PositionControl::_velocityControl(<span class="keyword">const</span> <span class="keyword">float</span> dt) &#123;</span><br><span class="line"><span class="comment">// PID velocity control</span></span><br><span class="line">    Vector3f vel_error = _vel_sp - _vel;  <span class="comment">// 速度误差</span></span><br><span class="line">    Vector3f acc_sp_velocity = vel_error.<span class="built_in">emult</span>(_gain_vel_p) + _vel_int - _vel_dot.<span class="built_in">emult</span>(_gain_vel_d);  <span class="comment">// emult是乘 _gain_vel_p </span></span><br><span class="line">    <span class="comment">// 如果acc_sp_velocity不是NAN值，就加到期望加速度里，</span></span><br><span class="line">    _acc_sp += acc_sp_velocity； <span class="comment">// _acc_sp 期望加速度</span></span><br><span class="line"></span><br><span class="line">    _accelerationControl();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 垂直方向积分器抗饱和  感觉没用</span></span><br><span class="line"><span class="comment">//if ((_thr_sp(2) &gt;= -_lim_thr_min &amp;&amp; vel_error(2) &gt;= 0.0f) ||</span></span><br><span class="line"><span class="comment">//    (_thr_sp(2) &lt;= -_lim_thr_max &amp;&amp; vel_error(2) &lt;= 0.0f)) &#123;</span></span><br><span class="line"><span class="comment">//vel_error(2) = 0.f;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在保持水平边距的同时，优先考虑垂直控制</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> Vector2f <span class="title">thrust_sp_xy</span><span class="params">(_thr_sp)</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> thrust_sp_xy_norm = thrust_sp_xy.<span class="built_in">norm</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> thrust_max_squared = math::<span class="built_in">sq</span>(_lim_thr_max);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 确定在保持水平边距的情况下还剩下多少垂直推力  这部分应该不重要</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> allocated_horizontal_thrust = math::<span class="built_in">min</span>(thrust_sp_xy_norm, _lim_thr_xy_margin);  <span class="comment">// 分配的水平推力</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> thrust_z_max_squared = thrust_max_squared - math::<span class="built_in">sq</span>(allocated_horizontal_thrust);    <span class="comment">// 推力 z 最大平方</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 饱和最大垂直推力  感觉没用</span></span><br><span class="line">    _thr_sp(<span class="number">2</span>) = math::<span class="built_in">max</span>(_thr_sp(<span class="number">2</span>), -<span class="built_in">sqrtf</span>(thrust_z_max_squared));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 确定优先垂直控制后还剩多少水平推力</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> thrust_max_xy_squared = thrust_max_squared - math::<span class="built_in">sq</span>(_thr_sp(<span class="number">2</span>));</span><br><span class="line"><span class="keyword">float</span> thrust_max_xy = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (thrust_max_xy_squared &gt; <span class="number">0</span>) &#123;</span><br><span class="line">thrust_max_xy = <span class="built_in">sqrtf</span>(thrust_max_xy_squared);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 水平方向饱和推力</span></span><br><span class="line"><span class="keyword">if</span> (thrust_sp_xy_norm &gt; thrust_max_xy) &#123;</span><br><span class="line">_thr_sp.<span class="built_in">xy</span>() = thrust_sp_xy / thrust_sp_xy_norm * thrust_max_xy;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 水平方向使用跟踪 Anti-Windup：在饱和期间，积分器用于使输出不饱和</span></span><br><span class="line"><span class="comment">// see Anti-Reset Windup for PID controllers, L.Rundqwist, 1990</span></span><br><span class="line">    <span class="comment">// 参见 PID 控制器的防复位饱和，L.Rundqwist，1990</span></span><br><span class="line"><span class="keyword">const</span> Vector2f acc_sp_xy_limited = <span class="built_in">Vector2f</span>(_thr_sp) * (CONSTANTS_ONE_G / _hover_thrust);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> arw_gain = <span class="number">2.f</span> / _gain_vel_p(<span class="number">0</span>);</span><br><span class="line">vel_error.<span class="built_in">xy</span>() = <span class="built_in">Vector2f</span>(vel_error) - (arw_gain * (<span class="built_in">Vector2f</span>(_acc_sp) - acc_sp_xy_limited));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保积分不会得到 NAN</span></span><br><span class="line">ControlMath::<span class="built_in">setZeroIfNanVector3f</span>(vel_error);</span><br><span class="line"><span class="comment">// 更新速度控制的组成部分</span></span><br><span class="line">_vel_int += vel_error.<span class="built_in">emult</span>(_gain_vel_i) * dt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 限制推力积分</span></span><br><span class="line">_vel_int(<span class="number">2</span>) = math::<span class="built_in">min</span>(<span class="built_in">fabsf</span>(_vel_int(<span class="number">2</span>)), CONSTANTS_ONE_G) * <span class="built_in">sign</span>(_vel_int(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="accelerationControl"><a href="#accelerationControl" class="headerlink" title="_accelerationControl"></a>_accelerationControl</h2><p>最终给出期望推力</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> PositionControl::_accelerationControl()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 假设在垂直方向上由于重力产生的标准加速度用于姿态生成</span></span><br><span class="line">Vector3f body_z = <span class="built_in">Vector3f</span>(-_acc_sp(<span class="number">0</span>), -_acc_sp(<span class="number">1</span>), CONSTANTS_ONE_G).<span class="built_in">normalized</span>();</span><br><span class="line">ControlMath::<span class="built_in">limitTilt</span>(body_z, <span class="built_in">Vector3f</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>), _lim_tilt);</span><br><span class="line"><span class="comment">// 假设悬停推力产生标准重力的比例推力</span></span><br><span class="line"><span class="keyword">float</span> collective_thrust = _acc_sp(<span class="number">2</span>) * (_hover_thrust / CONSTANTS_ONE_G) - _hover_thrust;</span><br><span class="line"><span class="comment">// Project thrust to planned body attitude</span></span><br><span class="line">collective_thrust /= (<span class="built_in">Vector3f</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>).<span class="built_in">dot</span>(body_z));</span><br><span class="line">collective_thrust = math::<span class="built_in">min</span>(collective_thrust, -_lim_thr_min);</span><br><span class="line">_thr_sp = body_z * collective_thrust;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;PositionControl&quot;&gt;&lt;a href=&quot;#PositionControl&quot; class=&quot;headerlink&quot; title=&quot;PositionControl&quot;&gt;&lt;/a&gt;PositionControl&lt;/h1&gt;&lt;p&gt;​        以下模块参照PX4</summary>
      
    
    
    
    <category term="UAV Simulation" scheme="http://isgoudan.top/categories/UAV-Simulation/"/>
    
    
    <category term="UAV" scheme="http://isgoudan.top/tags/UAV/"/>
    
  </entry>
  
  <entry>
    <title>智能指针</title>
    <link href="http://isgoudan.top/2022/01/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <id>http://isgoudan.top/2022/01/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</id>
    <published>2022-01-14T11:43:39.996Z</published>
    <updated>2022-01-15T15:41:27.603Z</updated>
    
    <content type="html"><![CDATA[<h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><p>​        用来托管自定义类型的对象，让对象进行自动释放</p><p> <a href="%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD.md">运算符重载.md</a> 里有相关内容</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;智能指针&quot;&gt;&lt;a href=&quot;#智能指针&quot; class=&quot;headerlink&quot; title=&quot;智能指针&quot;&gt;&lt;/a&gt;智能指针&lt;/h1&gt;&lt;p&gt;​        用来托管自定义类型的对象，让对象进行自动释放&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;%E8%BF%90%E7%</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="智能指针" scheme="http://isgoudan.top/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>运算符重载</title>
    <link href="http://isgoudan.top/2022/01/14/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    <id>http://isgoudan.top/2022/01/14/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</id>
    <published>2022-01-14T08:03:59.128Z</published>
    <updated>2022-01-17T07:40:58.633Z</updated>
    
    <content type="html"><![CDATA[<h1 id="左移运算符重载"><a href="#左移运算符重载" class="headerlink" title="左移运算符重载"></a>左移运算符重载</h1><ul><li>必须写在写在全局函数中，如果重载时想访问类的私有成员，需要将全局函数作类的友元。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;cout, Person &amp;A) &#123;</span><br><span class="line">    cout &lt;&lt; A.mA;</span><br><span class="line">    <span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="加法运算符重载"><a href="#加法运算符重载" class="headerlink" title="加法运算符重载"></a>加法运算符重载</h1><ul><li>可以在成员函数进行重载，也可以在全局函数重载。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person <span class="keyword">operator</span>+(Person &amp;A, Person&amp; B) &#123;  <span class="comment">// 全局方式  ，局部只需要把参数改下，返回this指针就行</span></span><br><span class="line">Person temp;</span><br><span class="line">    temp.mA = A.mA + B.mA;</span><br><span class="line">    temp.mB = A.mB + B.mB;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="前置递增运算符重载"><a href="#前置递增运算符重载" class="headerlink" title="前置递增运算符重载"></a>前置递增运算符重载</h1><ul><li>可以在成员函数进行重载，也可以在全局函数重载。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInteger</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyInteger</span>() &#123;</span><br><span class="line">mNum = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MyInteger&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">        <span class="keyword">this</span>.mNum++;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mNum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyInteger&amp; <span class="keyword">operator</span>++(MyInteger&amp; A) &#123;</span><br><span class="line">    A.mNum++;</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="后置递增运算符重载"><a href="#后置递增运算符重载" class="headerlink" title="后置递增运算符重载"></a>后置递增运算符重载</h1><ul><li>可以在成员函数进行重载，也可以在全局函数重载。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInteger</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyInteger</span>() &#123;</span><br><span class="line">mNum = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MyInteger <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">        MyInteger tmp = *<span class="keyword">this</span>;</span><br><span class="line">        A.mNum++;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mNum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyInteger <span class="keyword">operator</span>++(MyInteger&amp; A, <span class="keyword">int</span>) &#123;</span><br><span class="line">    MyInteger tmp = A;</span><br><span class="line">    A.mNum++;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="指针运算符重载"><a href="#指针运算符重载" class="headerlink" title="指针运算符重载"></a>指针运算符重载</h1><h2 id="智能指针实现"><a href="#智能指针实现" class="headerlink" title="智能指针实现"></a>智能指针实现</h2><p>用来托管自定义类型的对象，让对象进行自动释放，new出来的对象自动释放。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;age：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;xigou&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 智能指针</span></span><br><span class="line"><span class="comment">// 用来托管自定义类型的对象，让对象进行自动释放</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">smartPointer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">smartPointer</span>(Person *person) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;person = person;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重载-&gt;让智能指针对象像Person *p一样使用</span></span><br><span class="line">    Person * <span class="keyword">operator</span>-&gt;() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;person;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  重载*</span></span><br><span class="line">    Person&amp; <span class="keyword">operator</span>*() &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>-&gt;person;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">smartPointer</span>(Person *person) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;person != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>-&gt;person;</span><br><span class="line">            <span class="keyword">this</span>-&gt;person = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Person *person;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">smartPointer <span class="title">sp</span><span class="params">(<span class="keyword">new</span> Person(<span class="number">10</span>))</span></span>;  <span class="comment">//  开辟到栈上，自动释放</span></span><br><span class="line">    sp-&gt;<span class="built_in">showAge</span>();  <span class="comment">// sp-&gt;-&gt;showAge(),  编译器优化了写法</span></span><br><span class="line">    </span><br><span class="line">    (*sp).<span class="built_in">showAge</span>();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h1><ul><li>系统默认提供给类的赋值运算符写法是简单的值拷贝。</li><li>如果有数据在堆区，可能会有深浅拷贝问题。</li><li>如果想链式编程需要返回return *this;</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">char</span>* name) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;pName = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(name) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;pName, name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;age：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> Person &amp; p) &#123;</span><br><span class="line">        <span class="comment">// 如果原来堆区有内容，先释放掉</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>-&gt;pName != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pName;</span><br><span class="line">            thsi-&gt;pName = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;pName = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(p.pName) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;pName, p.pName);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">Person</span>() &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>-&gt;pName != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pName;</span><br><span class="line">            thsi-&gt;pName = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span>* pName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;goudan&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;gousheng&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;&quot;</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    p3 = p2 = p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="运算符重载"><a href="#运算符重载" class="headerlink" title="[]运算符重载"></a>[]运算符重载</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;myArray[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="和-关系运算符重载"><a href="#和-关系运算符重载" class="headerlink" title="==和!=关系运算符重载"></a>==和!=关系运算符重载</h1><ul><li>类似加号运算符重载</li></ul><h1 id="函数调用运算符重载"><a href="#函数调用运算符重载" class="headerlink" title="函数调用运算符重载"></a>函数调用运算符重载</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">MyPrint <span class="title">myPrint</span><span class="params">()</span></span>;</span><br><span class="line"><span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);  <span class="comment">// 仿函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="amp-amp-和"><a href="#amp-amp-和" class="headerlink" title="&amp;&amp; 和 ||"></a>&amp;&amp; 和 ||</h1><ul><li>这两个不要重载，因为无法实现它们的短路规则。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;左移运算符重载&quot;&gt;&lt;a href=&quot;#左移运算符重载&quot; class=&quot;headerlink&quot; title=&quot;左移运算符重载&quot;&gt;&lt;/a&gt;左移运算符重载&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;必须写在写在全局函数中，如果重载时想访问类的私有成员，需要将全局函数作类的友元。&lt;/li</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="重载" scheme="http://isgoudan.top/tags/%E9%87%8D%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>友元</title>
    <link href="http://isgoudan.top/2022/01/14/%E5%8F%8B%E5%85%83/"/>
    <id>http://isgoudan.top/2022/01/14/%E5%8F%8B%E5%85%83/</id>
    <published>2022-01-14T06:58:25.290Z</published>
    <updated>2022-02-20T03:07:03.815Z</updated>
    
    <content type="html"><![CDATA[<h1 id="友元目的"><a href="#友元目的" class="headerlink" title="友元目的"></a>友元目的</h1><p>​        访问类中的私有成员属性。</p><h1 id="三种友元"><a href="#三种友元" class="headerlink" title="三种友元"></a>三种友元</h1><ul><li><p>全局函数做友元函数，在类中写<code>friend void show();</code></p></li><li><p>整个类做友元类。在类中写<code>friend class Person;</code></p><ul><li>注意事项：<ul><li>友元关系不能被继承。</li><li>友元关系是单向的，类A是类B的朋友，但是类B不一定是类A的朋友。</li><li>友元关系不具有传递性。类B是类A的朋友，类C是类B的朋友，但是类C和类A不一定是朋友。</li></ul></li></ul></li><li><p>成员函数做友元函数，在类中写<code>friend void Person::show();</code></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;友元目的&quot;&gt;&lt;a href=&quot;#友元目的&quot; class=&quot;headerlink&quot; title=&quot;友元目的&quot;&gt;&lt;/a&gt;友元目的&lt;/h1&gt;&lt;p&gt;​        访问类中的私有成员属性。&lt;/p&gt;
&lt;h1 id=&quot;三种友元&quot;&gt;&lt;a href=&quot;#三种友元&quot; class=</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="friend" scheme="http://isgoudan.top/tags/friend/"/>
    
  </entry>
  
  <entry>
    <title>空指针访问成员函数</title>
    <link href="http://isgoudan.top/2022/01/14/%E7%A9%BA%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/"/>
    <id>http://isgoudan.top/2022/01/14/%E7%A9%BA%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0/</id>
    <published>2022-01-13T16:53:24.348Z</published>
    <updated>2022-01-14T06:40:27.514Z</updated>
    
    <content type="html"><![CDATA[<ul><li>如果成员函数没有用到this，那么空指针可以直接访问。</li><li>如果成员函数用的this指针，需要加if判断，如果this为空，直接return。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;show&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shouAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; mAge &lt;&lt;  endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>() &#123;</span><br><span class="line">Person *p1 = <span class="literal">NULL</span>;</span><br><span class="line">    p1-&gt;<span class="built_in">show</span>();    <span class="comment">// 正常运行</span></span><br><span class="line">    p1-&gt;<span class="built_in">shouAge</span>();<span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;如果成员函数没有用到this，那么空指针可以直接访问。&lt;/li&gt;
&lt;li&gt;如果成员函数用的this指针，需要加if判断，如果this为空，直接return。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>内存对齐</title>
    <link href="http://isgoudan.top/2022/01/14/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"/>
    <id>http://isgoudan.top/2022/01/14/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</id>
    <published>2022-01-13T16:46:11.438Z</published>
    <updated>2022-02-18T08:22:18.373Z</updated>
    
    <content type="html"><![CDATA[<h1 id="结构体内存对齐方式"><a href="#结构体内存对齐方式" class="headerlink" title="结构体内存对齐方式"></a>结构体内存对齐方式</h1><p>​        结构体大小不是个数据成员之和，而是按照一定的对齐数进行对齐存储，最后结构体的大小也是按照一定的对齐数进行对齐。</p><p><strong>对齐规则：</strong></p><ul><li><p>第一个成员在与结构体变量偏移量为0的地址。</p></li><li><p>char 偏移量必须为sizeof(char)即1的倍数 。</p></li><li><p>int 偏移量必须为sizeof(int)即4的倍数 。</p></li><li><p>float 偏移量必须为sizeof(float)即4的倍数 。</p></li><li><p>double 偏移量必须为sizeof(double)即8的倍数 。</p></li><li><p>short 偏移量必须为sizeof(short)即2的倍数 。</p></li><li><p> 结构体总的大小为默认对齐数（该结构中占用最大空间的类型所占用的字节数）的整数倍，所以在为最后一个成员变量申请空间后，还会根据需要自动填充空缺的字节。 </p></li></ul><p><strong>注意：</strong>当内存中的变量变换了顺序后，那么该结构体对象或者该类的对象所占内存空间也会发生变化。</p><p><strong>内存对齐计算方法：</strong></p><ul><li><p>看变量所在偏移地址是否为变量大小的整数倍。</p></li><li><p>看对齐后的总大小是否为最长变量的整数倍。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> dda;    <span class="comment">//偏移量为0，满足对齐方式，dda占用1个字节；</span></span><br><span class="line">    <span class="keyword">double</span> dda1; <span class="comment">//下一个可用的地址的偏移量为1，不是sizeof(double)=8的倍数，需要补足7个字节才能使偏移量变为8（满足对齐方式），因此VC自动填充7个字节，dda1存放在偏移量为8的地址上，它占用8个字节。</span></span><br><span class="line">    <span class="keyword">int</span> type;    <span class="comment">//下一个可用的地址的偏移量为16，是sizeof(int)=4的倍数，满足int的对齐方式，所以不需要VC自动填充，type存放在偏移量为16的地址上，它占用4个字节。</span></span><br><span class="line">    <span class="comment">//共占20个字节，不是默认偏移量（8）的整数倍，需要进行字节填充，最终占24个字节</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStruct1</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> d1;<span class="comment">//偏移量0，满足对齐方式，d1占用8个字节</span></span><br><span class="line">    <span class="keyword">char</span> d2;<span class="comment">//偏移量为8，满足对其方式（是1的倍数），占用1个字节</span></span><br><span class="line">    <span class="keyword">int</span> d3;<span class="comment">//偏移量为9，不满足对其方式（不是4的倍数），需要补3个字节，9+3+4=16</span></span><br><span class="line">    <span class="comment">//最终，占16个字节，是默认偏移量（8）的整数倍，不用补充字节</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(MyStruct) &lt;&lt; endl;  <span class="comment">// 24</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(MyStruct1) &lt;&lt; endl; <span class="comment">// 16</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="内存对齐原因"><a href="#内存对齐原因" class="headerlink" title="内存对齐原因"></a>内存对齐原因</h1><ul><li>平台的移植性好，并不是所有的硬件平台都能存放任意地址的数据，某些平台只能在某些地址访问特定类型的数据，否则会出现异常。</li><li>CPU处理效率高：CPU并不是把内存看成以字节为单位，而是以块为单位，CPU在读取内存的时候是一块一块读取的。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;结构体内存对齐方式&quot;&gt;&lt;a href=&quot;#结构体内存对齐方式&quot; class=&quot;headerlink&quot; title=&quot;结构体内存对齐方式&quot;&gt;&lt;/a&gt;结构体内存对齐方式&lt;/h1&gt;&lt;p&gt;​        结构体大小不是个数据成员之和，而是按照一定的对齐数进行对齐存储，最</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="面经" scheme="http://isgoudan.top/tags/%E9%9D%A2%E7%BB%8F/"/>
    
    <category term="内存" scheme="http://isgoudan.top/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>this指针</title>
    <link href="http://isgoudan.top/2022/01/13/this%E6%8C%87%E9%92%88/"/>
    <id>http://isgoudan.top/2022/01/13/this%E6%8C%87%E9%92%88/</id>
    <published>2022-01-13T08:37:27.138Z</published>
    <updated>2022-01-13T16:46:21.092Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>this指针指向被调用的成员函数所属的对象。</p></li><li><p>this是一种隐含指针，它隐含于每个类的非静态成员函数中，静态成员函数内部没有this指针，因此静态成员函数不能操作非静态成员变量。</p></li><li><p>当形参和成员变量同名时，可用this指针区分。</p></li><li><p>在类的非静态成员函数中返回对象本身，可使用 return *this。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;this指针指向被调用的成员函数所属的对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;this是一种隐含指针，它隐含于每个类的非静态成员函数中，静态成员函数内部没有this指针，因此静态成员函数不能操作非静态成员变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当形参和</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="this" scheme="http://isgoudan.top/tags/this/"/>
    
  </entry>
  
</feed>
