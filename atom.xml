<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>is_Goudan’s Blog</title>
  
  
  <link href="http://isgoudan.top/atom.xml" rel="self"/>
  
  <link href="http://isgoudan.top/"/>
  <updated>2022-05-26T10:48:45.391Z</updated>
  <id>http://isgoudan.top/</id>
  
  <author>
    <name>Gou Daner</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>noncopyable原理</title>
    <link href="http://isgoudan.top/2022/05/26/noncopyable%E5%8E%9F%E7%90%86/"/>
    <id>http://isgoudan.top/2022/05/26/noncopyable%E5%8E%9F%E7%90%86/</id>
    <published>2022-05-26T10:41:43.698Z</published>
    <updated>2022-05-26T10:48:45.391Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/c77e03ce4306">原文链接</a></p><h1 id="C-noncopyable-原理"><a href="#C-noncopyable-原理" class="headerlink" title="C++ noncopyable 原理"></a>C++ noncopyable 原理</h1><p>noncopyable 用于禁止派生类的拷贝操作。使用很简单，当某一个类不希望进行拷贝操作时，继承 noncopyable 即可，这么做可以避免编译器自动生成默认的拷贝构造函数和拷贝赋值运算符。</p><p>我们来看看 noncopyable 的两种实现方式：</p><ul><li>C++ 11 引入了 delete 语义，因此我们可以这样实现 noncopyable</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">noncopyable</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    noncopyable(<span class="keyword">const</span> noncopyable &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    noncopyable&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> noncopyable &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    noncopyable() = <span class="keyword">default</span>;</span><br><span class="line">    ~noncopyable() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>而 boost 库里的实现方式如下：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">noncopyable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    noncopyable() &#123;&#125;</span><br><span class="line">    ~noncopyable() &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:  <span class="comment">// emphasize the following members are private</span></span><br><span class="line">    noncopyable( <span class="keyword">const</span> noncopyable&amp; );</span><br><span class="line">    <span class="keyword">const</span> noncopyable&amp; <span class="keyword">operator</span>=( <span class="keyword">const</span> noncopyable&amp; );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>两者的区别在于第一个使用了 delete 语义，而 boost 库里将拷贝构造函数和拷贝赋值运算符的访问修饰符定义为 private 。这种操作为什么可以实现派生类的不可拷贝呢？</p><p>“《C++ Primer 第5版》15.7.2 合成拷贝控制与继承” 这一章节里有如下内容：</p><blockquote><p>如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的函数或者不可访问，则派生类中对应的成员将是被删除的，原因是编译器不能使用基类成员来执行派生类对象基类部分的构造、赋值或销毁操作。</p></blockquote><p>也就是说上述两种方式，第一种相当于基类的拷贝构造函数、拷贝赋值运算符是<strong>被删除的函数</strong>，而 boost 库里是<strong>不可访问的函数</strong>，因此其派生类对应的成员会被编译器生成是被删除的。这个就是 noncopyable 的核心原理。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/c77e03ce4306&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;C-noncopyable-原理&quot;&gt;&lt;a href=&quot;#C-noncopyable-原理&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="noncopyable" scheme="http://isgoudan.top/tags/noncopyable/"/>
    
  </entry>
  
  <entry>
    <title>KMP</title>
    <link href="http://isgoudan.top/2022/05/05/KMP/"/>
    <id>http://isgoudan.top/2022/05/05/KMP/</id>
    <published>2022-05-05T01:11:35.519Z</published>
    <updated>2022-05-05T01:55:02.880Z</updated>
    
    <content type="html"><![CDATA[<h1 id="力扣题目"><a href="#力扣题目" class="headerlink" title="力扣题目"></a>力扣题目</h1><p><a href="https://leetcode-cn.com/problems/implement-strstr/">28. 实现 strStr()</a></p><ul><li><p>法一：通过库函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> x = haystack.<span class="built_in">find</span>(needle);</span><br><span class="line">        <span class="keyword">if</span>(x != string::npos) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>法二：KMP</p></li></ul><p><a href="https://leetcode-cn.com/problems/string-rotation-lcci/">面试题 01.09. 字符串轮转</a></p><h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;力扣题目&quot;&gt;&lt;a href=&quot;#力扣题目&quot; class=&quot;headerlink&quot; title=&quot;力扣题目&quot;&gt;&lt;/a&gt;力扣题目&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/implement-strstr/&quot;&gt;2</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="算法" scheme="http://isgoudan.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="http://isgoudan.top/2022/05/03/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://isgoudan.top/2022/05/03/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2022-05-03T03:03:26.818Z</published>
    <updated>2022-05-05T07:00:28.775Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><h3 id="快排1-0"><a href="#快排1-0" class="headerlink" title="快排1.0"></a>快排1.0</h3><ul><li><p>平时自己写的快排</p></li><li><p>唯一注意点：考虑随机化key点。</p></li><li><p>时间复杂度：O（nlog(n)）</p></li></ul><h3 id="快排2-0"><a href="#快排2-0" class="headerlink" title="快排2.0"></a>快排2.0</h3><ul><li>利用荷兰国旗问题进行其中的递归处理行为，在重复元素较多的情况下比快排1.0效率高。</li></ul><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="衍生问题："><a href="#衍生问题：" class="headerlink" title="衍生问题："></a>衍生问题：</h3><p>小和问题：给定一个数组，计算每个数之前比它小的数的和，最后返回所有数结果的和。</p><p>求逆序对个数：左比右大则两数为逆序对。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;排序&quot;&gt;&lt;a href=&quot;#排序&quot; class=&quot;headerlink&quot; title=&quot;排序&quot;&gt;&lt;/a&gt;排序&lt;/h1&gt;&lt;h2 id=&quot;快排&quot;&gt;&lt;a href=&quot;#快排&quot; class=&quot;headerlink&quot; title=&quot;快排&quot;&gt;&lt;/a&gt;快排&lt;/h2&gt;&lt;h3 id</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="算法" scheme="http://isgoudan.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法技巧</title>
    <link href="http://isgoudan.top/2022/05/03/%E7%AE%97%E6%B3%95%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>http://isgoudan.top/2022/05/03/%E7%AE%97%E6%B3%95%E5%B0%8F%E6%8A%80%E5%B7%A7/</id>
    <published>2022-05-03T02:36:52.830Z</published>
    <updated>2022-05-03T03:08:47.260Z</updated>
    
    <content type="html"><![CDATA[<h1 id="取最低位为1的位置"><a href="#取最低位为1的位置" class="headerlink" title="取最低位为1的位置"></a>取最低位为1的位置</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> rightOne = x&amp;-x;</span><br><span class="line"><span class="comment">/* 以下为6的样例</span></span><br><span class="line"><span class="comment">111010; // -6补码   除去符号位，6原码取反最低位+1</span></span><br><span class="line"><span class="comment"> 00110; // 6原码</span></span><br><span class="line"><span class="comment">000010</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="取两数平均值"><a href="#取两数平均值" class="headerlink" title="取两数平均值"></a>取两数平均值</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);  <span class="comment">// 比传统的（a+b）/2 防止了溢出可能  left+两数一半距离</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;取最低位为1的位置&quot;&gt;&lt;a href=&quot;#取最低位为1的位置&quot; class=&quot;headerlink&quot; title=&quot;取最低位为1的位置&quot;&gt;&lt;/a&gt;取最低位为1的位置&lt;/h1&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td </summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="算法" scheme="http://isgoudan.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="http://isgoudan.top/2022/04/27/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://isgoudan.top/2022/04/27/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2022-04-27T01:14:52.769Z</published>
    <updated>2022-04-28T09:38:13.791Z</updated>
    
    <content type="html"><![CDATA[<p><font color=red><em><strong>以下内容源于力扣，参考链接如下</strong></em></font></p><p><a href="https://leetcode-cn.com/problems/coin-change/solution/xi-wang-yong-yi-chong-gui-lu-gao-ding-bei-bao-we-7/">https://leetcode-cn.com/problems/coin-change/solution/xi-wang-yong-yi-chong-gui-lu-gao-ding-bei-bao-we-7/</a></p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>常见的背包问题有1、组合问题。2、True、False问题。3、最大最小问题。<br>以下题目整理来自大神CyC，github地址：</p><p><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.md#0-1-%E8%83%8C%E5%8C%85">GitHub</a></p><p>我在大神整理的基础上，又做了细分的整理。分为三类。<br>1、组合问题：</p><p><a href="https://leetcode-cn.com/problems/combination-sum-iv/description/">377. 组合总和 Ⅳ</a></p><p><a href="https://leetcode-cn.com/problems/target-sum/description/">494. 目标和</a></p><p><a href="https://leetcode-cn.com/problems/coin-change-2/description/">518. 零钱兑换 II</a></p><p>2、True、False问题：</p><p><a href="https://leetcode-cn.com/problems/word-break/">139. 单词拆分</a></p><p><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/description/">416. 分割等和子集</a><br>3、最大最小问题：</p><p><a href="https://leetcode-cn.com/problems/ones-and-zeroes/description/">474. 一和零</a></p><p><a href="https://leetcode-cn.com/problems/coin-change/description/">322. 零钱兑换</a></p><p><strong>组合问题公式</strong></p><p><code>dp[i] += dp[i-num]</code></p><p><strong>True、False问题公式</strong></p><p><code>dp[i] = dp[i] or dp[i-num]</code></p><p><strong>最大最小问题公式</strong></p><p><code>dp[i] = min(dp[i], dp[i-num]+1)或者dp[i] = max(dp[i], dp[i-num]+1)</code><br>以上三组公式是解决对应问题的核心公式。</p><p><strong>当然拿到问题后，需要做到以下几个步骤：</strong><br>1.分析是否为背包问题。<br>2.是以上三种背包问题中的哪一种。<br>3.是0-1背包问题还是完全背包问题。也就是题目给的nums数组中的元素是否可以重复使用。<br>4.如果是组合问题，是否需要考虑元素之间的顺序。需要考虑顺序有顺序的解法，不需要考虑顺序又有对应的解法。</p><p><strong>接下来讲一下背包问题的判定</strong><br>背包问题具备的特征：给定一个target，target可以是数字也可以是字符串，再给定一个数组nums，nums中装的可能是数字，也可能是字符串，问：能否使用nums中的元素做各种排列组合得到target。</p><p><strong>背包问题技巧：</strong><br>1.如果是0-1背包，即数组中的元素不可重复使用，nums放在外循环，target在内循环，且内循环倒序；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(target, nums-<span class="number">1</span>, -<span class="number">1</span>):</span><br></pre></td></tr></table></figure><p>2.如果是完全背包，即数组中的元素可重复使用，nums放在外循环，target在内循环。且内循环正序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(nums, target+<span class="number">1</span>):</span><br></pre></td></tr></table></figure><p>3.如果组合问题需考虑元素之间的顺序，需将target放在外循环，将nums放在内循环。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, target+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br></pre></td></tr></table></figure><p>代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum4</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [<span class="number">0</span>] * (target+<span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,target+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> i &gt;= num:</span><br><span class="line">                    dp[i] += dp[i-num]</span><br><span class="line">        <span class="keyword">return</span> dp[target]</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;font color=red&gt;&lt;em&gt;&lt;strong&gt;以下内容源于力扣，参考链接如下&lt;/strong&gt;&lt;/em&gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/coin-change/solution/xi</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="算法" scheme="http://isgoudan.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux网络编程</title>
    <link href="http://isgoudan.top/2022/03/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>http://isgoudan.top/2022/03/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</id>
    <published>2022-03-15T04:26:04.093Z</published>
    <updated>2022-04-27T03:02:44.681Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h1><h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><ul><li><p>物理层</p><ul><li>主要解决两台物理机之间的通信，通过二进制比特流的传输来实现，而进程数据表现为电流电压上的强弱，到达目的地再转化为二进制机器码。网卡、集线器在这层工作。</li></ul></li><li><p>数据链路层 – 数据的传输和错误检测。</p><ul><li>在不可靠的物理介质上提供可靠传输，接收来自物理层的位流形式的数据并封装成帧，传送到上一层；同样也将上层的数据帧拆为位流形式的数据转发到物理层。这一层在物理层提供的比特流基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路。提供物理地址寻址功能。交换机工作在这一层。ARP协议。</li></ul></li><li><p>网络层 </p><ul><li>将网络地址翻译成对应的物理地址，并确定如何将数据从发送方路由到接收方，通过路由选择算法为分组通过通信子网选择最佳路径。路由器工作在这一层。IP协议。</li></ul></li><li><p>传输层</p><ul><li>传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。TCP、UDP协议。</li></ul></li><li><p>会话层</p><ul><li>建立会话：身份验证，权限鉴定等。</li><li>保持会话：对该会话进行维护，在会话维持期间两者可以随时使用这条会话传输数据。</li><li>断开会话：当应用程序或应用层规定的超时时间到期后，OSI会话层才会释放这条对话。</li></ul></li><li><p>表示层</p><ul><li>对数据格式进行编译，对收到或发出的数据根据应用层的特征进行处理，如处理为文字、图片、音频、视频、文档等，还可以对压缩文件进行解压缩、对加密文件进行解密等。</li></ul></li><li><p>应用层</p><ul><li>提供应用层协议，如HTTP协议，FTP协议等等，方便应用程序之间进行通信。HTTP、FTP、DNS等。</li></ul></li></ul><h1 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>​        数据传输和数据解释的规则。</p><h2 id="以太网帧协议"><a href="#以太网帧协议" class="headerlink" title="以太网帧协议"></a>以太网帧协议</h2><ul><li>以太网帧协议：根据mac地址，完成数据包传输。</li></ul><h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h2><ul><li>ARP协议：根据IP地址获取mac地址 。</li></ul><h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><ul><li>版本：IPv4、IPv6    – 4位。</li><li>TTL：time to live。设置数据包在路由节点中的跳转上限。每经过一个节点，该值-1，减为0时路由有义务将该数据丢弃。</li><li>源IP：32位。   – 4字节。</li><li>目的IP：32位。  – 4字节。</li></ul><p><strong>IP地址：</strong>可以在网络环境中，唯一标识一台主机。</p><p><strong>端口号：</strong>可以在网络的一台主机上，唯一标识 一个进程。</p><p><strong>IP+端口号：</strong>可以在网络环境中，唯一标识一个进程。</p><h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><ul><li>源端口号：16位。                    2^16 =65536 </li><li>目的端口号：16位。 </li></ul><h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><ul><li>源端口号：16位。                    2^16 =65536 </li><li>目的端口号：16位。 </li><li>32位序号。</li><li>32位确认序号。</li><li>6个标志位。</li><li>16位窗口大小。</li></ul><p><img src="https://s2.loli.net/2022/03/20/T6L3S2sIhBwHigm.jpg" alt="20180717201939345.jpg"></p><h2 id="TCP和UDP区别"><a href="#TCP和UDP区别" class="headerlink" title="TCP和UDP区别"></a>TCP和UDP区别</h2><p>4点（面向连接？面向的数据？是否可靠？是否支持组播？）</p><ul><li><p>TCP</p><p>为面向字节流的协议（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），提供可靠的、面向连接的服务，由流量控制和拥塞控制，可以保证数据顺序，提供全双工通信，每条TCP连接只能是点对点的。</p></li><li><p>UDP</p><p>为面向报文的协议，不提供可靠交付，并且不需要连接，不保证数据顺序，尽最大可能交付，没有拥塞控制，支持一对一，一对多，多对多，多对一的交互通信。</p></li></ul><h2 id="TCP三次握手四次挥手"><a href="#TCP三次握手四次挥手" class="headerlink" title="TCP三次握手四次挥手"></a>TCP三次握手四次挥手</h2><h3 id="TCP状态机"><a href="#TCP状态机" class="headerlink" title="TCP状态机"></a>TCP状态机</h3><p>​        TCP状态机是TCP连接的变化过程。</p><p><img src="https://s2.loli.net/2022/03/24/pRYEcIVPFMJrft6.png" alt="20180608201426603.png"></p><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><img src="https://s2.loli.net/2022/03/18/9xYT67swEiCUnOz.png" alt="1"></p><ul><li>第一次握手：客户端将标志位SYN置1，随机产生一个值序列号seq=x，并将该数据包发送给服务器，客户端进入syn_sent状态，等待服务器确认。</li></ul><blockquote><p>syn_sent: 在发送连接请求后等待匹配的连接请求。</p></blockquote><ul><li>第二次握手：服务器收到数据包后由标志位SYN = 1知道客户端请求建立连接，服务器将标志位SYN和ACK置1，确认序号ack=x+1代表之前的SYN报文收到希望收到的下一个数据的第一个字节的序号为x+1，并随机产生自己的初始序列号seq=y，服务器进入syn_rcvd状态。</li></ul><blockquote><p>syn_rcvd:在收到和发送一个连接请求后等待对连接请求的确认。</p></blockquote><ul><li>第三次握手：客户都安收到确认检查后，如果正确则将标志位ACK为1，确认序号ack=y+1，序号seq为x+1，并将数据包发送给服务端，服务端检查后二者建立连接。</li></ul><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img src="https://s2.loli.net/2022/03/18/jMdevk1tni7x8Br.png" alt="2"></p><ul><li>第一次挥手：客户端发送一个FIN，用来关闭客户端到服务器的数据传送，客户端进入fin_wait_1状态。</li><li>第二次挥手：服务器收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1，服务器进入close_wait状态。此时TCP连接处于半关闭状态，即客户端没有要发的数据了，但服务器若发送数据客户端仍可以接收。</li><li>第三次挥手：服务器发送一个FIN，用来关闭服务器到客户端的数据传送，服务器进入Last_ack状态。</li><li>第四次挥手：客户端收到FIN后，客户端进入Time_wait状态，接着发送一个ACK给服务器，确认后。服务器进入closed状态，完成四次挥手。</li></ul><h3 id="为什么三次握手，两次不行？"><a href="#为什么三次握手，两次不行？" class="headerlink" title="为什么三次握手，两次不行？"></a>为什么三次握手，两次不行？</h3><ul><li>TCP进行可靠传输的关键在于维护一个序列号 ，三次握手的过程即通信双方互相告知序列号起始值，并确认对方已经收到了序列号起始值。如果只是两次握手，最多只有客户端的起始序号能被确认，服务器端的序列号得不到确认。</li><li>为防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。<ul><li>经典场景：客户端发送了第一个请求连接并且没有丢失，只是因为在网络节点中滞留时间太长。</li><li>由于TCP的客户端迟迟没收到确认报文，会选择重发，此后客户端和服务器经过两次握手完成链接，传输数据，然后关闭。</li><li>此时此前滞留的一次请求连接，网络畅通到达服务器，这个报文本该失效，但是<strong>两次握手机制会让客户端和服务器再次建立连接，会导致不必要的错误和资源浪费</strong>。</li><li>如果采用三次握手，就算失效的报文传送过来，服务端收到后回复确认报文，但客户端不会再次发出确认，由于服务器收不到确认，就知道客户端没有请求连接。</li></ul></li></ul><h3 id="为什么建立连接三次，关闭是四次挥手呢？"><a href="#为什么建立连接三次，关闭是四次挥手呢？" class="headerlink" title="为什么建立连接三次，关闭是四次挥手呢？"></a>为什么建立连接三次，关闭是四次挥手呢？</h3><p>​        建立连接时，服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，服务器收到对方的FIN报文时 ，仅仅表示对方不再发送数据，但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据后再发送FIN表示同意关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多一次。</p><h3 id="如果已经建立连接，但是客户端突然出现故障怎么办？"><a href="#如果已经建立连接，但是客户端突然出现故障怎么办？" class="headerlink" title="如果已经建立连接，但是客户端突然出现故障怎么办？"></a>如果已经建立连接，但是客户端突然出现故障怎么办？</h3><p>​        TCP设有一个保活计时器，如果客户端出现故障，服务器不会一直等下去，服务器每收到一次客户端请求就会重新复位这个计时器，时间通常为2h，若2小时没收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75s发送一次。若一连发送10个探测报文没反应，服务器就认为客户端出现故障，接着关闭连接。</p><h3 id="半连接队列"><a href="#半连接队列" class="headerlink" title="半连接队列"></a>半连接队列</h3><p>​        TCP握手中，当服务器处于SYN_RCVD状态，服务器会把此种状态下请求连接放在一个队列里，该队列称为半连接队列。</p><h3 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h3><p>​        SYN攻击即利用TCP协议缺陷，通过发送大量半连接请求，占用半连接队列，耗费CPU和内存资源。</p><p>​        TCP SYN泛洪发生在OSI第四层，通过利用TCP三次握手特性，攻击者发送大量SYN报文，当服务器返回ACK后，攻击者不会确认，此时服务器会重复发送ACK回复，浪费服务器资源，攻击者通过发送大量半连接请求，在服务器上这些TCP连接会因为挂起状态消耗CPU和内存资源，从而死机。</p><p>优化方式：</p><ul><li>缩短SYN Timeout时间，使得主机尽快释放半连接的占用。</li><li>利用SYN cookie设置，记录IP，若连续受到某个IP的重复SYN报文，从这个IP地址来的包一概丢弃。</li></ul><h3 id="为什么四次挥手？"><a href="#为什么四次挥手？" class="headerlink" title="为什么四次挥手？"></a>为什么四次挥手？</h3><p>主要原因是当服务器收到客户端的FIN数据包后，服务器可能还有数据没有发完，不会立即close。因此服务器会先将ACK返回给客户端表示收到断开请求，但是服务器仍需要时间发送剩下的数据包，待所有数据包发完，服务器才会将FIN包发给客户端，之后客户端需要收到FIN后发送ACK确认断开给服务器。</p><h3 id="为什么四次挥手后需要等待2MSL？"><a href="#为什么四次挥手后需要等待2MSL？" class="headerlink" title="为什么四次挥手后需要等待2MSL？"></a>为什么四次挥手后需要等待2MSL？</h3><ul><li>MSL是指报文最大生存时间，是任何报文在网络上存在的最长时间，超时会被丢弃。MSL单位是时间，TTL单位是经过路由跳数。MSL&gt;=TTL。</li><li>尽量保证被动关闭的一端收到它自己发送的FIN报文的ACK确认报文。有两种情况：<ul><li>ACK在网络中丢失，在2MSL会收到重传的FIN报文，并重置2MSL。保证对端可以收到自己的ACK。</li><li>假如发送的ACK在MSL时间到达对端，此时正好对端重发了FIN标志位，2MSL就能保证最后一次发的FIN标志位在网络中消失，如果不等2MSL，客户端断开后立刻重连，那么服务器在上次连接最后一次发送的FIN就可能在新的连接中到达，影响连接，2MSL主要保证了旧连接的报文不会影响新连接。</li></ul></li></ul><h3 id="TCP的accept-函数发生在第几次握手？"><a href="#TCP的accept-函数发生在第几次握手？" class="headerlink" title="TCP的accept()函数发生在第几次握手？"></a>TCP的accept()函数发生在第几次握手？</h3><ul><li>accept过程发生在三次握手之后，三次握手完成后,客户端和服务器就建立了tcp连接并可以进行数据交互了。这时可以调用accept函数获得此连接。</li><li>在Linux中， accept函数的作用是： 从已经完成连接的socket队列中取出一个socket,  如果没有已经完成连接的socket, 那么accept函数就会阻塞。</li></ul><h2 id="TCP实现可靠通信（）"><a href="#TCP实现可靠通信（）" class="headerlink" title="TCP实现可靠通信（）"></a>TCP实现可靠通信（）</h2><h2 id="DNS协议"><a href="#DNS协议" class="headerlink" title="DNS协议"></a>DNS协议</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>​        DNS协议是基于UDP的应用层协议，他的功能是根据用户输入的域名，解析出该域名对应的IP地址，从而给客户端进行访问。</p><ul><li>一个组织的系统管理机构，维护系统内的每个主机IP和主机名的对应关系。</li><li>如果新计算机接入网络，将这个信息注册到数据库中。</li><li>用户输入域名的时候，会自动查询DNS服务器，由DNS服务器检索数据库，得到对应的IP地址。</li></ul><h3 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h3><ul><li>客户机发出查询请求，在本地host文件查找，有则直接返回。</li><li>若没有找到，会将请求发送给本地DNS服务器，通过递归查询方式进行查找，找到则返回。</li><li>没找到则本地服务器将请求发送到根域名服务器，之后使用迭代查询的方式找到目标IP信息后把查询结果返回给客户机的本地DNS服务器，最终将信息返回给客户机。</li></ul><blockquote><p>递归查询：如果主机所询问的本地域名服务器不知道被查询的域名的IP地址，那么本地域名服务器就以DNS客户的身份，向其它根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。因此，递归查询返回的查询结果或者是所要查询的IP地址，或者是报错，表示无法查询到所需的IP地址。</p></blockquote><blockquote><p>迭代查询：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的IP地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地服务器进行后续的查询。根域名服务器通常是把自己知道的顶级域名服务器的IP地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的IP地址，要么告诉本地服务器下一步应当向哪一个权限域名服务器进行查询。最后，知道了所要解析的IP地址或报错，然后把这个结果返回给发起查询的主机。</p></blockquote><p><img src="https://pic2.zhimg.com/v2-844e5d5d9424494ded2f1e97cf519951_r.jpg" alt="preview"></p><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>​        http协议是超文本传输协议。它是基于TCP协议的应用层传输协议，即客户端和服务端进行数据传输的一种规则。该协议本身HTTP是一种无状态协议。</p><p><strong>无状态：</strong>协议本身没有记忆能力。如果后续处理需要前面的信息，则其必须重传，这样可能导致每次连接传送的数据量增大。</p><h3 id="浏览器输入URL-gt-显示主页过程"><a href="#浏览器输入URL-gt-显示主页过程" class="headerlink" title="浏览器输入URL-&gt;显示主页过程"></a>浏览器输入URL-&gt;显示主页过程</h3><ul><li>进行DNS解析操作，根据DNS解析的结果查到服务器IP地址。</li><li>利用三次握手与服务器建立连接。</li><li>发送http请求。</li><li>服务器处理请求，返回给浏览器。</li><li>浏览器根据收到的静态数据进行页面渲染。</li></ul><p>用到的协议：DNS、TCP、IP、ARP、HTTP等。</p><h3 id="HTTP1-0和HTTP1-1"><a href="#HTTP1-0和HTTP1-1" class="headerlink" title="HTTP1.0和HTTP1.1"></a>HTTP1.0和HTTP1.1</h3><ul><li>长连接和短连接。<ul><li>1.0规定浏览器和服务器只保持短暂的连接，每进行一次HTTP通信就断开一次TCP连接。</li><li>1.1支持长连接（持久连接），他的特点是只要任意一端没有明确提出断开连接 ，就保持TCP连接状态。这样一个TCP连接可以进行多次请求响应的交互。同时支持管道通信，一次性发送多个request请求，可降低相应时间。</li></ul></li></ul><h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><ul><li><p>1XX：接收的信息正在处理。</p></li><li><p>2XX：请求成功。</p></li><li><p>3XX：重定向。</p></li><li><p>4XX：客户端错误。</p></li><li><p>5XX：服务端错误。</p></li><li><p>常见状态码：</p></li></ul><table><thead><tr><th align="left">状态码</th><th>含义</th></tr></thead><tbody><tr><td align="left">200（成功）</td><td>服务器已成功处理请求。通常表示服务器提供了请求的网页</td></tr><tr><td align="left">201（已接受）</td><td>请求成功并且服务器创建了新的资源。</td></tr><tr><td align="left">203（非授权信息）</td><td>服务器已成功处理了请求，但返回的信息可能来自另一来源。</td></tr><tr><td align="left">204（无内容）</td><td>服务器成功处理请求，但是没有返回任何内容，当前页面不会有任何变化。</td></tr><tr><td align="left">205（重置内容）</td><td>相比204多了一步操作,就是要清空当前文档内所有表单控件的内容。</td></tr><tr><td align="left">206（部分内容）</td><td>服务器成功处理了部分GET请求。</td></tr><tr><td align="left">301</td><td>永久重定向。</td></tr><tr><td align="left">302</td><td>临时重定向。</td></tr><tr><td align="left">304</td><td>资源没修改，用之前的缓存就行。</td></tr><tr><td align="left">400</td><td>客户端请求的报文有错误。</td></tr><tr><td align="left">401（未授权）</td><td>请求要求身份验证。对于需要登陆的网页，服务器可能返回此响应。</td></tr><tr><td align="left">403（禁止）</td><td>服务器拒绝请求。</td></tr><tr><td align="left">404</td><td>请求的资源在服务器不存在或未找到。</td></tr><tr><td align="left">500</td><td>服务器遇到错误，无法完成请求。挂代理的时候有时候会出现500 Internal Privoxy Error（内部隐私错误）。</td></tr><tr><td align="left">501（尚未实施）</td><td>服务器不具备完成请求的功能。例如服务器无法识别请求方法时。</td></tr><tr><td align="left">502（错误网关）</td><td>服务器作为网关或代理，从上游服务器收到无效响应。</td></tr><tr><td align="left">503（服务不可用）</td><td>服务器目前无法使用（由于超载和停机维护）。通常这只是暂时状态。</td></tr><tr><td align="left">504（网关超时）</td><td>服务器作为网关或代理，但是没有及时从上游服务器收到请求。</td></tr><tr><td align="left">505（HTTP版本不受支持）</td><td>服务器不支持请求中所用的HTTP协议版本。</td></tr></tbody></table><h3 id="转发和重定向的区别"><a href="#转发和重定向的区别" class="headerlink" title="转发和重定向的区别"></a>转发和重定向的区别</h3><ul><li>转发是服务器行为。服务器直接向目标地址访问URL，将相应内容读取后发给浏览器，用户浏览器地址栏URL不变，转发页面和转发到的页面可以共享request里面的数据。</li><li>重定向是利用服务器返回的状态码实现，如果服务器返回301或者302，浏览器收到新消息后会自动跳转到新的网址重新请求资源。用户的地址栏URL会改变，而且不能共享数据。</li></ul><h3 id="Get和Post区别"><a href="#Get和Post区别" class="headerlink" title="Get和Post区别"></a>Get和Post区别</h3><ul><li>Get：指定资源请求数据，刷新无害，Get请求数据会附加到URL中，传输数据的大小受到URL限制，允许发送的数据量较小，而Post请求没有大小限制。</li><li>Post：向指定资源提交要被处理的数据。刷新会导致数据的重复提交。post在发送数据前会先将请求头发送给服务器进行确认，然后才真正发送数据。Post的安全性比Get的安全性高，因为Get请求提交的数据将明文出现在URL上，而Post请求参数则被包装到请求体中，相对安全。</li></ul><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>​        超文本传输安全协议，是一种透过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但是利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。默认工作在TCP协议443端口。</p><h3 id="工作流程（）"><a href="#工作流程（）" class="headerlink" title="工作流程（）"></a>工作流程（）</h3><h2 id="HTTP和HTTPS区别"><a href="#HTTP和HTTPS区别" class="headerlink" title="HTTP和HTTPS区别"></a>HTTP和HTTPS区别</h2><ul><li>url和端口<ul><li>http：开头http://，默认80端口。</li><li>https：开头https://，默认443端口。</li></ul></li><li>安全性和资源消耗<ul><li>HTTP协议运行在TCP上，所有传输的内容都是明文，客户端和服务器都无法验证对方的身份，安全性较差。HTTPS经由HTTP进行通信，但是利用SSL/TLS来加密数据包，安全性较好。HTTP响应速度比HTTPS快，主要因为HTTP使用TCP三次握手建立连接，客户端和服务器需要交换3个包，而HTTPS除了TCP的三个包，还要加上SSL握手的9个包，所以HTTP资源消耗小。HTTPS其实就是建构在SSL/TLS上的HTTP协议。</li></ul></li></ul><h2 id="常用端口号"><a href="#常用端口号" class="headerlink" title="常用端口号"></a>常用端口号</h2><table><thead><tr><th align="center">端口</th><th align="left">服务</th></tr></thead><tbody><tr><td align="center">21</td><td align="left">FTP（文件传输协议）</td></tr><tr><td align="center">22</td><td align="left">SSH（安全外壳协议）</td></tr><tr><td align="center">23</td><td align="left">Telnet（internet远程登录服务的标准协议）</td></tr><tr><td align="center">25</td><td align="left">SMTP简单邮件传输服务</td></tr><tr><td align="center">53</td><td align="left">DNS（域名系统服务）</td></tr><tr><td align="center">80</td><td align="left">HTTP（超文本传输协议）</td></tr></tbody></table><h1 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h1><ul><li>什么是socket？<ul><li>网络通信的函数接口。</li><li>封装了传输层协议。<ul><li>TCP</li><li>UDP</li></ul></li><li>本质是一个文件描述符在指向一个套接字（该套接字内部由内核借助两个缓冲区实现。）</li></ul></li></ul><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="字节序转换函数"><a href="#字节序转换函数" class="headerlink" title="字节序转换函数"></a>字节序转换函数</h3><p><strong>inet_pton：</strong></p><ul><li><code>int inet_pton(int af, const char *src, void *dst);</code>本地字节序转网络字节序。</li><li>af: AF_INET、AF_INET6 对应ipv4、ipv6。</li><li>src：传入，本地IP地址字符串。</li><li>dst：传出，转换后的网络ip地址。</li><li>返回值：成功返回1，异常返回0，说明src传入的ip地址无效 。失败返回-1。</li></ul><p><strong>inet_ntop</strong>：</p><ul><li><code>const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);</code>网络字节序转本地字节序。</li><li>af: AF_INET、AF_INET6 对应ipv4、ipv6。</li><li>src：传入，网络IP地址字符串。</li><li>dst：传出，转换后的本地ip地址。</li><li>size：dst大小。</li><li>返回值：成功返回dst。失败返回null。</li></ul><h3 id="socket相关函数"><a href="#socket相关函数" class="headerlink" title="socket相关函数"></a>socket相关函数</h3><p><strong>socket():</strong></p><ul><li><code>int socket(int domain, int type, int protocol);</code>创建一个套接字</li><li>domain ：AF_INET、AF_INET6、AF_UNIX  对应IPv4、IPv6、本地。</li><li>type：创建套接字的传输协议，SOCK_STREAM、SOCK_DGRAM。</li><li>protocol：说明典型协议，一般传0。</li><li>返回值：成功返回一个新套接字所对应的文件描述符，失败-1，设置errno。</li></ul><p><strong>bind()：</strong></p><ul><li><p><code>int bind(int sockfd, const struct sockaddr *addr,socklen_t addrlen);</code>给socket绑定地址结构（IP+PORT）。</p></li><li><p>sockfd ：传入socket函数返回值。</p></li><li><p>addr：传入参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">addr.sin_family = AF_INET;</span><br><span class="line">addr.sin_port = <span class="built_in">htons</span>(<span class="number">8888</span>);</span><br><span class="line">arddr.sin_addr.s_addr = <span class="built_in">htonl</span>(INADDR_ANY); <span class="comment">// INADDR_ANY系统自动帮你取当前可用的IP</span></span><br></pre></td></tr></table></figure><ul><li><code>（struct sockaddr*）&amp;addr</code></li></ul></li><li><p>addrlen: sizeof(addr) 地址结构的大小。</p></li><li><p>返回值：成功返回0，失败-1设置errno。</p></li></ul><p><strong>listen()：</strong></p><ul><li><code>int listen(int sockfd, int backlog);</code> 设置同时与服务器建立连接的上限数。（同时进行三次握手的客户端数量）。</li><li>sockfd ：传入socket函数返回值。</li><li>backlog：上限数值。最大128。</li><li>返回值：成功返回0，失败-1设置errno。</li></ul><p><strong>accept():</strong></p><ul><li><code>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</code>阻塞等待客户端建立链接，成功返回一个与客户端成功链接的socket文件描述符。</li><li>sockfd ：传入socket函数返回值。</li><li>addr：传出参数。成功与服务器建立连接的哪个客户端的地址结构（IP+PORT）。</li><li>addrlen: 传入addr的大小，传出客户端addr的实际大小。</li><li>返回值：成功返回一个能与客户端进行数据通信的socket的文件描述符。失败返回-1，errno。</li></ul><p><strong>connect：</strong></p><ul><li><code>int connect(int sockfd, const struct sockaddr *addr,socklen_t addrlen);</code>使用现有的socket与服务器建立连接。</li><li>sockfd ：传入socket函数返回值。</li><li>addr：传入参数。服务器地址结构。</li><li>addrlen：sizeof(addr) 地址结构的大小。</li><li>返回值：成功0，失败-1errno。</li></ul><p><strong>setsockopt：</strong></p><ul><li><p><code>int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);</code>设置端口复用。</p></li><li><p>用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">setsockopt</span>(listenfd, SOL_SOCKET, SO_REUSEADDR, (<span class="keyword">void</span>*)&amp;opt, <span class="built_in"><span class="keyword">sizeof</span></span>(opt));</span><br><span class="line"><span class="comment">// 写在bind之前。</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>close\shutdown:</strong></p><ul><li><code>close(cfd);</code> 关闭套接字的文件描述符。</li><li><code>shutdown(int fd, int how);</code><ul><li>how:<ul><li>SHUT_RD 关读端</li><li>SHUT_WR 关写端</li><li>SHUT_RDWR 关读写</li></ul></li></ul></li><li>shutdown在关闭多个文件描述符引用的文件时，采用全关闭方法，close只关闭一个。</li></ul><h3 id="select函数"><a href="#select函数" class="headerlink" title="select函数"></a>select函数</h3><p><strong>select:</strong></p><ul><li><p>多路IO转接，原理：借助内核，select来监听，客户端连接、数据通信事件。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set *readfds, fd_set *writefds,fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br><span class="line"><span class="comment">// nfds：监听的所有文件描述符中，最大文件描述符+1.</span></span><br><span class="line"><span class="comment">// readfds：读文件描述符监听集合。传入传出参数</span></span><br><span class="line"><span class="comment">// writefds：写文件描述符监听集合。传入传出参数NULL</span></span><br><span class="line"><span class="comment">// exceptfds：异常文件描述符监听集合。传入传出参数NULL</span></span><br><span class="line"><span class="comment">// timeout：  &gt;0 : 设置监听超时时长</span></span><br><span class="line"><span class="comment">// NULL：阻塞监听</span></span><br><span class="line"><span class="comment">// 0： 非阻塞监听，轮询</span></span><br><span class="line"><span class="comment">// 返回值：&gt;0:所有监听集合中，满足对应事件的总数。</span></span><br><span class="line"><span class="comment">//0：没有满足监听条件的文件描述符</span></span><br><span class="line"><span class="comment">//   -1：errno。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *set)</span></span>;<span class="comment">// 将一个文件描述符从监听集合中移除。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *set)</span></span>;<span class="comment">// 判断一个文件描述符是否在监听集合中。在返回1，否则返回0。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *set)</span></span>;<span class="comment">// 将待监听的文件描述符添加到监听集合中。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *set)</span></span>;        <span class="comment">// 清空文件描述符集合。</span></span><br></pre></td></tr></table></figure></li><li><p>缺点：</p><ul><li>监听上限受文件描述符限制，最大1024。</li><li>检测满足条件的fd，自己添加业务逻辑提高小，提高了编码难度。</li></ul></li><li><p>优点：</p><ul><li>跨平台，Win、Linux、macOS、Unix、类Unix等。</li></ul></li></ul><h3 id="poll函数"><a href="#poll函数" class="headerlink" title="poll函数"></a>poll函数</h3><p><strong>poll:</strong></p><ul><li><code>int poll(struct pollfd *fds, nfds_t nfds, int timeout);</code></li><li>fds：监听的文件描述符数组。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>   fd;         <span class="comment">/* file descriptor 待监听的文件描述符*/</span></span><br><span class="line">    <span class="keyword">short</span> events;     <span class="comment">/* requested events 待监听的文件描述符对应的监听事件 取值：POLLIN、POLLOUT、POLLERR*/</span>   </span><br><span class="line">    <span class="keyword">short</span> revents;    <span class="comment">/* returned events 传入时，给0。如果满足对应事件的话，返回非0-》POLLIN、POLLOUT、POLLERR*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>nfds：监听数组的，实际有效监听个数。</li><li>timeout：<ul><li>-1 ：阻塞等待。</li><li>0：立即返回。</li><li>&gt;0:超时时长，毫秒。</li></ul></li><li>返回值：返回满足对应事件的总个数。</li><li>优点：自带数组结构，可以将监听事件和返回事件集合分离，可以拓展监听上限，超出1024。</li><li>缺点：不能跨平台，只能在Linux/Unix。无法直接定位满足监听事件的文件描述符，只能for循环轮询。</li></ul><p><strong>突破1024文件描述符限制：</strong></p><p><code>cat /proc/sys/fs/file-max</code>  —-&gt; 当前计算机能打开的最大文件个数，受硬件影响。</p><p><code>ulimit -a</code> —–&gt; 当前用户下的进程，默认打开文件描述符的个数。</p><p><code>sudo vim /etc/secur/limits.conf</code>   修改soft nofile。</p><h3 id="epoll函数"><a href="#epoll函数" class="headerlink" title="epoll函数"></a>epoll函数</h3><p><strong>epoll:(本质是红黑树)</strong></p><ul><li><p><code>int epoll_create(int size); </code>  创建一颗监听红黑树。</p><ul><li>size：表示创建红黑树的监听节点数量（仅供内核参考。）</li><li>返回值：<ul><li>成功返回指向新创建的红黑树的根节点的fd。</li><li>失败errno，-1。</li></ul></li></ul></li><li><p><code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); </code> 操作监听红黑树。</p><ul><li>epfd：epoll_creat函数的返回值。epfd。</li><li>op：表示对该监听红黑树的操作。<ul><li>EPOLL_CTL_ADD  添加fd到监听红黑树。</li><li>EPOLL_CTL_MOD  修改fd在监听红黑树上的监听事件。</li><li>EPOLL_CTL_DEL    将一个fd从监听红黑树上摘下（取消监听）。</li></ul></li><li>fd：待监听的fd。</li><li>event：本质是struct epoll_event结构体 地址<ul><li>events：EPOLLIN/EPOLLOUT/EPOLLERR</li><li>data：</li></ul></li><li>返回值：成功0，失败-1 errno。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>        *ptr;</span><br><span class="line">    <span class="keyword">int</span>          fd;<span class="comment">// 对应监听事件的fd</span></span><br><span class="line">    <span class="keyword">uint32_t</span>     u32;</span><br><span class="line">    <span class="keyword">uint64_t</span>     u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span>     events;      <span class="comment">/* Epoll events */</span></span><br><span class="line">    <span class="keyword">epoll_data_t</span> data;        <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code> int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);</code> 阻塞监听。</p><ul><li>epfd：epoll_creat 函数的返回值。epfd。</li><li>events：【数组】，传出参数，传出满足监听条件fd结构体。</li><li>maxevents：数组元素的总个数。类似于buffer_size。</li><li>timeout：<ul><li>-1 阻塞</li><li>0  不阻塞</li><li>&gt;0 监听时长，单位毫秒。</li></ul></li><li>返回值：<ul><li>&gt;0：满足监听的总个数，可以用作循环上限。</li><li>0：没有满足的事件。</li><li>-1，失败，errno。</li></ul></li></ul></li><li><p>epoll可以显著提高程序在大量并发连接中只有少量活跃情况下的系统CPU利用率</p></li><li><p>优点：高效，突破1024文件描述符限制。</p></li><li><p>缺点：不能跨平台，只能Linux。</p></li></ul><h2 id="epoll事件模型"><a href="#epoll事件模型" class="headerlink" title="epoll事件模型"></a>epoll事件模型</h2><h3 id="ET模式（边沿触发）"><a href="#ET模式（边沿触发）" class="headerlink" title="ET模式（边沿触发）"></a>ET模式（边沿触发）</h3><ul><li>内核缓冲区剩余未读尽的数据不会导致epoll_wait返回。新的事件满足才会触发。需要从电平的角度分析，假如内核缓冲区里的数据只读取一半，然后剩一半，这时候对读事件来说，会一直处于高电平（可读）状态，这时候在边沿触发模式下不会导致epoll_wait返回。在设计的时候需要把内核缓冲区的数据全部读出即read函数返回EAGAIN错误，黑马的做法是增加一个用户缓冲区，把内核缓冲区数据全都读到用户缓冲区中，然后进行处理。</li><li><code>struct epoll_event event;</code></li><li><code>event.events = EPOLLIN | EPOLLET;</code></li><li>epoll的ET模式，是高效模式，但是只支持非阻塞模式 – 忙轮询。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">event.events = EPOLLIN | EPOLLET;</span><br><span class="line"><span class="built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, cfd, &amp; event);</span><br><span class="line"><span class="keyword">int</span> flg = <span class="built_in">fcntl</span>(cfd, F_GETFL);</span><br><span class="line">flg |= O_NONBLOCK;</span><br><span class="line"><span class="built_in">fcntl</span>(cfd, F_SETFL, flg);</span><br></pre></td></tr></table></figure><h3 id="LT模式（水平触发）"><a href="#LT模式（水平触发）" class="headerlink" title="LT模式（水平触发）"></a>LT模式（水平触发）</h3><ul><li>对于读事件，内核缓冲区剩余未读尽的数据会导致epoll_wait返回，由于内核缓冲区一直处于高电平，所以epoll_wait会一直返回。</li><li>在写事件的时候，只要内核缓冲区未满，可写就会导致高电平状态，就会出现busy_loop的情况。</li><li>默认采用水平触发。</li></ul><p><img src="https://s2.loli.net/2022/04/13/jq2PMkrasnSBtE9.png" alt="image.png"></p><h2 id="epoll-反应堆模型"><a href="#epoll-反应堆模型" class="headerlink" title="epoll 反应堆模型"></a>epoll 反应堆模型</h2><ul><li>epoll的ET模式 + 非阻塞 + void*ptr。</li><li>不但要监听cfd的读事件，也要监听cfd的写事件。</li></ul><p><img src="https://s2.loli.net/2022/04/12/FH1NViKd2UxtYsh.png" alt="image.png"></p><h2 id="socket模型创建流程图"><a href="#socket模型创建流程图" class="headerlink" title="socket模型创建流程图"></a>socket模型创建流程图</h2><p><img src="https://img-blog.csdnimg.cn/20201005105410703.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDM0Nzgw,size_16,color_FFFFFF,t_70#pic_center" alt="1"></p><p>如果不使用bind绑定客户端的地址结构，系统会自动采用“隐式绑定”。</p><h2 id="网络套接字和本地套接字对比"><a href="#网络套接字和本地套接字对比" class="headerlink" title="网络套接字和本地套接字对比"></a>网络套接字和本地套接字对比</h2><p><img src="https://s2.loli.net/2022/04/27/HXZPejFkScOzomM.png" alt="image.png"></p><hr><h1 id="多路IO复用模型"><a href="#多路IO复用模型" class="headerlink" title="多路IO复用模型"></a>多路IO复用模型</h1><p>在多路复用IO模型中，会有一个线程不断去轮询多个socket的状态，只有当socket真正有读写事件时，才真正调用实际的IO读写操作。因为在多路复用IO模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket读写事件进行时，才会使用IO资源，所以它大大减少了资源占用。</p><p><img src="https://s2.loli.net/2022/04/25/iv6pY2mCSgrLITz.png" alt="image.png"></p><p><img src="https://s2.loli.net/2022/04/25/rLRUK5cNad8MHgk.png" alt="image.png"></p><p><img src="https://s2.loli.net/2022/04/25/Igfi8V3lzQK5xNj.png" alt="image.png"></p><p><img src="https://s2.loli.net/2022/04/25/7LEAWaPcglXxJjq.png" alt="image.png"></p><h1 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h1><h2 id="大端存储-Big-Endian"><a href="#大端存储-Big-Endian" class="headerlink" title="大端存储(Big-Endian)"></a>大端存储(Big-Endian)</h2><p>数据的高字节存储在低地址中，数据的低字节存储在高地址中。网络字节序采用大端存储。</p><h2 id="小端存储-Little-Endian"><a href="#小端存储-Little-Endian" class="headerlink" title="小端存储(Little-Endian)"></a>小端存储(Little-Endian)</h2><p>数据的高字节存储在高地址中，数据的低字节存储在低地址中 。主机字节序采用小端存储。</p><p><strong>uint31_t  htonl(uint31_t hostlong)：</strong>本地字节序转网络字节序函数。（转IP）。</p><p><strong>uint16_t  htons(uint16_t hostshort)：</strong>本地字节序转网络字节序函数。（转port）。</p><p><strong>uint31_t ntohl(uint31_t netlong)：</strong>网络字节序转本地字节序函数。（IP）</p><p><strong>uint16_t ntohl(uint16_t netlong)：</strong>网络字节序转本地字节序函数。（port）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;网络模型&quot;&gt;&lt;a href=&quot;#网络模型&quot; class=&quot;headerlink&quot; title=&quot;网络模型&quot;&gt;&lt;/a&gt;网络模型&lt;/h1&gt;&lt;h2 id=&quot;OSI七层模型&quot;&gt;&lt;a href=&quot;#OSI七层模型&quot; class=&quot;headerlink&quot; title=&quot;OSI</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://isgoudan.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="Linux" scheme="http://isgoudan.top/tags/Linux/"/>
    
    <category term="计算机网络" scheme="http://isgoudan.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>OS小知识点</title>
    <link href="http://isgoudan.top/2022/03/04/OS%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://isgoudan.top/2022/03/04/OS%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2022-03-04T05:30:27.536Z</published>
    <updated>2022-03-22T07:37:55.116Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MMU（内存管理单元）"><a href="#MMU（内存管理单元）" class="headerlink" title="MMU（内存管理单元）"></a>MMU（内存管理单元）</h1><p><img src="https://s2.loli.net/2022/03/04/1L35G4UghYlkuc8.png" alt="QQ截图20220304133224.png"></p><p><img src="https://s2.loli.net/2022/03/04/Pg6hLpMdvDy9Bzu.png" alt="MMU.png"></p><p>MMU作用：</p><ul><li>虚拟内存与物理内存映射。</li><li>设置修改内存访问级别。</li></ul><h1 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h1><p>​        操作系统是管理计算机硬件和软件资源的计算机程序，提供一个计算机用户与计算机硬件系统之间的接口。</p><p>​        向上对用户程序提供接口，向下接管硬件资源。</p><p>​        操作系统本质也是一个软件，作为最接近硬件的系统软件，负责处理器管理、存储器管理、设备管理、文件管理和提供用户接口。</p><h1 id="操作系统有哪些分类"><a href="#操作系统有哪些分类" class="headerlink" title="操作系统有哪些分类"></a>操作系统有哪些分类</h1><ul><li>批处理操作系统</li><li>分时操作系统</li><li>实时操作系统</li><li>通用操作系统：兼顾批操作和分时功能，如Windows，Linux，MacOS等。</li></ul><h1 id="内核态和用户态"><a href="#内核态和用户态" class="headerlink" title="内核态和用户态"></a>内核态和用户态</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>​        为了避免操作系统和关键数据被用户程序破坏，将处理器执行状态分为内核态和用户态。</p><ul><li>内核态是操作系统管理程序执行时所处的状态，能够执行包含特权指令在内的一切指令，能够访问系统内所有的存储空间。</li><li>用户态是用户程序执行时处理器所处的状态，不能执行特权指令，只能访问用户地址空间。</li><li>用户程序运行在用户态，操作系统内核运行在内核态。</li></ul><h2 id="如何转换"><a href="#如何转换" class="headerlink" title="如何转换"></a>如何转换</h2><p>​        处理器从用户态切换到内核态的方法有三种：系统调用（软中断）、异常（内中断）和外部中断（硬中断）。</p><ul><li><p>系统调用</p><ul><li>是操作系统的最小功能单位，是操作系统提供的用户接口，系统调用本身是一种软中断。</li><li>这是处于用户态的进程主动请求切换到内核态的一种方式。用户态的进程通过系统调用申请使用操作系统提供的系统调用例程来处理任务。而系统调用的机制，其核心仍是使用了操作系统为用户特别开发的一个中断机制来实现，即软中断。</li></ul></li><li><p>异常</p><ul><li>也叫内中断，是由错误引起。</li><li>当CPU执行运行在用户态下的程序时，发生了某些事先不可知的异常，如文件损坏、缺页故障等，这时会触发由当前运行的进程切换到处理此异常的内核相关程序中，也就是转到内核态。</li></ul></li><li><p>外部中断</p><ul><li>是通过两根信号线来通知处理器外设的状态变化，是硬中断。</li><li>当外围设备完成用户请求的操作后，会向CPU发出相应中断信号，这时CPU会暂停执行下一条即将执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换过程自然也就发生了由用户态到内核态的转换。比如硬盘读写操作完成时，系统会切换到硬盘读写的中断处理程序中执行后续操作。</li></ul></li></ul><h1 id="并发和并行的区别"><a href="#并发和并行的区别" class="headerlink" title="并发和并行的区别"></a>并发和并行的区别</h1><ul><li>并发：指宏观上看起来两个程序在同时运行，比如单核CPU的多任务，但是微观上两个程序指令是交织进行，在单个周期内只运行一个指令。这种并发并不能提高计算机性能，只能提高效率（降低某个进程的响应时间）。</li><li>并行：指严格意义上的同时运行，比如多核CPU，两个程序分别运行在两个核上，两者互不影响，单个周期内每个程序都运行了自己的指令，也就是执行了两条指令。这样说来并行的确的提高了计算机效率，所以目前的CPU都是朝着多核方向发展。</li></ul><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>死锁是指多个进程在执行过程中，因争夺资源而造成的互相等待的现象。</p><ul><li>锁了又锁，自己加了一次锁后，又锁一次。</li><li>交叉锁</li></ul><h2 id="如何产生"><a href="#如何产生" class="headerlink" title="如何产生"></a>如何产生</h2><p>产生死锁的四个条件：</p><ul><li>互斥条件：进程对分配到的资源不允许其他进程访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源。</li><li>请求和保持条件：进程获得一定的资源后，又对其他资源发出请求，但是该资源可能被其他进程占有，此时请求阻塞，但该进程不会释放自己已经占有的资源。</li><li>不可抢占条件，进程已获得的资源，在未完成使用之前，不可以剥夺，只能在使用后自己释放。</li><li>循环等待条件：进程发生死锁后，必然存在一个进程-资源之间的环形链。</li></ul><h2 id="防止死锁"><a href="#防止死锁" class="headerlink" title="防止死锁"></a>防止死锁</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MMU（内存管理单元）&quot;&gt;&lt;a href=&quot;#MMU（内存管理单元）&quot; class=&quot;headerlink&quot; title=&quot;MMU（内存管理单元）&quot;&gt;&lt;/a&gt;MMU（内存管理单元）&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022</summary>
      
    
    
    
    <category term="OS" scheme="http://isgoudan.top/categories/OS/"/>
    
    
    <category term="OS" scheme="http://isgoudan.top/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>C++小知识点</title>
    <link href="http://isgoudan.top/2022/02/27/C++%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://isgoudan.top/2022/02/27/C++%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2022-02-27T08:11:40.737Z</published>
    <updated>2022-05-18T06:21:59.582Z</updated>
    
    <content type="html"><![CDATA[<h1 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h1><ul><li>指针所指向的内存空间在程序运行过程中可以改变，而引用所绑定的对象一旦绑定就不能改变（是否可变）。</li><li>指针本身在内存中占有内存空间，引用相当于变量别名，而在内存中不占内存空间（是否占内存）。</li><li>指针可以为空，但是引用必须绑定对象（是否可空）。</li><li>指针可以有多级，但是引用只能一级（是否能多级）。</li></ul><h1 id="sizeof和strlen区别"><a href="#sizeof和strlen区别" class="headerlink" title="sizeof和strlen区别"></a>sizeof和strlen区别</h1><ul><li><p>strlen 是函数，sizeof 是运算符。</p></li><li><p>strlen 测量的是字符的实际长度，以’\0’ 结束（不包含’\0’ ）。而sizeof 测量的是字符的分配大小，如果未分配大小，则遇到’\0’ 结束（包含’\0’ ，也就是strlen测量的长度加1），如果已经分配内存大小，返回的就是分配的内存大小。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[] = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> str1[<span class="number">100</span>] = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"> </span><br><span class="line">cout &lt;&lt; <span class="built_in">strlen</span>(str) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(str) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(str1) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190929145538553.png" alt="img"></p><h1 id="不能声明为虚函数的函数"><a href="#不能声明为虚函数的函数" class="headerlink" title="不能声明为虚函数的函数"></a>不能声明为虚函数的函数</h1><p><strong>1，普通函数（非成员函数）</strong>：定义虚函数的主要目的是为了重写达到多态，所以普通函数声明为虚函数没有意义，因此编译器在编译时就绑定了它。<br><strong>2，静态成员函数</strong>：静态成员函数对于每个类都只有一份代码，所有对象都可以共享这份代码，他不归某一个对象所有，所以它也没有动态绑定的必要。,<br><strong>3，内联成员函数</strong>：内联函数本就是为了减少函数调用的代价，所以在代码中直接展开。但虚函数一定要创建虚函数表，这两者不可能统一。另外，内联函数在编译时被展开，而虚函数在运行时才动态绑定。<br><strong>4，构造函数</strong>：这个原因很简单，主要从语义上考虑。因为构造函数本来是为了初始化对象成员才产生的，然而虚函数的目的是为了在完全不了解细节的情况下也能正确处理对象，两者根本不能“ 好好相处 ”。因为虚函数要对不同类型的对象产生不同的动作，如果将构造函数定义成虚函数，那么对象都没有产生，怎么完成想要的动作？？</p><p><strong>5，友元函数</strong>：当我们把一个函数声明为一个类的友元函数时，它只是一个可以访问类内成员的普通函数，并不是这个类的成员函数，自然也不能在自己的类内将它声明为虚函数。</p><p>注意：友元本身可以是虚函数！！<br>如果一个类的友元函数是另一个类成员函数，那么它在自己的类内可以被声明为虚函数。</p><h1 id="restrict关键字"><a href="#restrict关键字" class="headerlink" title="restrict关键字"></a>restrict关键字</h1><p>概括的说，关键字restrict只用于限定指针；通过加上restrict关键字，编程者可提示编译器：在该指针的生命周期内，其指向的对象不会被别的指针所引用，所有修改该指针所指向内容的操作全部都是基于(base on)该指针的，即不存在其它进行修改操作的途径；这样的后果是帮助编译器进行更好的代码优化，生成更有效率的汇编代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add1</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span>* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *a = <span class="number">10</span>;</span><br><span class="line">    *b = <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">return</span> *a + *b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家猜猜<code>add1</code>函数的返回值是多少？是10 + 12 = 22吗？</p><p>答案是不一定。在指针a和b的地址不同时，返回22没有问题。但是当指针a与b指向的是同一个int对象时，该对象先被赋值为10，后被赋值为12，因此<em>a和</em>b都返回12,因此<code>add1</code>函数最终返回24</p><p>使用<code>-O3</code>优化, <code>add1</code>对应的汇编代码如下。可以看到，在计算返回值时，为了得到<code>*a</code>的值访问了1次内存，而不管在何种条件下(<code>a == b</code> or <code>a != b</code>)，<code>*b</code>的值都是12。因此聪明的编译器将<code>*a</code>的值载入<code>eax</code>寄存器后，直接加上立即数12，而无需再访问内存获取<code>*b</code>的值。在无法确定指针a和b是否相同的情况下，编译器只能帮你到这里了.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0000000000400a10 &lt;_Z4add1PiS_&gt;:</span><br><span class="line">  400a10:   c7 07 0a 00 00 00       movl   $0xa,(%rdi) ; *a = 10</span><br><span class="line">  400a16:   c7 06 0c 00 00 00       movl   $0xc,(%rsi) ; *b = 10</span><br><span class="line">  400a1c:   8b 07                   mov    (%rdi),%eax ; 结果 = *a</span><br><span class="line">  400a1e:   83 c0 0c                add    $0xc,%eax   ; 结果 += 12 </span><br><span class="line">  400a21:   c3                      retq</span><br></pre></td></tr></table></figure><p>但是如果加上了restrict关键字，情况便大不相同。C/C++和经过-O3优化的汇编代码如下。通过restrict关键字，编译器依然确认指针a和b不可能指向同一个内存地址，因此在求<code>*a + *b</code>时，无需访问内存，因为<code>*a</code>必然等于立即数10，<code>*b</code>必然等于立即数12。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add2</span><span class="params">(<span class="keyword">int</span>* __restrict  a, <span class="keyword">int</span>* __restrict b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *a = <span class="number">10</span>;</span><br><span class="line">    *b = <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">return</span> *a + *b ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0000000000400</span>a30 &lt;_Z4add2PiS_&gt;:</span><br><span class="line">  <span class="number">400</span>a30:   c7 <span class="number">07</span> <span class="number">0</span>a <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       movl   $<span class="number">0xa</span>,(%rdi) ; *a = <span class="number">10</span></span><br><span class="line">  <span class="number">400</span>a36:   b8 <span class="number">16</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x16</span>,%eax  ; 结果 = <span class="number">22</span></span><br><span class="line">  <span class="number">400</span>a3b:   c7 <span class="number">06</span> <span class="number">0</span>c <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       movl   $<span class="number">0xc</span>,(%rsi) ; *b = <span class="number">12</span></span><br><span class="line">  <span class="number">400</span>a41:   c3                      retq</span><br></pre></td></tr></table></figure><p>通过无restrict和有restrict两种情况下的汇编指令可看到，后者比前者少访问一次内存，且少执行一条指令。</p><p><a href="https://zhuanlan.zhihu.com/p/349726808">参考链接</a></p><h1 id="栈展开"><a href="#栈展开" class="headerlink" title="栈展开"></a>栈展开</h1><ul><li>栈展开（stack unwinding）是指，如果在一个函数内部抛出异常，而此异常并未在该函数内部被捕捉，就将导致该函数的运行在抛出异常处结束，所有已经分配在栈上的局部变量都要被释放。</li><li>危害：在栈展开的过程中，如果被释放的局部变量中有指针，而该指针在此前已经用new运算申请了空间，就有可能导致内存泄露。因为栈展开的时候并不会自动对指针变量执行delete（或delete[]）操作。</li></ul><h1 id="值语义和对象语义"><a href="#值语义和对象语义" class="headerlink" title="值语义和对象语义"></a>值语义和对象语义</h1><ul><li><p>值语义</p><ul><li>所谓值语义是指目标对象由源对象拷贝生成，且生成后与源对象完全无关，彼此独立存在，改变互不影响。就像 int 类型变量相互拷贝一样。</li><li>C++的内置类型（bool/int/double/char）都是值语义，标准库里的 complex&lt;&gt;、pair&lt;&gt;、vector&lt;&gt;、map&lt;&gt;、string 等等类型也都是值语义。</li><li>拷贝之后就与源对象完全脱离关系。</li></ul></li><li><p>对象语义</p><ul><li>对象语义也叫指针语义，引用语义等。</li><li>通常是指一个目标对象由源对象拷贝生成，但生成后与源对象之间依然共享底层资源，对任何一个的改变都将随之改变另一个。就像包含有指针成员变量的自定义类在默认拷贝构造函数下对其对象之间进行的拷贝。拷贝后目标对象和源对象的指针成员变量仍指向同一块内存数据。如果当其中一个被析构掉后，另一个对象的指针成员就会沦为名副其实的悬挂指针！</li><li>又比如，Thread 是对象语义，拷贝 Thread 是无意义的，也是被禁止的：因为 Thread 代表线程，拷贝一个Thread对象并不能让系统增加一个一模一样的线程。</li></ul></li></ul><p><a href="https://www.cnblogs.com/Braveliu/p/3285908.html">参考链接</a></p><h1 id="基于对象和面向对象"><a href="#基于对象和面向对象" class="headerlink" title="基于对象和面向对象"></a>基于对象和面向对象</h1><ul><li>面向对象<ul><li>面向对象的三大特点：封装，继承，多态缺一不可</li><li>封装：数据和处理数据的函数统一起来，封装在一个class中</li><li>继承：通过继承某个类派生出一个新类，被继承的类称作基类，派生出的类称作派生类。派生类是对基类的补充，二者之间满足一定的归属关心，如动物（基类），鸟（派生类）。继承可以是public/private/protected继承，也可以是虚继承（用于解决多重继承带来的重复问题），基类可以是抽象基类（不能被实例化），但是派生类需要重新实现基类定义的每个纯虚函数。</li><li>多态：在继承的基础上通过基类指针指向派生类的实例化对象，达到调用派生类虚函数的目的，多态又被叫做运行时多态，是在运行期根据基类指针实际指向的对象类型判断调用哪个函数的方式。</li></ul></li><li>基于对象<ul><li>无继承，无多态，只有封装</li><li>利用类封装好的接口实现对数据的操作</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;指针和引用的区别&quot;&gt;&lt;a href=&quot;#指针和引用的区别&quot; class=&quot;headerlink&quot; title=&quot;指针和引用的区别&quot;&gt;&lt;/a&gt;指针和引用的区别&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;指针所指向的内存空间在程序运行过程中可以改变，而引用所绑定的对象一旦绑定就不能改</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>适配器</title>
    <link href="http://isgoudan.top/2022/02/25/%E9%80%82%E9%85%8D%E5%99%A8/"/>
    <id>http://isgoudan.top/2022/02/25/%E9%80%82%E9%85%8D%E5%99%A8/</id>
    <published>2022-02-25T05:40:02.661Z</published>
    <updated>2022-02-25T06:56:44.849Z</updated>
    
    <content type="html"><![CDATA[<h1 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h1><h2 id="函数适配器"><a href="#函数适配器" class="headerlink" title="函数适配器"></a>函数适配器</h2><p><strong>一元转二元：</strong></p><ul><li>bind2nd 绑定第二个参数。</li><li>继承binary_function&lt;参数类型1, 参数类型2, 返回值类型&gt;。</li><li>const修饰operator()。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrint</span>:</span> <span class="keyword">public</span> binary_fuction&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">void</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> start)</span>  <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; num+start &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; a&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    cin&lt;&lt;start;</span><br><span class="line">    for_each(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">MyPront</span>(), start));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="取反适配器"><a href="#取反适配器" class="headerlink" title="取反适配器"></a>取反适配器</h2><p>一元取反：</p><ul><li>not1()。</li><li>继承unary_function&lt;参数类型1,  返回值类型 &gt;。</li><li>const修饰。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreaterFive</span>:</span> <span class="keyword">public</span> unary_function&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt; <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 一元取反</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">not1</span>(<span class="built_in">GreatrerFive</span>()));  <span class="comment">//  找不大于5的 返回0。</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数指针适配器"><a href="#函数指针适配器" class="headerlink" title="函数指针适配器"></a>函数指针适配器</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyPrint03</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; v+ start &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tets03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">ptr_fun</span>(<span class="built_in">MyPrint03</span>()), <span class="number">100</span>)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="成员函数适配器"><a href="#成员函数适配器" class="headerlink" title="成员函数适配器"></a>成员函数适配器</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">int</span> age) : <span class="built_in">mAge</span>(age) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; mAge &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;Person&gt; p;</span><br><span class="line">    p.<span class="built_in">push_back</span>(<span class="built_in">Person</span>(<span class="number">1</span>));</span><br><span class="line">    p.<span class="built_in">push_back</span>(<span class="built_in">Person</span>(<span class="number">2</span>));</span><br><span class="line">    p.<span class="built_in">push_back</span>(<span class="built_in">Person</span>(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    for_each(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>(), <span class="built_in">mem_fun_ref</span>(&amp;Person::showAge));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;适配器&quot;&gt;&lt;a href=&quot;#适配器&quot; class=&quot;headerlink&quot; title=&quot;适配器&quot;&gt;&lt;/a&gt;适配器&lt;/h1&gt;&lt;h2 id=&quot;函数适配器&quot;&gt;&lt;a href=&quot;#函数适配器&quot; class=&quot;headerlink&quot; title=&quot;函数适配器&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="适配器" scheme="http://isgoudan.top/tags/%E9%80%82%E9%85%8D%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>仿函数、谓词和lambda表达式</title>
    <link href="http://isgoudan.top/2022/02/25/%E4%BB%BF%E5%87%BD%E6%95%B0%E3%80%81%E8%B0%93%E8%AF%8D%E5%92%8Clambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://isgoudan.top/2022/02/25/%E4%BB%BF%E5%87%BD%E6%95%B0%E3%80%81%E8%B0%93%E8%AF%8D%E5%92%8Clambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2022-02-25T03:08:04.709Z</published>
    <updated>2022-03-15T01:34:10.359Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数对象（仿函数）"><a href="#函数对象（仿函数）" class="headerlink" title="函数对象（仿函数）"></a>函数对象（仿函数）</h1><p>​        重载函数调用操作符的类，其对象称为函数对象，即其行为类似函数的对象，又称为仿函数。重载了“（）”使其可以向函数一样调用。</p><p><strong>注意 ：</strong></p><ul><li>函数对象（仿函数）是一个类，不是一个函数。</li><li>函数对象（仿函数）重载了“（）”使其可以向函数一样调用。</li></ul><p><strong>分类：</strong></p><ul><li>一元仿函数：一个参数。</li><li>二元仿函数：两个参数。</li></ul><h1 id="内建仿函数"><a href="#内建仿函数" class="headerlink" title="内建仿函数"></a>内建仿函数</h1><ul><li>头文件：<code>#include&lt;functional&gt;</code></li><li>取反仿函数：<code>template&lt;class T&gt; T negate&lt;T&gt;</code></li><li>加法仿函数：<code>template&lt;class T&gt; T plus&lt;T&gt;</code> </li><li>大于仿函数：<code>template&lt;class T&gt; bool greater&lt;T&gt;</code></li><li>小于仿函数：<code>template&lt;class T&gt; bool less&lt;T&gt;</code></li><li>….</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">negate&lt;<span class="keyword">int</span>&gt; n;</span><br><span class="line">cout &lt;&lt; <span class="built_in">n</span>(<span class="number">10</span>) &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    plus&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">plus</span>(<span class="number">1</span>,<span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; a &#123;<span class="number">1</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());  <span class="comment">// 7 7 6 4 3 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h1><p>​        谓词就是一个判断式，是一个返回bool类型的函数，或者也可以是函数对象（仿函数）。一个参数是一元谓词，两个参数是二元谓词。</p><h1 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h1><ul><li>写法：<code>[捕获列表](参数列表) &#123; 函数内容 &#125;</code>。</li><li>捕获列表是lambda所在函数中定义的局部变量的列表。</li><li>捕获作用：若某算法的可调用表达式是一元谓词但是需要多个参数时则可用捕获。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;函数对象（仿函数）&quot;&gt;&lt;a href=&quot;#函数对象（仿函数）&quot; class=&quot;headerlink&quot; title=&quot;函数对象（仿函数）&quot;&gt;&lt;/a&gt;函数对象（仿函数）&lt;/h1&gt;&lt;p&gt;​        重载函数调用操作符的类，其对象称为函数对象，即其行为类似函数的对象</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="仿函数" scheme="http://isgoudan.top/tags/%E4%BB%BF%E5%87%BD%E6%95%B0/"/>
    
    <category term="谓词" scheme="http://isgoudan.top/tags/%E8%B0%93%E8%AF%8D/"/>
    
    <category term="lambda" scheme="http://isgoudan.top/tags/lambda/"/>
    
  </entry>
  
  <entry>
    <title>Linux基础知识点</title>
    <link href="http://isgoudan.top/2022/02/24/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://isgoudan.top/2022/02/24/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2022-02-24T07:01:28.387Z</published>
    <updated>2022-04-13T08:48:42.869Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><table><thead><tr><th>命令</th><th>执行操作</th></tr></thead><tbody><tr><td>history</td><td>查看历史命令</td></tr><tr><td>ls</td><td>查看文件目录    -l 显示详细信息    -a 显示隐藏目录    -R递归显示子目录信息</td></tr><tr><td>cd</td><td>更改目录</td></tr><tr><td>pwd</td><td>查看当前的工作目录</td></tr><tr><td>mkdir</td><td>创建目录</td></tr><tr><td>tree</td><td>目录成树状显示</td></tr><tr><td>rmdir</td><td>删除目录，只能删非空目录</td></tr><tr><td>which</td><td>显示对应命令所在的路径</td></tr><tr><td>touch</td><td>创建文件，如果不存在创建，如果存在则只更改访问时间</td></tr><tr><td>rm</td><td>删除文件或者目录  -r 递归删除子目录    rm -rf * 强制删除目录下所有内容</td></tr><tr><td>cp</td><td>拷贝文件或者目录</td></tr><tr><td>mv</td><td>移动文件或者目录</td></tr><tr><td>cat</td><td>直接显示文件信息</td></tr><tr><td>more和less</td><td>分屏显示文件信息</td></tr><tr><td>head</td><td>head -n file 显示文件头n行，不加-n默认10行</td></tr><tr><td>tail</td><td>tail -n file 显示文件后n行；tail -f file 查看文件尾部内容，不退出，用于追踪日志</td></tr><tr><td>du</td><td>-h 查看文件占用空间</td></tr><tr><td>ln</td><td>建立硬连接   ln hello hello.hard1   见下图 ；  ln -s hello hello.hard3  建立软连接</td></tr><tr><td>unlink</td><td>删除软硬连接</td></tr><tr><td>chmod</td><td>改变文件权限</td></tr><tr><td>chown</td><td>改变文件所属权限  sudo chown   用户：组  文件名|目录</td></tr><tr><td>find</td><td>find dir [opt] 内容     opt：-name  -type  -size        按名字、类型、大小找文件</td></tr><tr><td>grep</td><td>过滤信息</td></tr><tr><td>xargs</td><td>将前一目录的输出分成小块输入给后面的命令</td></tr><tr><td>zip</td><td>zip -r zipname.zip filename1 filename2 …   压缩文件  -r递归子目录</td></tr><tr><td>unzip</td><td>unzip zipname.zip  解压文件</td></tr><tr><td>tar</td><td>tar zcvf zipname.tar.gz filename1 filename2 …  压缩文件 <br />tar zxvf zipname.tar.gz  解压文件</td></tr><tr><td>rar</td><td>rar a -r rarname（可以无后缀） filename1 filename2 …  压缩文件<br />rar x rarname.rar 解压文件</td></tr><tr><td>ps</td><td>ps aux 查看进程信息<br />ps ajk  也是查看进程信息，可以追溯进程之间的血缘关系</td></tr><tr><td>kill</td><td>给进程发送一个信号<br /> kill -9 pid  杀死进程</td></tr></tbody></table><h1 id="小知识点"><a href="#小知识点" class="headerlink" title="小知识点"></a>小知识点</h1><p><strong>通配符*和？：</strong>* 代表任意多个字符，? 代表任意一个字符。</p><p><strong>相对路径和绝对路径：</strong> 以”/“开头为绝对路径，否则为相对路径。 </p><p><font color=red>linux一切皆文件。</font></p><p><strong>文件权限表示法：</strong></p><p><img src="https://s2.loli.net/2022/02/26/aCGT69pZHrv8cnO.png" alt="image.png"></p><p><strong>硬连接和软连接：</strong></p><ul><li>在Linux中，在磁盘分区中的文件不管什么类型都有一个编号， 叫索引节点号。Linux中可以多个文件名指向同一个索引节点，这种方式就叫硬连接，硬连接作用就是可以一个文件拥有多个有效的路径名，防止误删，只有当对应索引节点的所有硬连接全被删除之后，文件的数据块才会被释放。</li><li>软连接就类似于windows快捷方式，删了对硬连接无影响，硬连接全没了，软连接也就失效了。</li></ul><p><img src="https://s2.loli.net/2022/02/26/dSngu69ODZKw2Vp.png" alt="image.png"></p><p><strong>类unix系统目录结构：</strong></p><p><img src="https://s2.loli.net/2022/02/26/NRCgm4r6dMULqFb.png" alt="image.png"></p><p><strong>进程的虚拟地址空间</strong></p><p><img src="https://s2.loli.net/2022/03/03/yKps2PtraMoSBZG.png" alt="QQ截图20220303111420.png"></p><h1 id="GCC流程"><a href="#GCC流程" class="headerlink" title="GCC流程"></a>GCC流程</h1><ul><li><strong>示例代码</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="keyword">int</span> main（<span class="keyword">void</span>） &#123;</span><br><span class="line"><span class="built_in">printf</span>（<span class="string">&quot;hello\n&quot;</span>）;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>预编译过程</strong></li></ul><p>这个过程处理宏定义和include，去除注释，不会对语法进行检查。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E a.c -o a.i</span><br></pre></td></tr></table></figure><ul><li><strong>编译过程</strong></li></ul><p>这个阶段，检查语法，生成汇编代码。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S a.i -o a.s</span><br></pre></td></tr></table></figure><ul><li><strong>汇编过程</strong></li></ul><p>这个阶段，生成目标代码。</p><p>此过程生成ELF格式的目标代码。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c a.s -o a.o</span><br></pre></td></tr></table></figure><ul><li><strong>链接过程</strong></li></ul><p>链接过程。生成可执行代码。链接分为两种，一种是静态链接，另外一种是动态链接。使用静态链接的好处是，依赖的动态链接库较少，对动态链接库的版本不会很敏感，具有较好的兼容性；缺点是生成的程序比较大。使用动态链接的好处是，生成的程序比较小，占用较少的内存。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc a.o -o a</span><br><span class="line">./a</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200607142556997.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcxODc5NA==,size_16,color_FFFFFF,t_70" alt="image.png"></p><p><strong>动态库和静态库制作流程：</strong><a href="https://blog.csdn.net/weixin_44718794/article/details/106599417">https://blog.csdn.net/weixin_44718794/article/details/106599417</a></p><h1 id="Makefile文件编写"><a href="#Makefile文件编写" class="headerlink" title="Makefile文件编写"></a>Makefile文件编写</h1><ul><li><p>命名规则：makefile  Makefile</p></li><li><p>写法：</p><ul><li>目标：依赖</li><li>Tab键 规则命令</li></ul></li><li><p>Eg（第一版 ）：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">app:main.c add.c sub.c div.c mul.c</span></span><br><span class="line">gcc -o app -I ./<span class="keyword">include</span> main.c add.c sub.c div.c mul.c</span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line"><span class="comment"># make -f makefilename 可以指定具体的makefile文件</span></span><br></pre></td></tr></table></figure><p>如果更改其中一个，所有源码都重新编译。</p><p>Eg（第二版 ）：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># objFlies 定义的目标文件</span></span><br><span class="line">objFiles=main.o add.o sub.o div.o mul.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标文件用法 $（var）</span></span><br><span class="line"><span class="section">app:<span class="variable">$(objFiles)</span></span></span><br><span class="line">gcc -o app -I ./<span class="keyword">include</span> main.o add.o sub.o div.o mul.o</span><br><span class="line"></span><br><span class="line"><span class="section">main.o:main.c</span></span><br><span class="line">gcc -c main.c -I./<span class="keyword">include</span></span><br><span class="line"><span class="section">add.o:add.c</span></span><br><span class="line">gcc -c add.c -I./<span class="keyword">include</span></span><br><span class="line"><span class="section">sub.o:sub.c</span></span><br><span class="line">gcc -c sub.c -I./<span class="keyword">include</span></span><br><span class="line"><span class="section">div.o:div.c</span></span><br><span class="line">gcc -c div.c -I./<span class="keyword">include</span></span><br><span class="line"><span class="section">mul.o:mul.c</span></span><br><span class="line">gcc -c mul.c -I./<span class="keyword">include</span></span><br></pre></td></tr></table></figure><p>makefile隐含规则：默认处理第一个目标。</p><p>Eg（第三版 ）：</p><ul><li>函数：<ul><li>wildcard 进行文件匹配。</li><li>patsubst 内容替换。</li></ul></li><li>makefile变量：<ul><li>$@ 代表目标。</li><li>$^ 代表全部依赖。</li><li>$&lt; 代表第一个依赖。</li><li>$? 代表第一个变化的依赖 。</li></ul></li><li>@在规则前代表不输出该条规则的命令。</li><li>-在规则前代表该条规则报错，仍然继续执行。</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">SecFiles =<span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line"></span><br><span class="line">objFiles=<span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,<span class="variable">$(SrcFiles)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标文件用法 $（var）</span></span><br><span class="line"><span class="section">app:<span class="variable">$(objFiles)</span></span></span><br><span class="line">gcc -o app -I ./<span class="keyword">include</span> <span class="variable">$(objFiles)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># $@,$&lt;只能在规则中出现</span></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">gcc -c <span class="variable">$&lt;</span> -I ./<span class="keyword">include</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义伪目标，防止有歧义</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:clean all</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm *.o</span><br><span class="line">rm app</span><br></pre></td></tr></table></figure></li></ul><h1 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h1><ul><li>启动gdb:<code>gdb app</code>app为对应程序名。</li><li>在gdb启动程序：<ul><li><code>r(un)</code> 启动。</li><li><code>start</code> 启动-停留在 main函数，分步调试。</li><li><code>n(ext)</code> 下一条指令。</li><li><code>s(tep)</code> 下一条指令，可以进入函数内部，库函数不能进。</li><li><code>q(uit)</code> 退出。</li><li><code>b(reak)</code> n 在主函数所在文件 第n行设置断点， <code>b func</code> 在func函数设置断点， <code>b main.cpp:2=10</code> 在某个文件某一行设置断点；<code>b main.cpp:2=10 if i==0</code>设置条件断点。</li><li><code>l(ist)</code> 查看主函数对应文件，<code>list func.cpp:1</code>看func从第一行 。</li><li><code>info b</code> 查看断点。</li><li><code>d(el)  n</code> 删除断点，n对应info b里的第几个 断点。</li><li><code>c(ontinue)</code> 跳到下一断点。</li><li><code>p(rint) context </code>打印context的内容。</li><li><code>ptype x</code>  打印x类型。</li><li><code>set</code> 设置变量值。</li><li><code>display argc</code> 执行任何一个指令argc的值都显示一下。</li><li><code>undisplay n</code>不显示display，n代表display的那个行号，也可以通过info display查看。</li></ul></li><li>gdb追踪core<ul><li>查看core文件大小 ：<code>ulimit -c</code></li><li>设置生成core文件大小：<code>ulimit -c unlimited</code> 设置无限大</li><li>gdb app core<ul><li>where 查看错误在哪。</li></ul></li></ul></li></ul><h1 id="umask"><a href="#umask" class="headerlink" title="umask"></a>umask</h1><ul><li>设置文件没有的权限。</li><li>用户默认创建文件的最高权限为666。</li><li>用户默认创建目录的最高权限为777。</li></ul><h1 id="Linux库函数"><a href="#Linux库函数" class="headerlink" title="Linux库函数"></a>Linux库函数</h1><p><strong>open：</strong></p><ul><li>查看 man 2 open</li><li><code>int open(const char *pathname, int flags);</code></li><li><code>int open(const char *pathname, int flags, mode_t mode);</code><ul><li>pathname 文件名</li><li>flags<ul><li>必选项<ul><li>O_RDONLY  只读。</li><li>O_WRONLY 只写。</li><li>O_RWR         读写。</li></ul></li><li>可选项<ul><li>O_APPEND 追加。</li><li>O_CREAT    创建文件。<ul><li>O_EXCL 与 O_CREAT 如果文件存在报错。</li><li>创建的文件权限是（mode&amp;~umask）。</li></ul></li><li>O_NONBLOCK  非阻塞。</li></ul></li></ul></li></ul></li><li>返回值：返回一个新的文件描述符，返回的是当前最小可用的文件描述符。失败返回-1，设置errno。</li><li>注意：在打开fifo文件时read端会阻塞等待write端open，write端同理，也会阻塞的能带另一端打开。</li></ul><p><strong>close</strong>：</p><ul><li><code>int close(int fd);</code> 关闭文件描述符。</li><li>返回值：成功返回0，失败返回-1。</li></ul><p><strong>read：</strong></p><ul><li><code> ssize_t read(int fd, void *buf, size_t count);</code></li><li>fd          文件描述符</li><li>buf        缓冲区</li><li>count    缓冲区大小</li><li>返回值：<ul><li>失败返回-1，设置errno。</li><li>成功返回读的大小。</li><li>0代表读到文件末尾。</li><li>非阻塞的情况下，read返回-1，但是此时需要判断errno的值。</li></ul></li></ul><p><strong>write：</strong></p><ul><li><code>ssize_t write(int fd, const void *buf, size_t count);</code></li><li>fd          文件描述符</li><li>buf        缓冲区</li><li>count    缓冲区大小</li><li>返回值：失败返回-1，设置errno；成功返回写入的字节数；0代表未写入。 </li></ul><p><strong>lseek:</strong></p><ul><li><p><code>off_t lseek(int fd, off_t offset, int whence);</code></p></li><li><p>fd 文件描述符</p></li><li><p>offset 偏移量 设0</p></li><li><p>whence </p><ul><li>SEEK_SET  文件开始位置    </li><li>SEEK_CUR 当前位置</li><li>SEEK_END 结尾</li></ul></li><li><p>返回值：成功返回当前位置到开始的长度；失败返回-1，设置errno。</p></li><li><p>函数作用：</p><ul><li>移动文件读写位置。</li><li>计算文件大小。</li><li>拓展文件。</li></ul></li></ul><p><strong>阻塞的概念：</strong></p><ul><li>read函数在读设备或者读管道或者读网络的时候。</li></ul><p><strong>fcntl：</strong></p><ul><li><p><code>int fcntl(int fd, int cmd, ... /* arg */ );</code></p></li><li><pre><code class="c++">int fd = open(&quot;/dev/tty&quot;, O_RDWR)// 设置非阻塞int flags = fcntl(fd, F_GETFL);flags |= O_NONBLOCK;fcntl(fd, F_SETFL, flags);</code></pre></li></ul><p><strong>stat:</strong></p><ul><li><p><code>int stat(const char *pathname, struct stat *statbuf);</code>获得文件信息。</p></li><li><p>函数参数</p><ul><li>pathname 文件名。</li><li>statbuf       传出参数。</li></ul></li><li><p>返回值：成功返回0，失败返回-1，设置errno。</p></li><li><p>lstat和stat：stat会穿透到源文件，lstat不会。</p></li></ul><p><strong>access：</strong></p><ul><li>判断文件权限和文件是否存在。具体用法百度。</li></ul><p><strong>truncate：</strong></p><ul><li>截断文件。用法百度。</li></ul><p><strong>link系列函数：</strong></p><ul><li>创建删除软硬连接，读取连接。用法百度。</li></ul><p><strong>rename：</strong></p><ul><li>重命名函数。</li></ul><p><strong>getcwd：</strong></p><ul><li>获取当前工作路径。</li></ul><p><strong>chdir：</strong></p><ul><li>改变进程工作路径。</li></ul><p><strong>mkdir、rmdir、opendir、readdir、closedir：</strong></p><ul><li>创建删除打开读关闭 dir。</li></ul><p><strong>dup2和dup:</strong></p><ul><li>主要用于重定向。</li><li><code>int dup2(int oldfd, int newfd);</code><ul><li>把newfd指向oldfd。</li><li>成功返回newfd，失败返回-1，设置errno。</li></ul></li><li><code>int dup(int oldfd);</code><ul><li>新生成一个fd指向oldfd，新生成的fd是当前可用最小的。</li><li>返回值为新的fd。</li></ul></li></ul><p><strong>execl和execlp：</strong></p><ul><li><code>int execl(const char *path, const char *arg, .../* (char  *) NULL */);</code><ul><li>执行其他程序，需要加路径。</li><li>Eg：<code>execl(&quot;./bin/ls&quot;, &quot;ls&quot;, &quot;-l&quot;, NULL);</code></li></ul></li><li><code>int execlp(const char *file, const char *arg, .../* (char  *) NULL */);</code><ul><li>执行程序，使用当前PATH环境变量，可以不用加路径。</li><li>Eg：<code>execl(&quot;ls&quot;, &quot;ls&quot;, &quot;-l&quot;, NULL);</code></li></ul></li><li>path/file 为要执行的程序。</li><li>arg参数列表<ul><li>列表最后要一个NULL结尾。</li></ul></li><li>返回值：只有失败才返回。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;常用命令&quot;&gt;&lt;a href=&quot;#常用命令&quot; class=&quot;headerlink&quot; title=&quot;常用命令&quot;&gt;&lt;/a&gt;常用命令&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;执行操作&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tb</summary>
      
    
    
    
    <category term="Linux" scheme="http://isgoudan.top/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://isgoudan.top/tags/Linux/"/>
    
    <category term="GCC" scheme="http://isgoudan.top/tags/GCC/"/>
    
    <category term="makefile" scheme="http://isgoudan.top/tags/makefile/"/>
    
  </entry>
  
  <entry>
    <title>C++STL</title>
    <link href="http://isgoudan.top/2022/02/23/STL/"/>
    <id>http://isgoudan.top/2022/02/23/STL/</id>
    <published>2022-02-23T03:17:51.490Z</published>
    <updated>2022-03-15T03:10:59.945Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>​        STL广义上分为：容器（container）、算法（algorithm）、迭代器（iterator）。容器和算法通过迭代器进行无缝连接。</p><p>​        STL细分为六大组件：容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器。</p><ul><li>容器：各种数据结构，如vector、list、deque、set、map等，用来存放数据。从实现角度看，STL容器是一种class template。</li><li>算法：各种常用算法，如sort、find、copy、for_each。从实现角度看，STL算法是一种function template。</li><li>迭代器：扮演了容器和算法之间的调和剂，共5种类型（输入、输出、前向、双向、随机访问）。从实现角度看，迭代器是一种将operator*，operator-&gt;，operator++，operator–等指针相关操作予以重载的class template，所有的STL容器都有自己的专属迭代器。原生指针（native pointer）也是一种迭代器。</li><li>仿函数：行为类似函数，可作为算法的某种策略。从实现角度看，仿函数是一种重载了operator()的class或者class template。</li><li>适配器：一种用来修饰容器或者仿函数迭代器接口的东西。</li><li>空间配置器：负责空间的配置与管理。从实现角度看，配置器是一个实现了动态空间配置、空间管理、空间释放的class template。</li></ul><p>​        STL六大组件的交互关系：容器通过空间配置器取得数据存储空间，算法通过迭代器存储容器中的内容，仿函数可以协助算法完成不同策略得变化，适配器可以修饰仿函数。</p><h1 id="STL优点"><a href="#STL优点" class="headerlink" title="STL优点"></a>STL优点</h1><ul><li>STL为C++一部分，不用额外安装。</li><li>STL一个重要特性是将数据和操作分离，数据由容器类别加以管理，操作则由可定制的算法定义。迭代器在两者之间充当“粘合剂”，以使算法可以和容器交互运作。</li><li>程序员不用考虑STL内部实现，直接使用。</li><li>STL具有高可重用性，高性能，高移植性，跨平台的优点。<ul><li>高可重用性：STL几乎所有代码都采用模板类和模板函实现，相比于传统的函数和类提供了更好的代码重用机会。</li><li>高性能：如map可以高效从大量数据在检索指定记录，因为采用红黑树。</li><li>高移植性：如在项目A使用STL编写模块，可以直接移植到项目B。</li></ul></li></ul><h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><ul><li>序列式容器：强调值的顺序，每个元素均有固定位置，除非用插入删除操作改变，如vector、deque、list等。</li><li>关联式容器：非线性的二叉树结构，个元素间没有严格的物理上得顺序关系，也就是说元素在容器中并没有保存元素置入容器时的逻辑顺序。关联式容器一个显著特点：在值中选择一个值作为关键字key，key起到索引的作用，方便查找。如set、multiset、map、multimap等。 </li></ul><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><ul><li>质变算法：运算过程中改变区间内元素内容。如拷贝，替换，删除等。</li><li>非质变算法：运算过程中不改变区间内元素内容。如查找，计数，遍历等。</li></ul><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>​        提供一种方法，使之能够依序遍历某个容器所含的各个元素，而又无需暴露该容器内部的表示方式。</p><table><thead><tr><th>名称</th><th>功能</th><th>支持操作</th></tr></thead><tbody><tr><td>输入迭代器</td><td>提供对数据的只读访问</td><td>只读，支持++，–，!=</td></tr><tr><td>输出迭代器</td><td>提供对数据的只写访问</td><td>只写，支持++</td></tr><tr><td>前向迭代器</td><td>提供读写操作，并向前推进迭代器</td><td>读写，支持++，==，!=</td></tr><tr><td>双向迭代器</td><td>提供读写操作，并能向前和向后操作</td><td>读写，支持++,–，==，!=</td></tr><tr><td>随机访问迭代器</td><td>提供读写操作，并能以跳跃的方式访问容器的任意数据，功能最强。</td><td>读写，支持++，–，[n]，-n，&lt;，&lt;=，&gt;，&gt;=, ==，!=</td></tr></tbody></table><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><ul><li>s[]访问和s.at()访问区别：[]访问越界会直接挂掉，at则抛出异常。</li><li>string -&gt; const char* :   <code>const char *p = s.c_str();</code> 。</li><li>const char* -&gt; string：<code>string s2(p);</code>。</li><li>C++存在const char*到string的隐式类型转换，不存在从string到const char*的隐式类型转换。</li></ul><h1 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h1><ul><li><p>vector所谓的动态增加大小，并不是在原有空间之后虚接新空间，而是找一块更大空间，将原数据拷贝，然后释放原空间。所以一旦引起空间配置，则原有的迭代器失效。</p></li><li><p>利用swap收缩空间：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;    <span class="comment">// &gt;10000</span></span><br><span class="line">    cout &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// = 10000</span></span><br><span class="line">    </span><br><span class="line">    v.<span class="built_in">resize</span>(<span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;    <span class="comment">// &gt;10000  和之前一样</span></span><br><span class="line">    cout &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// = 3</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 巧用swap</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;(v).<span class="built_in">swap</span>(v);<span class="comment">// v初始化匿名对象，交换两个指针，然后释放掉匿名对象（那个大的就被释放了）</span></span><br><span class="line">    cout &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;    <span class="comment">// = 3  </span></span><br><span class="line">    cout &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// = 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>reserve(int len);</code>容器预留len个元素长度，预留位置不初始化，元素不可访问。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(p != &amp;v[<span class="number">0</span>]) &#123;  <span class="comment">// 查看开辟10万个数据重新开辟多少次空间。</span></span><br><span class="line">            p = &amp;v[<span class="number">0</span>];</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; num &lt;&lt; endl; <span class="comment">// &gt;1,好多次</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 改进：</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    v1.<span class="built_in">reserve</span>(<span class="number">100000</span>);</span><br><span class="line">    <span class="keyword">int</span> *p1 = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(p1 != &amp;v[<span class="number">0</span>]) &#123;  <span class="comment">// 查看开辟10万个数据重新开辟多少次空间。</span></span><br><span class="line">            p1 = &amp;v[<span class="number">0</span>];</span><br><span class="line">            num1++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; num1 &lt;&lt; endl; <span class="comment">//  = 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>s[]访问和s.at()访问区别：[]访问越界会直接挂掉，at则抛出异常。</p></li></ul><h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><ul><li>没有迭代器，不提供遍历功能。</li></ul><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><ul><li><p>双向循环链表。</p></li><li><p>不支持随机访问。</p></li><li><p>所有不支持随机访问的迭代器，不可以用系统提供的算法，但是这个类内部会提供。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="keyword">int</span>&gt; L&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(L.<span class="built_in">begin</span>(), L.<span class="built_in">end</span>());  <span class="comment">// 报错</span></span><br><span class="line">L.<span class="built_in">sort</span>();</span><br></pre></td></tr></table></figure></li></ul><h1 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h1><h2 id="优先队列使用lambda表达式"><a href="#优先队列使用lambda表达式" class="headerlink" title="优先队列使用lambda表达式"></a>优先队列使用lambda表达式</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> cmp = [&amp;nums1, &amp;nums2](<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp; a, <span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp; b) &#123;</span><br><span class="line">    <span class="keyword">return</span> nums1[a.first] + nums2[a.second] &gt; nums1[b.first] + nums2[b.second];</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">que</span>(cmp);</span><br></pre></td></tr></table></figure><ul><li>decltype 类型指示符，返回函数的返回值类型。</li><li>在初始化priority_queue时，&lt;&gt;中的三个参数必须都是类型名，而cmp为实例化的对象，所以加decltype进行转换。</li><li>que后加（cmp）原因是priority_queue内部实现的时候是根据&lt;&gt;第三个参数实例化一个对象，也就是需要调用其默认构造函数，但是因为lambda这种特殊的class没有默认构造函数，所以需要调用其拷贝构造函数，priority_queue内部定义了这种实现方式，就是通过que(cmp)传入cmp（lambda对象）来直接进行排序操作。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;p&gt;​        STL广义上分为：容器（container）、算法（algorithm）、迭代器（iterator）。容器</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="STL" scheme="http://isgoudan.top/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>进程、线程和信号</title>
    <link href="http://isgoudan.top/2022/02/22/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/"/>
    <id>http://isgoudan.top/2022/02/22/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/</id>
    <published>2022-02-22T12:09:07.884Z</published>
    <updated>2022-04-13T07:42:49.623Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>​        进程是操作系统中最重要的抽象概念之一，是资源分配的基本单位，是独立运行的基本单位。</p><p>​        进程的经典定义就是一个执行中程序的实例。系统中的每个程序（程序就是编译好的二进制文件）都运行在某个进程的上下文（context）中。上下文是由程序正确运行所需的状态组成。这个状态包括存放在内存中的程序代码和数据，他的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。</p><p>进程一般由以下部分组成：</p><ul><li>进程控制块PCB，是进程存在的唯一标志，包含进程标识符PID、进程当前状态、程序、数据地址、进程优先级、CPU现场保护区（用于进程切换）、占有的资源清单等等。</li><li>程序段。</li><li>数据段。</li></ul><h2 id="进程和程序"><a href="#进程和程序" class="headerlink" title="进程和程序"></a>进程和程序</h2><ul><li>程序是编译好的二进制文件。</li><li>进程是运行着的程序。从程序员角度，进程是运行一系列指令的过程。从操作系统角度，进程是资源分配的基本单位，是独立运行的基本单位。</li><li>区别：<ul><li>程序占用磁盘，不占用系统资源。</li><li>进程占用内存，占用系统资源。</li><li>一个程序可以对应多个进程，一个进程只能对应一个程序。</li><li>程序没有生命周期，进程有。</li></ul></li></ul><h2 id="简述进程间通信方法"><a href="#简述进程间通信方法" class="headerlink" title="简述进程间通信方法"></a>简述进程间通信方法</h2><p>​        每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程A把数据从用户空间拷到内核缓冲区，进程B再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信。</p><p>​        不同进程间的通信本质：进程之间可以看到一份公共资源；而提供这份资源的形式或者提供者不同，造成了通信方式的不同。</p><p>​        进程间通信主要包括管道、系统IPC（包括消息队列、信号量、信号、共享内存等）以及套接字socket。</p><h2 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h2><ul><li>IPC：Inter Process Communication进程间通信，通过内核提供的缓冲区进行数据交换的机制。</li><li>常见通信方式：单工（广播），半双工（对讲机），全双工（打电话）。</li><li>IPC通信方式：<ul><li>pipe             管道–只支持有血缘关系的进程间通信，半双工通信。</li><li>fifo               有名管道–不同进程间也可以通信。</li><li>mmap          文件映射（共享）IO–速度最快。</li><li>本地socket  最稳定。</li><li>信号              携带信息量最小。</li><li>共享内存    </li><li>消息队列</li></ul></li></ul><h2 id="进程的状态与状态转换"><a href="#进程的状态与状态转换" class="headerlink" title="进程的状态与状态转换"></a>进程的状态与状态转换</h2><p>进程在运行时有三种基本状态：就绪态、运行态和阻塞态。（五态模型还有新建态和终止态）。</p><ul><li>运行态：进程占有处理器正在运行的状态。进程已获得CPU，其程序正在执行。在单处理机系统中，只有一个进程处于执行状态；在多处理机系统中，则有多个进程处于执行状态。</li><li>就绪态：进程具备运行条件，等待系统分配处理器以便运行的状态。当进程已分配到除CPU以外的所有必要资源后，只要再获得CPU，便可立即执行，进程这时的状态称为就绪态。在一个系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列。</li><li>阻塞态：又称为等待态或睡眠态，指进程不具备运行条件，正在等待某个时间完成的状态。</li></ul><p>各状态之间的转换：</p><p><img src="https://s2.loli.net/2022/03/09/p9TfiQYyzcDGXF2.png" alt="进程状态转换"></p><ul><li>就绪→执行：处于就绪状态的进程，当进程调度程序为之分配了处理机后，该进程便由就绪状态转变成运行状态。</li><li>执行→就绪：处于运行态程序在执行过程中，因分配给他的一个时间片用完而不得不让出CPU，遇是进程从运行态转变成就绪态。</li><li>执行→阻塞：正在执行的进程因等待某种事件发生而无法继续执行时，便从执行状态变成阻塞态。</li><li>阻塞→就绪：处于阻塞态的进程，若等待的事件已经发生，于是进程由阻塞状态转变为就绪态。</li></ul><h2 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h2><p>​        管道是一种最基本的IPC机制，作用域有血缘关系的进程之间，完成数据传递。调用pipe系统函数即可创建一个管道，有如下特质：</p><ul><li>其本质是一个伪文件（实为一个内核缓冲区）。</li><li>有两个文件描述符引用，一个表示读端，一个表示写端，</li><li>规定数据从管道的写端流入管道，从读端流出。</li></ul><p><strong>管道原理：</strong>管道实为内核使用环形队列机制，借助内核缓冲区实现。</p><p><strong>管道局限性：</strong></p><ul><li>数据自己读不能自己写，如果需要双向通信需要创建多根管道。 </li><li>数据一旦被读走，便不在管道中存在，不可反复读取。</li><li>由于管道采用半双工通信方式，因此数据只能在一个方向流动。</li><li>只能在有公共祖先的进程间使用管道。</li></ul><p><strong>管道函数：</strong></p><ul><li><p><code> int pipe(int pipefd[2]);</code></p><ul><li>pipefd 读写文件描述符，0代表读，1代表写。</li><li>返回值：失败-1，成功0。</li></ul></li><li><p>读管道 ：</p><ul><li>写端 全部关闭 – read读到0，相当于读到文件末尾。</li><li>写端没有全部关闭。<ul><li>有数据  – read读到数据。</li><li>无数据  – read阻塞，fcntl函数可以更改非阻塞。</li></ul></li></ul></li><li><p>写管道：</p><ul><li>读端全部关闭  –  产生一个信号SIGPIPE，程序异常终止。</li><li>读端未全部关闭。<ul><li>管道已满  –  write阻塞。</li><li>管道未满  –  write正常写入。</li></ul></li></ul></li></ul><ul><li><code>long fpathconf(int fd, int name);</code><ul><li>计算管道大小。</li><li>name 设置为  _PC_PIPE_BUF。</li></ul></li></ul><h2 id="FIFO通信"><a href="#FIFO通信" class="headerlink" title="FIFO通信"></a>FIFO通信</h2><p>​        FIFO有名管道，实现无血缘关系进程通信。</p><ul><li>创建一个管道的伪文件。<ul><li>mkfifo myfifo 命令创建。</li><li><code>int mkfifo(const char *pathname, mode_t mode);</code> 函数创建。</li></ul></li><li>内核会针对fifo文件开辟一个缓冲区，操作fifo文件–实际上就是文件读写，可以操作缓冲区，实现进程间通信。</li></ul><h2 id="mmap通信"><a href="#mmap通信" class="headerlink" title="mmap通信"></a>mmap通信</h2><p>​        mmap共享映射区，可以无血缘关系进程通信。</p><ul><li><code>void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);</code><ul><li>创建映射区。</li><li>addr     传NULL。</li><li>length  映射区长度。</li><li>prot：<ul><li>PROT_READ   可读 。</li><li>PROT_WRITE  可写。</li><li>MAP_ANON     可以创建匿名映射，不用再建立一个文件，这时候fd设为-1。这个宏在有些Unix系统没有，匿名映射只能实现有血缘关系的进程通信。</li></ul></li><li>flag：<ul><li>MAP_SHARED 共享的，对内存的修改会影响到源文件。</li><li>MAP_PRIVATE 私有的，修改不反应到磁盘实际文件，是一个copy-on-write（写时复制）的映射方式。</li></ul></li><li>fd  文件描述符。</li><li>offeset  偏移量。</li><li>返回值：<ul><li>成功返回可用的内存首地址。</li><li>失败返回MAP_FAILED。</li></ul></li></ul></li><li><code>int munmap(void *addr, size_t length);</code><ul><li>释放映射区。</li><li>addr 传mmap返回值。</li><li>length mmap创建的长度。</li><li>返回值：<ul><li>失败返回-1。</li><li>成功返回0。</li></ul></li></ul></li></ul><p><img src="https://s2.loli.net/2022/03/08/W9iZmHUJXEIGMRO.png" alt="QQ截图20220308132738.png"></p><h2 id="共享内存通信"><a href="#共享内存通信" class="headerlink" title="共享内存通信"></a>共享内存通信</h2><p>​        共享内存使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。</p><p><strong>特点：</strong></p><ul><li>共享内存是最快的一种IPC，因为进程是直接对内存进行操作来实现通信，避免了数据在用户空间和内核空间来回拷贝。</li><li>因为多个进程可以同时操作，所以需要进行同步处理。</li><li>信号量和共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。</li></ul><h2 id="进程调度的时机"><a href="#进程调度的时机" class="headerlink" title="进程调度的时机"></a>进程调度的时机</h2><ul><li>当前运行的进程运行结束。</li><li>当前运行的进程由于某种原因阻塞。</li><li>执行完系统调用等系统程序后返回用户进程。</li><li>在使用抢占调度的系统中，具有更高优先级的进程就绪时。</li><li>分时系统中，分给当前进程的时间片用完。</li></ul><h2 id="不能进行进程调度的情况"><a href="#不能进行进程调度的情况" class="headerlink" title="不能进行进程调度的情况"></a>不能进行进程调度的情况</h2><ul><li>在中断处理程序执行时。</li><li>在操作系统的内核程序临界区内。</li><li>其他需要完全屏蔽中断的原子操作过程中。</li></ul><h2 id="进程的调度策略"><a href="#进程的调度策略" class="headerlink" title="进程的调度策略"></a>进程的调度策略</h2><ul><li>先到先服务调度算法</li><li>短作业优先调度算法</li><li>优先级调度算法</li><li>时间片轮转调度算法</li><li>高响应比优先调度算法（响应比 = （等待时间+需要服务时间）/需要服务时间）</li><li>多级队列调度算法</li><li>多级反馈队列调度算法</li></ul><h2 id="进程调度策略的基本设计指标"><a href="#进程调度策略的基本设计指标" class="headerlink" title="进程调度策略的基本设计指标"></a>进程调度策略的基本设计指标</h2><ol><li>CPU利用率 。</li><li>系统吞吐率，即单位时间内CPU完成的作业的数量。</li><li>响应时间。</li><li>周转时间。是指作业从提交到完成的时间间隔。从每个作业的角度看，完成每个作业的时间也是很关键 。<ul><li>平均周转时间 </li><li>带权周转时间 </li><li>平均带权周转时间</li></ul></li></ol><h2 id="孤儿进程和僵尸进程"><a href="#孤儿进程和僵尸进程" class="headerlink" title="孤儿进程和僵尸进程"></a>孤儿进程和僵尸进程</h2><ul><li>孤儿进程：父亲死了 ，子进程被init进程领养。父进程退出，子进程还在运行的这些子进程都是孤儿进程，孤儿进程将会被init进程(1号进程)收养，并由 init进程对他们完成状态收集工作。</li><li>僵尸进程：子进程死了，父进程没有回收子进程的资源（PCB）。进程使用fork创建子进程，如果子进程退出，而父进程没有盗用wait或者 waitpid获取子进程状态信息，那么子进程的进程描述符依然保存在系统中的这些进程为僵尸进程。</li><li>如何回收僵尸进程：<ul><li>kill 父进程，init领养子进程后，自动回收。</li><li>wait和waitpid</li></ul></li></ul><h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><p>​        操作系统中，进程是具有不同的地址空间的，两个进程是不能感知对方的存在的。有时候，需要多个进程来协同完成一些任务。</p><p>​        当多个进程需要对同一个内核资源进行操作时，这些进程便是竞争关系，操作系统必须协调各个进程对资源的占用，进程的互斥是解决进程间竞争关系的方法。进程互斥指若干进程要使用同一共享资源时，任何时刻最多允许一个进程去使用，其他进程要使用该资源的进程必须等待，直到占有资源的进程释放该资源。</p><p>​        当多个进程协同完成一些任务时，不同进程的执行进度不一致，这便产生了进程同步问题。需要操作系统干预，在特定的同步点对所有进程进行同步，这种协作进程之间相互等待对方消息或信号的协调关系称为进程同步，进程互斥本质上也是一种进程同步。</p><p><strong>进程同步方法：</strong></p><ul><li>互斥锁</li><li>读写锁</li><li>条件变量</li><li>记录锁</li><li>信号量</li><li>屏障</li></ul><h2 id="进程API"><a href="#进程API" class="headerlink" title="进程API"></a>进程API</h2><p><strong>fork:</strong></p><ul><li><code>pid_t fork();</code> </li><li>创建一个新的进程。fork函数将运行着的程序分成2个（几乎）完全一样的进程，每个进程都启动一个从代码的同一位置开始执行的线程。子进程使用相同的pc（程序计数器），相同的CPU寄存器，在父进程中使用的相同打开文件。</li><li>返回值：<ul><li>失败 -1。</li><li>成功，两次返回。<ul><li>父进程返回子进程id。</li><li>子进程返回0。</li></ul></li></ul></li><li>父子进程的数据：读时共享，写时复制。</li></ul><p><strong>getpid，getppid：</strong></p><ul><li><code>pid_t getpid();</code>获得进程id。</li><li><code>pid_t getppid()</code>获得父进程id。</li></ul><p><strong>wait:</strong></p><ul><li><p>回收子进程，知道子进程死亡原因。</p></li><li><p>作用：</p><ul><li>阻塞等待。</li><li>回收子进程资源。</li><li>查看死亡原因。</li></ul></li><li><p><code>pid_t wait(int *wstatus);</code></p><ul><li>没有子进程退出会阻塞。</li><li>wstatus 传出参数，告知死亡原因，具体看百度。</li><li>返回值：<ul><li>成功返回终止的子进程ID。</li><li>失败返回-1。</li></ul></li></ul></li><li><p><code>pid_t waitpid(pid_t pid, int *wstatus, int options);</code></p><ul><li><p>pid </p><p><img src="https://s2.loli.net/2022/03/07/latG6nAJriKVXLy.png" alt="QQ截图20220307111516.png"></p></li><li><p>wstatus 传出参数，告知死亡原因，具体看百度。</p></li><li><p>options</p><ul><li>设置0和wait差不多。</li><li>设置WNOHANG 如果没有子进程退出立刻返回。</li></ul></li><li><p>返回值：</p><ul><li>如果设置了WNOHANG，如果没有子进程退出，返回0。如果有子进程退出，返回PID。</li><li>失败返回-1（没有子进程）。</li></ul></li></ul></li><li><p>通过捕捉SIGCHLD信号也可以在捕获函数中释放子进程。</p></li></ul><h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><p><strong>守护进程：</strong>守护进程(daemon)是一类在后台运行的特殊进程，用于执行特定的系统任务。很多守护进程在系统引导的时候启动，并且一直运行直到系统关闭。另一些只在需要的时候才启动，完成任务后就自动结束。</p><p><strong>会话：</strong>进程组的更高一级，多个进程组对应一个会话。创建会话时，只能组员创建，不能组长创建。</p><p><strong>进程组：</strong>多个进程在同一个组，第一个进程默认是进程组组长。</p><p><strong>创建会话步骤：</strong>创建子进程，杀死父进程，子进程自当会长。</p><p><strong>守护进程步骤：</strong></p><ul><li><font color=red>创建子进程fork</font></li><li><font color=red>父进程退出</font></li><li><font color=red>子进程当会长setid</font></li><li>切换工作目录$HOME</li><li>设置掩码  umask</li><li>关闭文件描述符0，1，2，为了避免浪费资源</li><li><font color=red>执行核心逻辑</font></li><li>退出</li></ul><p><strong>扩展：</strong><br>通过nohub指令也可以达到守护进程创建的效果。</p><p><code>nohub ./a.out &gt; 1.log &amp;</code></p><ul><li>nohub指令会让cmd收不到SIGHUB信号</li><li>&amp;代表后台运行。</li></ul><hr><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>​        轻量级的进程，一个进程可以有多个线程，默认情况下一个进程只有一个线程。线程是最小的执行单位，进程是最小的系统资源分配单位。在linux里内核实现都是通过clone函数实现的。</p><ul><li>线程是进程划分的任务，是一个进程内可调度的实体，是CPU调度的基本单位，用于保存程序的实时性，实现进程内部的并发。</li><li>线城市操作系统可识别的最小执行和调度单位。每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。</li><li>每个线程完成不同的任务，但是属于同一个进程的不同线程之间共享同一地址空间（也就是同样的动态内存，映射文件，目标代码等等），打开的文件队列和其他内核资源。</li></ul><h2 id="为什么需要线程"><a href="#为什么需要线程" class="headerlink" title="为什么需要线程"></a>为什么需要线程</h2><p><strong>线程产生原因：</strong>进程可以使多个程序能并发执行，以提高资源的利用率和系统的吞吐量；但是其具有一些缺点：</p><ul><li>进程在同一时刻只能做一个任务，很多时候不能充分利用CPU资源。</li><li>进程在执行过程中如果发生阻塞，整个进程就会挂起，即使进程中其他任务不依赖于等待的资源，进程仍会被阻塞。</li></ul><p>引入线程就是为了解决以上进程的不足，线程具有如下优点：</p><ul><li>从资源上讲，开辟一个线程所需要的资源远小于一个进程。</li><li>从切换效率上来讲，运行于一个进程中的多个线程，他们之间使用相同的地址空间，而且线程间彼此切换所需要的时间也远远小于进程间切换所需要的时间（这种时间差异主要由于缓存的大量未命中导致）。</li><li>从通信机制上来讲，线程间方便的通信机制。对不同线程来说，他们具有独立的地址空间，要进行数据的传递只能通过进程间通信的方式进行。线程则不然 ，属于同一个进程的不同线程之间共享同一地址空间，所以一个线程的数据可以被其他线程感知，线程间可以直接读写进程数据段（如全局变量）来进行通信（需要一些同步措施）。</li><li>线程提高程序并发性，充分利用CPU资源。</li></ul><p>Linux下线程缺点：</p><ul><li>调试困难。</li><li>库函数，不稳定。</li><li>对信号支持不好。</li></ul><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>​        操作系统中，属于同一进程的线程之间具有相同的地址空间，线程之间共享数据变得简单高效。遇到竞争的线程同时修改同一数据或者协作的线程设置同步点问题时，需要使用一些线程同步的方法解决这些问题。</p><p><strong>线程同步方法：</strong></p><ul><li><p>互斥锁</p></li><li><p>读写锁</p><ul><li><p>读是共享，写是独占，写的优先级高。</p></li><li><p>读写锁仍然是一把锁，只是有不同的状态：</p><ul><li>未加锁</li><li>读锁</li><li>写锁</li></ul></li><li><p>使用场景：适合读的线程多。</p></li></ul></li><li><p>条件变量</p><ul><li>可以引起阻塞，并非锁 。</li><li>要和互斥量组合使用。</li><li>避免不必要的竞争。</li></ul></li><li><p>信号量</p><ul><li>就是加强版的互斥锁，允许多个线程访问共享资源。</li></ul></li><li><p>自旋锁</p></li><li><p>屏障</p></li></ul><h2 id="线程和进程的区别和联系"><a href="#线程和进程的区别和联系" class="headerlink" title="线程和进程的区别和联系"></a>线程和进程的区别和联系</h2><ul><li>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。</li><li>进程在执行过程中拥有独立的地址空间，而多个线程共享进程的地址空间。（资源分配给进程，同一进程的所有线程共享该进程的所有资源 。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段 ，用来存放所有局部变量和临时变量）。</li><li>进程是资源分配的最小单位，而线程是CPU调度的最小单位。</li><li>通信：由于同一进程中多个线程具有相同的地址空间，使他们之间的同步和通信的实现也变得比较容易，进程间通信IPC通过内核提供的缓冲区进行数据交换，而线程间可以直接读写进程数据段（如全局变量）来进行通信（需要一些同步方法 ，以保证数据的一致性）。</li><li>进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快 ，但是编程调试相对复杂。</li><li>进程间不会相互影响；一个进程内某个线程挂掉将导致整个进程挂掉。</li><li>进程适应于多核、多机分布；线程是用于多核。</li></ul><h2 id="线程API"><a href="#线程API" class="headerlink" title="线程API"></a>线程API</h2><p><strong>pthread_self:</strong></p><ul><li><code>pthread_t pthread_self(void);</code>查看线程id。</li></ul><p><strong>pthread_creat:</strong></p><ul><li><code>int pthread_create(pthread_t *thread, const pthread_attr_t *attr,void *(*start_routine) (void *), void *arg);</code> 创建一个线程。</li><li>thread 线程id，传出参数。</li><li>attr 代表线程的属性。</li><li>第三个参数 ，函数指针，void* func（void*）。</li><li>arg 线程执行函数的参数。</li><li>返回值：<ul><li>成功返回0。</li><li>失败返回errno。</li></ul></li></ul><p><font color=red>注意：Compile and link with -pthread。</font></p><p><strong>pthread_exit:</strong></p><ul><li><code>void pthread_exit(void *retval);</code>退出线程。</li><li>retval 函数传出参数。设NULL。</li></ul><p><strong>线程退出注意事项：</strong></p><ul><li>在线程中使用pthread_exit。</li><li>在线程中使用return（主控线程即主函数return代表退出进程）。</li><li>exit代表退出整个进程。</li></ul><p><strong>pthread_join:</strong></p><ul><li><code>int pthread_join(pthread_t thread, void **retval);</code>线程回收函数，阻塞等待回收。</li><li>thrad 创建的时候传出的第一个参数，想回收的线程id。</li><li>retval代表传出线程的退出信息。如果是被pthread_cancel杀死的，返回-1。</li></ul><p><strong>pthread_cancel:</strong></p><ul><li><code>int pthread_cancel(pthread_t thread);</code> 杀死线程。</li><li>thrad 创建的时候传出的第一个参数，想杀死的线程id。</li><li>返回值：<ul><li>失败返回errno。</li><li>成功返回0。</li></ul></li></ul><p><strong>strerror：</strong></p><ul><li><code>char *strerror(int errnum);</code>  获得错误码对应的错误信息。</li></ul><p><strong>pthread_detach:</strong></p><ul><li><code>int pthread_detach(pthread_t thread);</code> 线程分离，此时不用pthread_join回收资源。</li></ul><p><strong>pthread_equal:</strong></p><ul><li><code> int pthread_equal(pthread_t t1, pthread_t t2);</code>比较两个线程id是否相等。</li><li>线程id在进程内部唯一。</li></ul><p><strong>pthread_attr进程属性控制函数：</strong></p><ul><li><code> int pthread_attr_init(pthread_attr_t *attr);</code>   初始化线程属性。</li><li><code>int pthread_attr_destroy(pthread_attr_t *attr);</code>销毁线程属性。</li><li><code> int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);</code> 设置属性分离<ul><li>attr 用pthread_attr_init初始化的属性。</li><li>detachstate<ul><li>PTHREAD_CREATE_DETACHED 线程分离。</li><li>PTHREAD_CREATE_JOINABLE   允许回收。  默认是这个状态。</li></ul></li></ul></li></ul><p><strong>pthread_mutex互斥量函数：</strong></p><ul><li><code>int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);</code><ul><li>restrict 约束该块内存区域对应的数据，只能通过后面的变量进行访问和修改。</li><li>mutex 互斥量– 锁。</li><li>attr 互斥量的属性，一般传NULL。</li><li><code>pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;</code>或者用这个进行mutex初始化，不用上述函数。</li></ul></li><li><code>int pthread_mutex_lock(pthread_mutex_t *mutex);</code> 给共享资源加锁。<ul><li>mutex 是pthread_mutex_init初始化的锁。rugu</li><li>如果当前未锁，成功加锁。如果已经加锁，阻塞等待。</li></ul></li><li><code>int pthread_mutex_trylock(pthread_mutex_t *mutex);</code> 尝试加锁。<ul><li>mutex 是pthread_mutex_init初始化的锁。</li><li>如果当前未锁，成功加锁返回0，失败设置errno。</li></ul></li><li><code> int pthread_mutex_unlock(pthread_mutex_t *mutex);</code> 解锁。</li><li><code>int pthread_mutex_destroy(pthread_mutex_t *mutex);</code> 摧毁锁。<ul><li>mutex 是pthread_mutex_init初始化的锁。</li></ul></li></ul><p><em><strong>互斥量只是建议锁</strong></em></p><p><strong>pthread_rwlock读写锁函数 ：</strong></p><ul><li><p><code>int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock,const pthread_rwlockattr_t *restrict attr)</code>初始化锁</p><ul><li><code>pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER;</code>同上</li></ul></li><li><p><code> int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);</code>销毁锁</p></li><li><p><code> int pthread_rwlock_rdlock(pthread_rwlock_twr *rwlock);</code>加读锁</p></li><li><p><code> int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);</code>加写锁</p></li><li><p><code> int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);</code>释放锁</p></li></ul><p><strong>pthrad_cond条件变量函数：</strong></p><ul><li><p><code>int pthread_cond_timedwait(pthread_cond_t *restrict cond,pthread_mutex_t *restrict mutex,const struct timespec *restrict abstime);</code> 超时等待。 </p><ul><li><p>```c++<br>struct timespec {</p><pre><code>           time_t tv_sec;      /* Seconds */           long   tv_nsec;     /* Nanoseconds [0 .. 999999999] */       &#125;;</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - abstime 写 time（NULL）+秒数。 </span><br><span class="line"></span><br><span class="line">- `int pthread_cond_wait(pthread_cond_t *restrict cond,pthread_mutex_t *restrict mutex);`条件变量阻塞等待。</span><br><span class="line"></span><br><span class="line">  - 先释放锁mutex。</span><br><span class="line">  - 阻塞在cond条件变量上。</span><br><span class="line"></span><br><span class="line">- `int pthread_cond_init(pthread_cond_t *restrict cond,const pthread_condattr_t *restrict attr);`初始化条件变量。</span><br><span class="line"></span><br><span class="line">  - `pthread_cond_t cond = PTHREAD_COND_INITIALIZER;`    </span><br><span class="line"></span><br><span class="line">- `int pthread_cond_destroy(pthread_cond_t *cond);`销毁条件变量。</span><br><span class="line"></span><br><span class="line">- `int pthread_cond_signal(pthread_cond_t *cond);`唤醒至少一个阻塞在条件变量cond上的线程。</span><br><span class="line"></span><br><span class="line">- `int pthread_cond_broadcast(pthread_cond_t *cond);`唤醒所有阻塞在条件变量cond上的线程。</span><br><span class="line"></span><br><span class="line">**信号量函数：**</span><br><span class="line"></span><br><span class="line">- `int sem_init(sem_t *sem, int pshared, unsigned int value);` 初始化信号量</span><br><span class="line">  - sem定义的信号量，传出参数。</span><br><span class="line">  - pshared  </span><br><span class="line">    - 0代表线程信号量。</span><br><span class="line">    - 非0代表进程信号量。</span><br><span class="line">  - value 定义信号量个数。</span><br><span class="line">- `int sem_destroy(sem_t *sem);`摧毁信号量。</span><br><span class="line">- `int sem_wait(sem_t *sem);`申请信号量</span><br><span class="line">  - 成功value--。</span><br><span class="line">  - 当信号量为0阻塞。</span><br><span class="line">- ` int sem_post(sem_t *sem);`释放信号量 。</span><br><span class="line">  - value++。</span><br><span class="line"></span><br><span class="line">## 线程共享资源和非共享资源</span><br><span class="line"></span><br><span class="line">### 共享资源</span><br><span class="line"></span><br><span class="line">1. 文件描述符表</span><br><span class="line">2. 每种信号的处理方式</span><br><span class="line">3. 当前工作目录</span><br><span class="line">4. 用户ID和组ID</span><br><span class="line">5. 内存地址空间</span><br><span class="line"></span><br><span class="line">### 非共享资源</span><br><span class="line"></span><br><span class="line">1. 线程id</span><br><span class="line">2. 处理器现场和栈指针（内核栈）</span><br><span class="line">3. 独立的栈空间（用户空间栈）</span><br><span class="line">4. errno变量</span><br><span class="line">5. 信号屏蔽字</span><br><span class="line">6. 调度优先级</span><br><span class="line"></span><br><span class="line">## 多线程模型</span><br><span class="line"></span><br><span class="line">- 多对一模型：将多个用户级线程映射到同一个内核级线程上。该模型下，线程在用户空间进行管理，效率较高。缺点就是一个线程阻塞，整个进程内所有线程都会阻塞，几乎没有系统继续使用这个模型。</span><br><span class="line">- 一对一模型：将内核线程与用户线程一一对应。优点是一个线程阻塞时，不会影响到其他线程的执行。该模型具有更好的并发性。缺点是内核线程数量一般有上线，会限制用户线程的数量，更多的内核线程数目也给线程切换带来额外的负担。Linux和Windows操作系统都是使用一对一模型。</span><br><span class="line">- 多对多模型：将多个用户级线程映射到多个内核级线程上，结合了多对一模型和一对一模型的特点。</span><br><span class="line"></span><br><span class="line">## 进程同步和线程同步的区别</span><br><span class="line"></span><br><span class="line">​进程之间地址空间不同，不能感知对方的存在，同步时需要将锁放在多进程共享的空间。而线程之间共享同一地址空间，同步时把锁放在所属的同一进程空间即可。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 线程池</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 信号</span><br><span class="line"></span><br><span class="line">## 什么是信号</span><br><span class="line"></span><br><span class="line">​一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件。Linux系统上支持的30多种不同类型的信号。每种 信号类型都对应于某种系统事件。底层的硬件异常是由内核异常处理程序处理的，正常情况下，对用户进程而言不可见。信号提供一种机制，通知用户进程发生了这些异常。信号也叫软件产生的中断，有可能会有延迟。</span><br><span class="line"></span><br><span class="line">1. 发送信号：内核通过更新目的进程上下文中的某个状态，发送一个信号到目的进程。发送信号的原因：</span><br><span class="line">   - 内核检测到一个系统事件，比如零错误或者子进程终止。</span><br><span class="line">   - 一个进程调用了kill函数，显式要求内核发送一个信号给目的进程。一个进程可以发送信号给他自己。</span><br><span class="line">2. 接收信号：当目的进程被内核强迫以某种方式对信号的发送作出反应时，它就接收了信号。进程可以忽略、终止或者通过执行一个称为信号处理程序（signal handler）的用户层函数捕获这个信号。</span><br><span class="line"></span><br><span class="line">**特点：**简单，不能带大量信息，满足特定条件发生。</span><br><span class="line"></span><br><span class="line">**信号的机制：**进程B发送给进程A，内核产生信号，内核处理。</span><br><span class="line"></span><br><span class="line">**信号产生：**</span><br><span class="line"></span><br><span class="line">- 按键产生 crtl+c crtl+z  crtl+\。</span><br><span class="line">- 调用函数  kill  raise   abort。</span><br><span class="line">- 定时器  alarm， setitimer。</span><br><span class="line">- 命令产生  kill。</span><br><span class="line">- 硬件异常  段错误，浮点型错误，总线错误，SIGPIPE。</span><br><span class="line"></span><br><span class="line">**信号状态：**</span><br><span class="line"></span><br><span class="line">- 产生。</span><br><span class="line">- 递答  信号到达并且处理完。</span><br><span class="line">- 未决  信号被阻塞。</span><br><span class="line"></span><br><span class="line">**信号默认处理方式：**</span><br><span class="line"></span><br><span class="line">- 忽略。</span><br><span class="line">- 执行默认动作。</span><br><span class="line">- 捕获。</span><br><span class="line"></span><br><span class="line">**信号四要素：**</span><br><span class="line"></span><br><span class="line">- 编号</span><br><span class="line">- 事件</span><br><span class="line">- 名称</span><br><span class="line">- 默认处理动作：忽略、终止、终止+core、暂停、继续。</span><br><span class="line"></span><br><span class="line">**信号集：**</span><br><span class="line"></span><br><span class="line">![信号集](https://s3.bmp.ovh/imgs/2022/03/311eea32a3ddcab1.png)</span><br><span class="line"></span><br><span class="line">**信号捕捉特性：**</span><br><span class="line"></span><br><span class="line">- 进程正常运行时，默认PCB中有一个信号屏蔽字，假定为⭐，它决定了进程自动屏蔽那些信号。当注册了某个信号捕捉函数 ，捕捉到该信号后，要调用该函数，该函数有可能执行很长时间，在这期间所屏蔽的信号不由⭐指定，而是用sa_mask指定。调用完信号处理函数在恢复为⭐。</span><br><span class="line">- \*\*\*信号捕捉函数执行期间，\*\*\*信号自动被屏蔽。</span><br><span class="line">- 阻塞的常规信号不支持排队，产生多次只记录一次。（后32个实时信号支持排队）</span><br><span class="line"></span><br><span class="line">**内核实现信号捕捉过程：**</span><br><span class="line"></span><br><span class="line">![1](https://img2018.cnblogs.com/blog/1241434/201908/1241434-20190811095430459-2130640271.png)</span><br><span class="line"></span><br><span class="line">## 信号API</span><br><span class="line"></span><br><span class="line">### 系统API产生信号</span><br><span class="line"></span><br><span class="line">**kill:**</span><br><span class="line"></span><br><span class="line">- `int kill(pid_t pid, int sig);`</span><br><span class="line">- pid:</span><br><span class="line">  - \&gt;0，要发送进程ID。</span><br><span class="line">  - =0，代表当前调用进程组内所有进程。</span><br><span class="line">  - =-1，代表有权限发送的所有进程。</span><br><span class="line">  - &lt;0，代表-pid对应的组内所有进程。</span><br><span class="line">- sig：对应的信号。</span><br><span class="line"></span><br><span class="line">**raise和abort:**</span><br><span class="line"></span><br><span class="line">- `int raise(int sig);`</span><br><span class="line">- sig：对应的信号。给自己发。</span><br><span class="line">- `void abort(void);`</span><br><span class="line">- 直接给自己发个异常信号。</span><br><span class="line"></span><br><span class="line">### 时钟信号</span><br><span class="line"></span><br><span class="line">**alarm：**</span><br><span class="line"></span><br><span class="line">- `unsigned int alarm(unsigned int seconds);`</span><br><span class="line">- 定时给自己发SIGALRM信号，也会使进程终止。</span><br><span class="line">- 返回值：上次闹钟剩余的秒数。</span><br><span class="line">- 如果传入参数为0，代表取消闹钟。</span><br><span class="line"></span><br><span class="line">**setitimer：**</span><br><span class="line"></span><br><span class="line">- ` int getitimer(int which, struct itimerval *curr_value);`</span><br><span class="line"></span><br><span class="line">- `int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value);`</span><br><span class="line"></span><br><span class="line">  - ```c++</span><br><span class="line">    struct itimerval &#123;</span><br><span class="line">        struct timeval it_interval; /* Interval for periodic timer 周期性时间设置*/</span><br><span class="line">        struct timeval it_value;    /* Time until next expiration 第一次闹钟时间*/</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    struct timeval &#123;</span><br><span class="line">        time_t      tv_sec;         /* seconds 秒*/</span><br><span class="line">        suseconds_t tv_usec;        /* microseconds 微秒*/</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></li><li><p>which</p><ul><li>ITIMER_REAL  自然定时法，发送SIGALRM信号，</li><li>ITIMER_VIRTUAL 计算进程执行时间，发送SIGVTALRM信号。</li><li>ITIMER_PROF  进程执行时间+调度时间，发送SIGPROF信号。</li></ul></li><li><p>new_value 要设置的闹钟时间。</p></li><li><p>old_value  传出原闹钟时间。</p></li></ul></li></ul><h3 id="信号集处理函数"><a href="#信号集处理函数" class="headerlink" title="信号集处理函数"></a>信号集处理函数</h3><ul><li><p>```c++<br>// 清空信号集<br>int sigemptyset(sigset_t *set);</p><p>// 填充信号集<br>int sigfillset(sigset_t *set);</p><p>// 添加某个信号到信号集<br>int sigaddset(sigset_t *set, int signum);</p><p>// 从集合中删除某个信号<br>int sigdelset(sigset_t *set, int signum);</p><p>// 是否为集合中的成员，是return 1 否return 0<br>int sigismember(const sigset_t *set, int signum);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**sigprocmask：**</span><br><span class="line"></span><br><span class="line">- `int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);`设置阻塞或者解除阻塞信号集。</span><br><span class="line">- how</span><br><span class="line">  - SIG_BLOCK  设置阻塞。</span><br><span class="line">  - SIG_UNBLOCK  解除阻塞。</span><br><span class="line">  - SIG_SETMASK  设置set为新的阻塞信号集。</span><br><span class="line">- set        传入的信号集。</span><br><span class="line">- oldset  传出旧的信号集。</span><br><span class="line"></span><br><span class="line">**sigpending:**</span><br><span class="line"></span><br><span class="line">- `int sigpending(sigset_t *set);`获取当前的未决信号集。</span><br><span class="line">- set 传出参数，当前的未决信号集。</span><br><span class="line"></span><br><span class="line">### 信号捕捉</span><br><span class="line"></span><br><span class="line">**signal：**</span><br><span class="line"></span><br><span class="line">- ```c++</span><br><span class="line">  typedef void (*sighandler_t)(int); </span><br><span class="line">  </span><br><span class="line">  sighandler_t signal(int signum, sighandler_t handler); // 定义一个handler函数来进行捕捉到信号后执行什么操作，signum为信号。</span><br></pre></td></tr></table></figure></li><li><p>捕捉信号并进行相关处理。</p></li></ul><p><strong>sigaction：</strong></p><ul><li><p><code>int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);</code>注册捕捉函数 。</p></li><li><p>signum 捕捉的信号。</p></li><li><p>act 传入的动作</p><ul><li><pre><code class="c++">struct sigaction &#123;    void     (*sa_handler)(int);      // 函数指针，捕捉后的动作    void     (*sa_sigaction)(int, siginfo_t *, void *);    sigset_t   sa_mask;                // 执行捕捉函数期间，临时屏蔽的信号集    int        sa_flags;            // 一般填0使用第一个函数指针，填SA_SIGINFO用第二个    void     (*sa_restorer)(void);  // 无效&#125;;</code></pre></li></ul></li><li><p>oldact 原动作，传出参数，恢复现场。</p></li></ul><h2 id="如何编写正确且安全的信号处理函数"><a href="#如何编写正确且安全的信号处理函数" class="headerlink" title="如何编写正确且安全的信号处理函数"></a>如何编写正确且安全的信号处理函数</h2><ol><li><p>处理程序要尽可能简单。 避免麻烦的最好方法是保持处理程序尽可能小和简单。例如，处理程序可 能只是简单地设置全局标志并立即返回；所有与接收信号相关的处理都由主程序执行，它周期性地 检查(并重置)这个标志。 </p></li><li><p>在处理程序中只调用异步信号安全的函数。 所谓异步信号安全的函数(或简称安全的函数)能够被信 号处理程序安全地调用，原因有二：要么它是可重入的(例如只访问局部变量），要么它不能被信号 处理程序中断。 </p></li><li><p>保存和恢复errno。 许多Linux 异步信号安全的函数都会在出错返回时设置errno在处理程序中调用 这样的函数可能会干扰主程序中其他依赖于分。解决方法是在进人处理程序时把errno 保存在一个 局部变量中，在处理程序返回前恢复它。注意，只有在处理程序要返回时才有此必要。如果处理程 序调用_exit终止该进程，那么就不需要这样做了。 </p></li><li><p>阻塞所有的信号，保护对共享全局数据结构的访问。 如果处理程序和主程序或其他处理程序共享一 个全局数据结构，那么在访问(读或者写)该数据结构时，你的处理程序和主程序应该暂时阻塞所有 的信号。这条规则的原因是从主程序访问一个数据结构d 通常需要一系列的指令，如果指令序列被 访问d 的处理程序中断，那么处理程序可能会发现d 的状态不一致，得到不可预知的结果。在访问d 时暂时阻塞信号保证了处理程序不会中断该指令序列。</p></li><li><p>用volatile 声明全局变量。 考虑一个处理程序和一个main 函数，它们共享一个全局变量g 。处理程 序更新g，main 周期性地读g， 对于一个优化编译器而言，main 中g的值看上去从来没有变化过， 因此使用缓存在寄存器中g 的副本来满足对g 的每次引用是很安全的。如果这样，main 函数可能永 远都无法看到处理程序更新过的值。可以用volatile 类型限定符来定义一个变量，告诉编译器不要 缓存这个变量。例如：volatile 限定符强迫编译器毎次在代码中引用g时，都要从内存中读取g的 值。一般来说，和其他所有共享数据结构一样，应该暂时阻塞信号，保护每次对全局变量的访问。 volatile int g; </p></li><li><p>用sig_atomic_t声明标志。在常见的处理程序设计中，处理程序会写全局标志来记录收到了信号。 主程序周期性地读这个标志，响应信号，再清除该标志。对于通过这种方式来共享的标志，C 提供 一种整型数据类型sig_atomic_t对它的读和写保证会是原子的（不可中断的）。 </p></li><li><p>信号的一个与直觉不符的方面是未处理的信号是不排队的。因为 pending 位向量中每种类型的信号 只对应有一位，所以每种类型最多只能有一个未处理的信号。关键思想是如果存在一个未处理的信 号就表明至少有一个信号到达了。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; title=&quot;进程&quot;&gt;&lt;/a&gt;进程&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;​  </summary>
      
    
    
    
    <category term="OS" scheme="http://isgoudan.top/categories/OS/"/>
    
    
    <category term="面经" scheme="http://isgoudan.top/tags/%E9%9D%A2%E7%BB%8F/"/>
    
    <category term="OS" scheme="http://isgoudan.top/tags/OS/"/>
    
    <category term="进程" scheme="http://isgoudan.top/tags/%E8%BF%9B%E7%A8%8B/"/>
    
    <category term="线程" scheme="http://isgoudan.top/tags/%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="信号" scheme="http://isgoudan.top/tags/%E4%BF%A1%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>内存泄露</title>
    <link href="http://isgoudan.top/2022/02/22/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <id>http://isgoudan.top/2022/02/22/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</id>
    <published>2022-02-22T12:06:36.573Z</published>
    <updated>2022-02-23T07:34:48.943Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h1><p>​        内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是<a href="http://baike.baidu.com/view/330120.htm">应用程序</a>分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。</p><h1 id="内存是如何泄露的？"><a href="#内存是如何泄露的？" class="headerlink" title="内存是如何泄露的？"></a>内存是如何泄露的？</h1><ul><li>堆区数据未被释放。</li></ul><h1 id="C-中的内存泄露该如何避免？"><a href="#C-中的内存泄露该如何避免？" class="headerlink" title="C++ 中的内存泄露该如何避免？"></a>C++ 中的内存泄露该如何避免？</h1><ul><li>避免在堆区开辟数据。</li><li>使用智能指针，而不是手动管理内存。</li><li>使用 std::string 来替代 char*。</li><li>善用 RAII（Resource Acquisition Is Initialization）思想：在类的构造函数中分配资源，在类的析构函数中释放资源。</li></ul><h1 id="如果发生了内存泄露，该如何定位问题代码？"><a href="#如果发生了内存泄露，该如何定位问题代码？" class="headerlink" title="如果发生了内存泄露，该如何定位问题代码？"></a>如果发生了内存泄露，该如何定位问题代码？</h1><ul><li>使用工具软件BoundsChecker，BoundsChecker是一个运行时错误检测工具，它主要定位程序运行时期发生的各种错误。</li><li>调试运行DEBUG版程序，运用以下技术：CRT(C run-time libraries)、运行时函数调用堆栈、内存泄漏时提示的内存分配序号(集成开发环境OUTPUT窗口)，综合分析内存泄漏的原因，排除内存泄漏。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;内存泄漏&quot;&gt;&lt;a href=&quot;#内存泄漏&quot; class=&quot;headerlink&quot; title=&quot;内存泄漏&quot;&gt;&lt;/a&gt;内存泄漏&lt;/h1&gt;&lt;p&gt;​        内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="面经" scheme="http://isgoudan.top/tags/%E9%9D%A2%E7%BB%8F/"/>
    
    <category term="内存" scheme="http://isgoudan.top/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>文件读写</title>
    <link href="http://isgoudan.top/2022/02/22/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/"/>
    <id>http://isgoudan.top/2022/02/22/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/</id>
    <published>2022-02-22T07:00:58.804Z</published>
    <updated>2022-02-22T07:17:31.528Z</updated>
    
    <content type="html"><![CDATA[<h1 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h1><ul><li>头文件<code>#include&lt;fstream&gt;</code></li></ul><h2 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// 以输出方式打开文件</span></span><br><span class="line">    <span class="comment">//  ofstream ofs(&quot;./test.txt&quot;, ios::out | ios::trunc);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 也可以后期指定打开方式</span></span><br><span class="line">    ofstream ofs;</span><br><span class="line">    ofs.<span class="built_in">open</span>(<span class="string">&quot;./test.txt&quot;</span>, ios::out | ios::trunc);</span><br><span class="line">    <span class="keyword">if</span>(!ofs.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;open fail&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ofs&lt;&lt;<span class="string">&quot;goudan&quot;</span>&lt;&lt;endl;</span><br><span class="line">    ofs&lt;&lt;<span class="string">&quot;11&quot;</span>&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// 以输出方式打开文件</span></span><br><span class="line">    <span class="comment">//  ifstream ifs(&quot;./test.txt&quot;, ios::in);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 也可以后期指定打开方式</span></span><br><span class="line">    ifstream ifs;</span><br><span class="line">    ifs.<span class="built_in">open</span>(<span class="string">&quot;./test.txt&quot;</span>, ios::out | ios::trunc);</span><br><span class="line">    <span class="keyword">if</span>(!ifs.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;open fail&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第一种方式</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span>(ifs&gt;&gt;buf) &#123; <span class="comment">// 按行读取</span></span><br><span class="line">cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第二种方式</span></span><br><span class="line">    <span class="keyword">char</span> buf2[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span>(ifs.<span class="built_in">eof</span>()) &#123;<span class="comment">// eof读到文件尾</span></span><br><span class="line">ifs.<span class="built_in">getline</span>(buf2, <span class="built_in"><span class="keyword">sizeof</span></span>(buf2));</span><br><span class="line">        cout &lt;&lt; buf2 &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第三种方式，不推荐，按单个字符读取</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">while</span>(c = ifs.<span class="built_in">get</span>() != EOF) &#123; <span class="comment">// EOF文件尾</span></span><br><span class="line">        cout &lt;&lt; c;</span><br><span class="line">    &#125;</span><br><span class="line">    ifs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;读写文件&quot;&gt;&lt;a href=&quot;#读写文件&quot; class=&quot;headerlink&quot; title=&quot;读写文件&quot;&gt;&lt;/a&gt;读写文件&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;头文件&lt;code&gt;#include&amp;lt;fstream&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 i</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="文件操作" scheme="http://isgoudan.top/tags/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>输入输出流</title>
    <link href="http://isgoudan.top/2022/02/22/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/"/>
    <id>http://isgoudan.top/2022/02/22/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/</id>
    <published>2022-02-22T06:44:12.954Z</published>
    <updated>2022-03-11T08:11:39.314Z</updated>
    
    <content type="html"><![CDATA[<h1 id="标准输入流"><a href="#标准输入流" class="headerlink" title="标准输入流"></a>标准输入流</h1><ul><li><code>cin.get(一个参数)</code>缓冲区中读取一个字符。</li><li><code> cin.get(两个参数)</code>读取字符串，不读换行符。</li><li><code>cin.getline()</code>读取字符串，读取换行符并扔掉。</li><li><code>cin.ignore(N)</code>忽略N个字符。</li><li><code>cin.peek()</code>偷窥，偷看一个字符然后放回缓冲区 。</li><li><code>cin.putback(c)</code>把字符c放回缓冲区。</li><li><code>cin.fail()</code>看标志位，0正常，1不正常。</li><li><code>cin.clear()</code>重置标志位。</li><li><code>cib.sync()</code>清空缓冲区。</li></ul><h1 id="标准输出流"><a href="#标准输出流" class="headerlink" title="标准输出流"></a>标准输出流</h1><ul><li><code>cout.flush</code>刷新缓冲区，Linux有效。</li><li><code>cout.put()</code> 向缓冲区写字符。</li><li><code>cout.write()</code>从缓冲区写num个字节到当前输出流中。</li></ul><p><img src="https://s2.loli.net/2022/02/22/H1IZo4N5h6X7Dji.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;标准输入流&quot;&gt;&lt;a href=&quot;#标准输入流&quot; class=&quot;headerlink&quot; title=&quot;标准输入流&quot;&gt;&lt;/a&gt;标准输入流&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cin.get(一个参数)&lt;/code&gt;缓冲区中读取一个字符。&lt;/li&gt;
&lt;li&gt;&lt;code</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="IO" scheme="http://isgoudan.top/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>C++异常</title>
    <link href="http://isgoudan.top/2022/02/21/C++%E5%BC%82%E5%B8%B8/"/>
    <id>http://isgoudan.top/2022/02/21/C++%E5%BC%82%E5%B8%B8/</id>
    <published>2022-02-21T06:33:07.439Z</published>
    <updated>2022-02-22T06:44:11.033Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><ul><li>基本思想：将问题检测和问题处理相分离。</li><li>try试图执行try{}中的内容。</li><li>在可能出现异常的地方抛出异常 eg： throw -1； </li><li>try下面catch捕获异常。</li><li>catch(捕获类型)   …代表所有其他类型。</li><li>如果不能处理异常，继续向上抛出  thow；</li><li>如果没有任何处理异常的地方，那么程序调用terminate函数终止程序 。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myDevide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="number">-1</span>;  <span class="comment">// 抛出int异常</span></span><br><span class="line">        <span class="comment">// throw 3.14;  抛出double异常</span></span><br><span class="line">        <span class="comment">// throw &quot;a&quot;;</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="built_in">myDevide</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">int</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;int error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">double</span>) &#123;</span><br><span class="line">        <span class="comment">// throw;  如果加上这个，则异常向上反馈，最后只输出 main double error</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;double error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(...) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;other error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">test01</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">double</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;main double error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h1><h2 id="自己写类"><a href="#自己写类" class="headerlink" title="自己写类"></a>自己写类</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;自定义 error&quot;</span> &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myDevide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">MyException</span>();  <span class="comment">// 匿名对象    </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="built_in">myDevide</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(MyException e) &#123;</span><br><span class="line">e.<span class="built_in">prinError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承系统中自带的"><a href="#继承系统中自带的" class="headerlink" title="继承系统中自带的"></a>继承系统中自带的</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyOutOfRangeException</span> :</span> <span class="keyword">public</span> exception &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyOutOfRangeException</span>(string errorInfo) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_ErrorInfo = errorInfo;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">MyOutOfRangeException</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> cont <span class="keyword">char</span>* <span class="title">what</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_ErrorInfo.<span class="built_in">c_str</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    string m_ErrorInfo;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h1 id="栈解旋"><a href="#栈解旋" class="headerlink" title="栈解旋"></a>栈解旋</h1><ul><li>从try开始到throw抛出异常前，所有栈上的对象都会被释放，这个过程称为栈解旋。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;自定义 error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myDevide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 栈解旋</span></span><br><span class="line">        <span class="comment">// 从try开始到throw抛出异常前，所有栈上的对象都会被释放，这个过程称为栈解旋。</span></span><br><span class="line">        Person p1;</span><br><span class="line">        Person p2;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">MyException</span>();  <span class="comment">// 匿名对象    </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="built_in">myDevide</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(MyException e) &#123;</span><br><span class="line">e.<span class="built_in">prinError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">p1构造</span></span><br><span class="line"><span class="comment">p2构造</span></span><br><span class="line"><span class="comment">p2析构</span></span><br><span class="line"><span class="comment">p1析构</span></span><br><span class="line"><span class="comment">自定义 error</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="异常接口声明"><a href="#异常接口声明" class="headerlink" title="异常接口声明"></a>异常接口声明</h1><ul><li>抛出特定类型异常。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该代码不能在VS里运行，可以在QT和linux运行。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="title">throw</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span>)</span>  </span>&#123;<span class="comment">// throw(int)只能抛出int类型异常 throw()不抛出任何类型异常</span></span><br><span class="line"><span class="keyword">throw</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">int</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;int error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="异常变量的生命周期"><a href="#异常变量的生命周期" class="headerlink" title="异常变量的生命周期"></a>异常变量的生命周期</h1><ul><li>如果<code>catch(MyException e)</code> 会多开销一份数据，调用拷贝构造。</li><li>如果<code>catch(MyException *e)</code>，如果不new会提前释放对象，new需要自己释放delete。</li><li>推荐<code>catch(MyException &amp;e)</code>，只一份数据。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyException</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;MyException moren gouzao&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">MyException</span>(<span class="keyword">const</span> MyException &amp;e) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;MyException kaobei gouzao&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;自定义 error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">MyException</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;MyException xigou&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">MyException</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">doWork</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(MyException &amp;e) &#123; <span class="comment">// MyException e会多开销一份数据</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;catch error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">输出catch(MyException e)情况：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">MyException moren gouzao</span></span><br><span class="line"><span class="comment">MyException kaobei gouzao</span></span><br><span class="line"><span class="comment">catch error</span></span><br><span class="line"><span class="comment">MyException xigou</span></span><br><span class="line"><span class="comment">MyException xigou</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注：编译器会做优化，不会立刻将匿名对象释放掉，所以可以改为 catch(MyException &amp;e)减少开销。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="异常的多态使用"><a href="#异常的多态使用" class="headerlink" title="异常的多态使用"></a>异常的多态使用</h1><ul><li>利用多态实现<code>printError()</code>同一个接口调用。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseException</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">printError</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NullPointException</span> :</span> <span class="keyword">public</span> BaseException  &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt;  <span class="string">&quot;Null Point Error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">NullPointException</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">doWork</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(BaseException &amp;e) &#123;</span><br><span class="line">        e.<span class="built_in">printError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="系统标准异常使用"><a href="#系统标准异常使用" class="headerlink" title="系统标准异常使用"></a>系统标准异常使用</h1><ul><li>头文件<code>#include&lt;stdexcept&gt;</code>。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">if</span>(age &lt; <span class="number">0</span> || age &gt; <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;年龄越界！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span>  </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="number">1000</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(out_of_range &amp;e) &#123;</span><br><span class="line">        cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;  <span class="comment">// 年龄越界！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本思想&quot;&gt;&lt;a href=&quot;#基本思想&quot; class=&quot;headerlink&quot; title=&quot;基本思想&quot;&gt;&lt;/a&gt;基本思想&lt;/h1&gt;&lt;h1 id=&quot;异常&quot;&gt;&lt;a href=&quot;#异常&quot; class=&quot;headerlink&quot; title=&quot;异常&quot;&gt;&lt;/a&gt;异常&lt;/h</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="异常" scheme="http://isgoudan.top/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>C++类型转换</title>
    <link href="http://isgoudan.top/2022/02/20/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>http://isgoudan.top/2022/02/20/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</id>
    <published>2022-02-20T06:18:06.186Z</published>
    <updated>2022-02-21T06:33:04.791Z</updated>
    
    <content type="html"><![CDATA[<h1 id="静态类型转换（static-cast）"><a href="#静态类型转换（static-cast）" class="headerlink" title="静态类型转换（static_cast）"></a>静态类型转换（static_cast）</h1><ul><li><p>写法<code>static_cast&lt;目标类型&gt;(原始对象)</code>。</p></li><li><p>可以进行基础类型转换。</p></li><li><p>父与子的class可以转换。</p></li><li><p>没有父子关系的class不可以转换。</p></li></ul><h1 id="动态类型转换（dynamic-cast）"><a href="#动态类型转换（dynamic-cast）" class="headerlink" title="动态类型转换（dynamic_cast）"></a>动态类型转换（dynamic_cast）</h1><ul><li><p>写法<code>dynamic_cast&lt;目标类型&gt;(原始对象)</code>。</p></li><li><p>不可以转换基础数据类型。</p></li><li><p>父子间可以转换。</p><ul><li>一般父转子，不可以。</li><li>子转父，可以。</li><li>如果发生多态，都可以。</li></ul></li></ul><h1 id="常量转换（const-cast）"><a href="#常量转换（const-cast）" class="headerlink" title="常量转换（const_cast）"></a>常量转换（const_cast）</h1><ul><li><p>写法<code>const_cast&lt;目标类型&gt;(原始对象)</code>。</p></li><li><p>用来修改类型的const属性。</p><ul><li>常量指针和非常量指针相互转换，并且仍然指向原来对象。</li><li>常量引用和非常量引用相互转换，并且仍然指向原来对象。</li></ul></li></ul><p>​    <font color=red><strong>注意：不能对非指针和非引用的变量使用const_cast操作符去移除他的const。</strong></font></p><h1 id="重新解释转换（reinterpret-cast）"><a href="#重新解释转换（reinterpret-cast）" class="headerlink" title="重新解释转换（reinterpret_cast）"></a>重新解释转换（reinterpret_cast）</h1><ul><li><p>写法<code>reinterpret_cast&lt;目标类型&gt;(原始对象)</code>。</p></li><li><p>什么都可以转，最不安全，不推荐。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;静态类型转换（static-cast）&quot;&gt;&lt;a href=&quot;#静态类型转换（static-cast）&quot; class=&quot;headerlink&quot; title=&quot;静态类型转换（static_cast）&quot;&gt;&lt;/a&gt;静态类型转换（static_cast）&lt;/h1&gt;&lt;ul&gt;
</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="类型转换" scheme="http://isgoudan.top/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>C++模板</title>
    <link href="http://isgoudan.top/2022/02/18/C++%E6%A8%A1%E6%9D%BF/"/>
    <id>http://isgoudan.top/2022/02/18/C++%E6%A8%A1%E6%9D%BF/</id>
    <published>2022-02-18T06:45:18.207Z</published>
    <updated>2022-02-27T08:24:59.278Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h1><p>​        函数模板实际上是建立一个通用函数，其函数类型和形参类型不具体制定用一个虚拟的类型来代表，这个通用函数就是函数模板。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型参数化，泛型编程</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span>  <span class="comment">// 告诉编译器，T是一个通用类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap</span><span class="params">(T &amp;a, T &amp;b)</span> </span>&#123;</span><br><span class="line">    T tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// typename和class二者没啥区别,等价</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 自动类型推导</span></span><br><span class="line">    <span class="built_in">mySwap</span>(a, b);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 显式指定类型</span></span><br><span class="line">    mySwap&lt;<span class="keyword">int</span>&gt;(a, b);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 模板必须指定出T才可以使用。</span></span><br><span class="line">    <span class="built_in">func</span>();  <span class="comment">// 报错</span></span><br><span class="line">    func&lt;<span class="keyword">int</span>&gt;(); <span class="comment">// 正常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数模板和普通函数区别以及调用规则"><a href="#函数模板和普通函数区别以及调用规则" class="headerlink" title="函数模板和普通函数区别以及调用规则"></a>函数模板和普通函数区别以及调用规则</h1><p><strong>区别:</strong></p><ul><li>函数模板不能进行隐式类型转换，普通函数可以。</li></ul><p><strong>调用规则：</strong></p><ul><li>c++编译器优先考虑普通函数。</li><li>可以通过空模板实参列表的语法限定编译器只能通过模板匹配。</li><li>函数模板可以向普通函数一样被重载。</li><li>如果函数模板可以产生一个更好的匹配，优先使用函数模板。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt; </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPlus</span><span class="params">(T &amp;a, T &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPlus01</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">myPlus</span>(a, c); <span class="comment">// 报错，不能执行</span></span><br><span class="line">    <span class="built_in">myPlus2</span>(a, c); <span class="comment">// 可以执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数和函数模板的调用规则</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt; </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(T &amp;a, T &amp;b)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;函数模板print&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt; </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(T &amp;a, T &amp;b, T &amp;c)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;重载函数模板print&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;普通函数print&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果出现重载，优先使用普通函数调用，如果普通函数只声明没有实现，会出现错误</span></span><br><span class="line"><span class="built_in">myPrint</span>(a, b); <span class="comment">// 普通函数print</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果想强制使用模板，可以使用空参数列表</span></span><br><span class="line">    myPrint&lt;&gt;(a, b);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 函数模板可以发生重载</span></span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">30</span>;</span><br><span class="line">    <span class="built_in">myPrint</span>(a, b, c);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果函数模板可以产生更好的匹配，优先使用函数模板</span></span><br><span class="line">    <span class="keyword">char</span> d = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">    <span class="keyword">char</span> e = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line"><span class="built_in">myPrint</span>(d, e); <span class="comment">// 调用函数模板</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="模板机制"><a href="#模板机制" class="headerlink" title="模板机制"></a>模板机制</h1><ul><li>模板不是万能的，不能适用所有的数据类型。</li><li>函数模板通过具体类型产生不同的函数。</li><li>编译器对函数模板进行<strong>两次</strong>编译，在声明地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译（替换后代码称为模板函数）。</li></ul><h1 id="模板局限性及解决"><a href="#模板局限性及解决" class="headerlink" title="模板局限性及解决"></a>模板局限性及解决</h1><ul><li>模板不能解决所有的类型。</li><li>如果出现不能解决的类型，可以通过第三代具体化进行解决。</li><li>语法<code>template &lt;&gt; 返回值 函数名&lt;具体类型&gt;(参数)&#123;&#125;</code>       返回值和函数名必须和模板一致。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="keyword">int</span> age) : <span class="built_in">mName</span>(name), <span class="built_in">mAge</span>(age)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    string mName;</span><br><span class="line">    <span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCompare</span><span class="params">(T &amp;a, T &amp;b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a == b) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过第三代具体化自定义数据类型解决问题</span></span><br><span class="line"><span class="comment">// 如果具体化能够优先匹配，那么选择具体化</span></span><br><span class="line"><span class="comment">// 语法template &lt;&gt; 返回值 函数名&lt;具体类型&gt;(参数)      返回值和函数名必须和模板一致</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">bool</span> myCompare&lt;Person&gt;(Person &amp;a, Person &amp;b) &#123;</span><br><span class="line"><span class="keyword">if</span>(a.mAge == b.mAge) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;jerry&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="built_in">myCompare</span>(p1, p2);  <span class="comment">// 如果没具体化自定义实现会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h1><ul><li>写法：<code>template&lt;class T, ...&gt;</code> 紧跟着类。</li><li>相比于函数模板，类模板可以有默认类型参数。</li><li>函数模板可以进行自动类型推导，类模板不可以。</li><li>成员函数一开始不会创建，在运行时才会创建。</li></ul><p><strong>类模板做函数的参数的三种方式：</strong></p><ul><li>显式指定类型</li><li>xxxxxxxxxx #include<stdexcept>​class Person {public:    Person(int age) {        if(age &lt; 0 || age &gt; 200) {            throw out_of_range(“年龄越界！”);        }    }        int m_Age;};​void test01()  {    try {        Person p(1000);    }    catch(out_of_range &amp;e) {        cout &lt;&lt; e.what() &lt;&lt; endl;  // 年龄越界！    }}c++</li><li>整体模板化</li></ul><p><strong>查看类型名称的方式：</strong><code>typeid(T1).name</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">NameType</span>, <span class="keyword">class</span> <span class="title">AgeType</span> =</span> <span class="keyword">int</span>&gt;  <span class="comment">// 类模板可以有默认类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(NameType name, Agetype age) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;age:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    NameType m_Name;</span><br><span class="line">    AgeType m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 类模板不支持自动类型推导</span></span><br><span class="line">    <span class="comment">// Person p(&quot;goudan&quot;, 100);   会出错</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">Person&lt;string, <span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;goudan&quot;</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传参方式</span></span><br><span class="line"><span class="comment">// 1.指定传入类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork1</span><span class="params">(Person&lt;string, <span class="keyword">int</span>&gt; &amp;p)</span> </span>&#123;</span><br><span class="line">    p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.参数模板化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T1, class T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork2</span><span class="params">(Person&lt;T1, T2&gt; &amp;p)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 如何查看类型</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(T1).name &lt;&lt; endl;</span><br><span class="line">    p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.整体模板化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork3</span><span class="params">(T &amp;p)</span> </span>&#123;</span><br><span class="line">p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person&lt;string, <span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;goudan&quot;</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="built_in">doWork1</span>(p);</span><br><span class="line">    <span class="built_in">doWork2</span>(p);</span><br><span class="line">    <span class="built_in">doWork3</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类模板碰到继承的问题"><a href="#类模板碰到继承的问题" class="headerlink" title="类模板碰到继承的问题"></a>类模板碰到继承的问题</h1><ul><li>基类如果是模板类，必须让子类告诉编译器基类中的T是什么类型。否则无法分配内存，编译不通过。</li><li>利用参数列表<code>class Child : public Base&lt;int&gt;</code> </li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// child继承base必须告诉base中T的类型，否则无法分配内存</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Base&lt;<span class="keyword">int</span>&gt; &#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// child2 也是模板类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child2</span> :</span> <span class="keyword">public</span> Base&lt;T2&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T1 m_B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Child2&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt; c2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>类模板类外实现成员函数：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">NameType</span>, <span class="keyword">class</span> <span class="title">AgeType</span>&gt;</span>  <span class="comment">// 类模板可以有默认类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(NameType name, Agetype age); </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    NameType m_Name;</span><br><span class="line">    AgeType m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">NameType</span>, <span class="keyword">class</span> <span class="title">AgeType</span>&gt;</span></span><br><span class="line">Person&lt;NameType, AgeType&gt;::<span class="built_in">Person</span>(NameType name, Agetype age) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">NameType</span>, <span class="keyword">class</span> <span class="title">AgeType</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> Person&lt;NameType, AgeType&gt;::<span class="built_in">showPerson</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color=red><strong>注意：类模板不要用分文件编写，如果用正常的分文件编写会出现问题，因为类模板成员函数一开始不会创建，在运行时才会创建，导致包含.h头文件，不会创建函数实现，无法解析外部命令，所以在检查#include“Person.h”不会有问题，但是到链接阶段会链接不到成员函数，可以改成#include“Person.cpp”（但是一般不这么做，一般解决方案为：把实现和声明放在一个文件下，改名为hpp文件，hpp一般为模板）</strong></font></p><h1 id="类模板碰到友元函数"><a href="#类模板碰到友元函数" class="headerlink" title="类模板碰到友元函数"></a>类模板碰到友元函数</h1><p><strong>友元函数类内实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">printPerson</span><span class="params">(Person&lt;T1, T2&gt; &amp;p)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; p.m_Name &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(T1 name, T2 age) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;age:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 m_Name;</span><br><span class="line">    T2 m_Age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>友元函数类外实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 让编译器看到printPErson,否则编译器看不到他的声明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 让编译器看到Person类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span><span class="class"><span class="keyword">class</span> <span class="title">Person</span>;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span><span class="function"><span class="keyword">void</span> <span class="title">printPerson</span><span class="params">(Person&lt;T1, T2&gt; &amp;p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="comment">// 友元函数类外实现，利用空参数列表&lt;&gt;告诉编译器这是模板函数声明，否则是普通函数声明</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> printPerson&lt;&gt;(Person&lt;T1, T2&gt; &amp;p);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(T1 name, T2 age) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;age:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 m_Name;</span><br><span class="line">    T2 m_Age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T1, class T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPerson</span><span class="params">(Person&lt;T1, T2&gt; &amp;p)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; p.m_Name &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;函数模板&quot;&gt;&lt;a href=&quot;#函数模板&quot; class=&quot;headerlink&quot; title=&quot;函数模板&quot;&gt;&lt;/a&gt;函数模板&lt;/h1&gt;&lt;p&gt;​        函数模板实际上是建立一个通用函数，其函数类型和形参类型不具体制定用一个虚拟的类型来代表，这个通用函数就是函</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="模板" scheme="http://isgoudan.top/tags/%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>C++多态</title>
    <link href="http://isgoudan.top/2022/01/17/C++%E5%A4%9A%E6%80%81/"/>
    <id>http://isgoudan.top/2022/01/17/C++%E5%A4%9A%E6%80%81/</id>
    <published>2022-01-17T07:33:27.666Z</published>
    <updated>2022-03-30T03:15:19.690Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><ul><li><p>C++支持编译时多态（静态多态）和运行时多态（动态多态）。重载–静态多态。虚函数和继承–动态多态。</p></li><li><p>静态多态和动态多态的区别就是函数地址是早绑定（静态连编，编译阶段绑定好地址）还是晚绑定（动态联编，运行时绑定好地址）。</p></li><li><p>什么叫多态？</p><ul><li>父类的引用或指针指向子类对象。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;   <span class="comment">// 改为 virtual void speak()</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;animal speak&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cat</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;  <span class="comment">// 子类中的 virtual 可写可不写</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;cat speak&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数func里， speak函数的地址早就绑定好了，在编译阶段就确定了地址</span></span><br><span class="line"><span class="comment">// 如果像调用cat的speak，不能提前绑定好函数地址，所以需要在运行的时候再去确定函数地址</span></span><br><span class="line"><span class="comment">// 动态联编写法：把speak（）在父类声明为虚函数，就发生了多态</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Animal &amp;animal)</span> </span>&#123;</span><br><span class="line">    animal.<span class="built_in">speak</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Cat cat;</span><br><span class="line">    <span class="built_in">func</span>(cat);  <span class="comment">// animal speak;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="多态内部原理"><a href="#多态内部原理" class="headerlink" title="多态内部原理"></a>多态内部原理</h1><ul><li>Animal 内部结构<ul><li><p>Animal 内部存在一个vfptr（virtual function pointer）虚函数表指针。</p></li><li><p>虚函数表指针指向虚函数表。</p></li><li><p>当Cat中没有写speak函数时，Cat的vfptr指向Animal speak函数，如下图：</p></li><li><p><img src="https://s2.loli.net/2022/01/18/XW46U1CHu3JRas8.png" alt="image.png"></p></li><li><p>当Cat中重写了speak函数后，Cat的vfptr指向自己的cat speak函数（对象创建的时候，调用构造函数，将所有的虚函数指针都指向自己的虚函数表，这个操作我们看不到），如下图：</p></li><li><p><img src="https://s2.loli.net/2022/01/18/u7mxhFrbGjA6kvI.png" alt="image.png"></p></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(Animal) &lt;&lt; endl;  <span class="comment">// 没加virtual时是1，加了以后是4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>深入剖析内部调用</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Animal * animal = <span class="keyword">new</span> Cat;</span><br><span class="line">    <span class="comment">// (*(int *)*(int *)animal) 为函数地址</span></span><br><span class="line">    ((<span class="built_in"><span class="keyword">void</span></span>(*)()) (*(<span class="keyword">int</span> *)*(<span class="keyword">int</span> *)animal))();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h1><ul><li>如果父类有纯虚函数，子类继承父类，子类必须将其实现，否则子类也是一个抽象类。</li><li>如果父类有纯虚函数，那么父类不能实例化对象。</li><li>如果类有了纯虚函数，通常称为抽象类。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;   <span class="comment">// 虚函数</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;animal speak&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 纯虚函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h1><ul><li>虚析构解决问题：是为了delete基类指针指向派生类时防止子类的数据不会被释放造成内存泄露。</li><li>纯虚析构：<ul><li>纯虚析构，需要声明，还需要实现，类内声明，类外实现。</li><li>如果类中出现纯虚析构，那么这个类也算抽象类。</li><li>抽象类不能实例化对象。</li></ul></li><li>虚析构和纯虚析构区别：纯虚析构的类不能实例化对象。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Animal speak&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 普通析构 不会调用子类的析构，所以可能导致释放不干净</span></span><br><span class="line">    <span class="comment">// 利用虚析构解决该问题</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Animal xigou&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 纯虚析构</span></span><br><span class="line">    <span class="comment">// 纯虚析构，需要声明，还需要实现，类内声明，类外实现</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal::~<span class="built_in">Animal</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Animal chunxu&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cat</span>(<span class="keyword">const</span> <span class="keyword">char</span> * name) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;mName = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(name) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;name, name);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Cat speak&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">Cat</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Cat xigou&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;mName != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;mName;</span><br><span class="line">            <span class="keyword">this</span>-&gt;mName = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>* mName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Animal * cat = <span class="keyword">new</span> <span class="built_in">Cat</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    animal-&gt;<span class="built_in">speak</span>();   <span class="comment">// Cat speak</span></span><br><span class="line">    <span class="keyword">delete</span> animal;  <span class="comment">// 父类析构函数没加virtual：Animal xigou</span></span><br><span class="line">    <span class="comment">// 父类改成虚析构后： Cat xigou</span></span><br><span class="line">    <span class="comment">//   Animal xigou</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="为什么静态成员函数不能是虚函数"><a href="#为什么静态成员函数不能是虚函数" class="headerlink" title="为什么静态成员函数不能是虚函数"></a>为什么静态成员函数不能是虚函数</h1><ul><li>静态成员函数不属于类中的任何一个对象和实例，属于类共有的函数，因此不能通过this指针访问，因为this指针指向的是每一个对象和实例，而虚函数的调用恰恰需要this指针。虚函数的类实例是通过this指针调用vptr指针，指向虚函数表，通过虚函数表找到需要调用的虚函数地址。this-&gt;vptr-&gt;vtabel-&gt;virtual 函数。</li></ul><h1 id="为什么析构函数一般写成虚函数"><a href="#为什么析构函数一般写成虚函数" class="headerlink" title="为什么析构函数一般写成虚函数"></a>为什么析构函数一般写成虚函数</h1><ul><li>析构函数定义成虚函数是为了防止内存泄漏，因为当父类指针或引用指向或绑定子类对象时，如果未将基类的析构函数定义成虚函数，会调用基类的析构函数，那么只能将基类的成员所占空间释放掉，子类中特有的会无法释放内存空间导致内存泄漏。</li></ul><h1 id="为什么构造函数一般不写为虚函数"><a href="#为什么构造函数一般不写为虚函数" class="headerlink" title="为什么构造函数一般不写为虚函数"></a>为什么构造函数一般不写为虚函数</h1><ul><li>构造函数是在实例化对象的时候进行调用，而虚函数指针是在实例化对象后才产生，而虚函数调用需要通过虚函数指针指向虚函数表从而得到虚函数地址来调用，如果声明成虚函数，在构造的时候由于并没有实例化对象，从而没有虚函数指针从而不能调用构造函数实例化对象。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;多态&quot;&gt;&lt;a href=&quot;#多态&quot; class=&quot;headerlink&quot; title=&quot;多态&quot;&gt;&lt;/a&gt;多态&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;C++支持编译时多态（静态多态）和运行时多态（动态多态）。重载–静态多态。虚函数和继承–动态多态。&lt;/p&gt;
&lt;/li&gt;
&lt;</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="多态" scheme="http://isgoudan.top/tags/%E5%A4%9A%E6%80%81/"/>
    
    <category term="抽象类" scheme="http://isgoudan.top/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    
    <category term="纯虚函数" scheme="http://isgoudan.top/tags/%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
    <category term="虚函数" scheme="http://isgoudan.top/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
</feed>
