<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>is_Goudan’s Blog</title>
  
  
  <link href="http://isgoudan.top/atom.xml" rel="self"/>
  
  <link href="http://isgoudan.top/"/>
  <updated>2022-03-17T06:13:24.053Z</updated>
  <id>http://isgoudan.top/</id>
  
  <author>
    <name>Gou Daner</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux网络编程</title>
    <link href="http://isgoudan.top/2022/03/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>http://isgoudan.top/2022/03/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</id>
    <published>2022-03-15T04:26:04.093Z</published>
    <updated>2022-03-17T06:13:24.053Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h1><h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><ul><li>物理层<ul><li>主要解决两台物理机之间的通信，通过二进制比特流的传输来实现，而进程数据表现为电流电压上的强弱，到达目的地再转化为二进制机器码。网卡、集线器在这层工作。</li></ul></li><li>数据链路层 – 数据的传输和错误检测。<ul><li>在不可靠的物理介质上提供可靠传输，接收来自物理层的位流形式的数据并封装成帧，传送到上一层；同样也将上层的数据帧拆为位流形式的数据转发到物理层。这一层在物理层提供的比特流基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路。提供物理地址寻址功能。交换机工作在这一层。</li></ul></li><li><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层 "></a>网络层 </h2></li><li>传输层</li><li>会话层</li><li>表示层</li><li>应用层</li></ul><h1 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>​        数据传输和数据解释的规则。</p><h2 id="以太网帧协议"><a href="#以太网帧协议" class="headerlink" title="以太网帧协议"></a>以太网帧协议</h2><ul><li>ARP协议：根据IP地址获取mac地址 。</li><li>以太网帧协议：根据mac地址，完成数据包传输。</li></ul><h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><ul><li>版本：IPv4、IPv6    – 4位。</li><li>TTL：time to live。设置数据包在路由节点中的跳转上限。每经过一个节点，该值-1，减为0时路由有义务将该数据丢弃。</li><li>源IP：32位。   – 4字节。</li><li>目的IP：32位。  – 4字节。</li></ul><p><strong>IP地址：</strong>可以在网络环境中，唯一标识一台主机。</p><p><strong>端口号：</strong>可以在网络的一台主机上，唯一标识 一个进程。</p><p><strong>IP+端口号：</strong>可以在网络环境中，唯一标识一个进程。</p><h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><ul><li>源端口号：16位。                    2^16 =65536 </li><li>目的端口号：16位。 </li></ul><h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><ul><li>源端口号：16位。                    2^16 =65536 </li><li>目的端口号：16位。 </li><li>32位序号。</li><li>32位确认序号。</li><li>6个标志位。</li><li>16位窗口大小。</li></ul><h2 id="TCP三次握手四次挥手"><a href="#TCP三次握手四次挥手" class="headerlink" title="TCP三次握手四次挥手"></a>TCP三次握手四次挥手</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><img src="https://images2017.cnblogs.com/blog/985821/201708/985821-20170802101806802-1497343688.png" alt="1"></p><ul><li>第一次握手：客户端将标志位SYN置1，随机产生一个值序列号seq=x，并将该数据包发送给服务器，客户端进入syn_sent状态，等待服务器确认。</li></ul><ul><li>第二次握手：服务器收到数据包后由标志位SYN = 1知道客户端请求建立连接，服务器将标志位SYN和ACK置1，确认序号ack=x+1代表之前的SYN报文收到希望收到的下一个数据的第一个字节的序号为x+1，并随机产生自己的初始序列号seq=y，服务器进入syn_rcvd状态。</li></ul><ul><li>第三次握手：客户都安收到确认检查后，如果正确则将标志位ACK为1，确认序号ack=y+1，序号seq为x+1，并将数据包发送给服务端，服务端检查后二者建立连接。</li></ul><h1 id="socket编程"><a href="#socket编程" class="headerlink" title="socket编程"></a>socket编程</h1><ul><li>什么是socket？<ul><li>网络通信的函数接口。</li><li>封装了传输层协议。<ul><li>TCP</li><li>UDP</li></ul></li><li>本质是一个文件描述符在指向一个套接字（该套接字内部由内核借助两个缓冲区实现。）</li></ul></li></ul><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p><strong>inet_pton：</strong></p><ul><li><code>int inet_pton(int af, const char *src, void *dst);</code>本地字节序转网络字节序。</li><li>af: AF_INET、AF_INET6 对应ipv4、ipv6。</li><li>src：传入，本地IP地址字符串。</li><li>dst：传出，转换后的网络ip地址。</li><li>返回值：成功返回1，异常返回0，说明src传入的ip地址无效 。失败返回-1。</li></ul><p><strong>inet_ntop</strong>：</p><ul><li><code>const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);</code>网络字节序转本地字节序。</li><li>af: AF_INET、AF_INET6 对应ipv4、ipv6。</li><li>src：传入，网络IP地址字符串。</li><li>dst：传出，转换后的本地ip地址。</li><li>size：dst大小。</li><li>返回值：成功返回dst。失败返回null。</li></ul><p><strong>socket():</strong></p><ul><li><code>int socket(int domain, int type, int protocol);</code>创建一个套接字</li><li>domain ：AF_INET、AF_INET6、AF_UNIX  对应IPv4、IPv6、本地。</li><li>type：创建套接字的传输协议，SOCK_STREAM、SOCK_DGRAM。</li><li>protocol：说明典型协议，一般传0。</li><li>返回值：成功返回一个新套接字所对应的文件描述符，失败-1，设置errno。</li></ul><p><strong>bind()：</strong></p><ul><li><p><code>int bind(int sockfd, const struct sockaddr *addr,socklen_t addrlen);</code>给socket绑定地址结构（IP+PORT）。</p></li><li><p>sockfd ：传入socket函数返回值。</p></li><li><p>addr：传入参数。</p><ul><li><pre><code class="c++">struct sockaddr_in addr;addr.sin_family = AF_INET;addr.sin_port = htons(8888);arddr.sin_addr.s_addr = htonl(INADDR_ANY); // INADDR_ANY系统自动帮你取当前可用的IP</code></pre></li><li><p>（struct sockaddr*）&amp;addr</p></li></ul></li><li><p>addrlen: sizeof(addr) 地址结构的大小。</p></li><li><p>返回值：成功返回0，失败-1设置errno。</p></li></ul><p><strong>listen()：</strong></p><ul><li><code>int listen(int sockfd, int backlog);</code> 设置同时与服务器建立连接的上限数。（同时进行三次握手的客户端数量）。</li><li>sockfd ：传入socket函数返回值。</li><li>backlog：上限数值。最大128。</li><li>返回值：成功返回0，失败-1设置errno。</li></ul><p><strong>accept():</strong></p><ul><li><code>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</code>阻塞等待客户端建立链接，成功返回一个与客户端成功链接的socket文件描述符。</li><li>sockfd ：传入socket函数返回值。</li><li>addr：传出参数。成功与服务器建立连接的哪个客户端的地址结构（IP+PORT）。</li><li>addrlen: 传入addr的大小，传出客户端addr的实际大小。</li><li>返回值：成功返回一个能与客户端进行数据通信的socket的文件描述符。失败返回-1，errno。</li></ul><p><strong>connect：</strong></p><ul><li><code>int connect(int sockfd, const struct sockaddr *addr,socklen_t addrlen);</code>使用现有的socket与服务器建立连接。</li><li>sockfd ：传入socket函数返回值。</li><li>addr：传入参数。服务器地址结构。</li><li>addrlen：sizeof(addr) 地址结构的大小。</li><li>返回值：成功0，失败-1errno。</li></ul><h2 id="socket模型创建流程图"><a href="#socket模型创建流程图" class="headerlink" title="socket模型创建流程图"></a>socket模型创建流程图</h2><p><img src="https://img-blog.csdnimg.cn/20201005105410703.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDM0Nzgw,size_16,color_FFFFFF,t_70#pic_center" alt="1"></p><p>如果不使用bind绑定客户端的地址结构，系统会自动采用“隐式绑定”。</p><hr><h1 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h1><h2 id="大端存储-Big-Endian"><a href="#大端存储-Big-Endian" class="headerlink" title="大端存储(Big-Endian)"></a>大端存储(Big-Endian)</h2><p>数据的高字节存储在低地址中，数据的低字节存储在高地址中。网络字节序采用大端存储。</p><h2 id="小端存储-Little-Endian"><a href="#小端存储-Little-Endian" class="headerlink" title="小端存储(Little-Endian)"></a>小端存储(Little-Endian)</h2><p>数据的高字节存储在高地址中，数据的低字节存储在低地址中 。主机字节序采用小端存储。</p><p><strong>uint31_t  htonl(uint31_t hostlong)：</strong>本地字节序转网络字节序函数。（转IP）。</p><p><strong>uint16_t  htons(uint16_t hostshort)：</strong>本地字节序转网络字节序函数。（转port）。</p><p><strong>uint31_t ntohl(uint31_t netlong)：</strong>网络字节序转本地字节序函数。（IP）</p><p><strong>uint16_t ntohl(uint16_t netlong)：</strong>网络字节序转本地字节序函数。（port）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;网络模型&quot;&gt;&lt;a href=&quot;#网络模型&quot; class=&quot;headerlink&quot; title=&quot;网络模型&quot;&gt;&lt;/a&gt;网络模型&lt;/h1&gt;&lt;h2 id=&quot;OSI七层模型&quot;&gt;&lt;a href=&quot;#OSI七层模型&quot; class=&quot;headerlink&quot; title=&quot;OSI</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://isgoudan.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://isgoudan.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>死锁</title>
    <link href="http://isgoudan.top/2022/03/14/%E6%AD%BB%E9%94%81/"/>
    <id>http://isgoudan.top/2022/03/14/%E6%AD%BB%E9%94%81/</id>
    <published>2022-03-14T02:55:22.760Z</published>
    <updated>2022-03-14T04:32:26.739Z</updated>
    
    <content type="html"><![CDATA[<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><ul><li>锁了又锁，自己加了一次锁后，又锁一次。</li><li>交叉锁</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;死锁&quot;&gt;&lt;a href=&quot;#死锁&quot; class=&quot;headerlink&quot; title=&quot;死锁&quot;&gt;&lt;/a&gt;死锁&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;锁了又锁，自己加了一次锁后，又锁一次。&lt;/li&gt;
&lt;li&gt;交叉锁&lt;/li&gt;
&lt;/ul&gt;
</summary>
      
    
    
    
    <category term="OS" scheme="http://isgoudan.top/categories/OS/"/>
    
    
    <category term="OS" scheme="http://isgoudan.top/tags/OS/"/>
    
    <category term="死锁" scheme="http://isgoudan.top/tags/%E6%AD%BB%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>OS小知识点</title>
    <link href="http://isgoudan.top/2022/03/04/OS%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://isgoudan.top/2022/03/04/OS%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2022-03-04T05:30:27.536Z</published>
    <updated>2022-03-14T08:30:45.531Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MMU（内存管理单元）"><a href="#MMU（内存管理单元）" class="headerlink" title="MMU（内存管理单元）"></a>MMU（内存管理单元）</h1><p><img src="https://s2.loli.net/2022/03/04/1L35G4UghYlkuc8.png" alt="QQ截图20220304133224.png"></p><p><img src="https://s2.loli.net/2022/03/04/Pg6hLpMdvDy9Bzu.png" alt="MMU.png"></p><p>MMU作用：</p><ul><li>虚拟内存与物理内存映射。</li><li>设置修改内存访问级别。</li></ul><h1 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h1><p>​        操作系统是管理计算机硬件和软件资源的计算机程序，提供一个计算机用户与计算机硬件系统之间的接口。</p><p>​        向上对用户程序提供接口，向下接管硬件资源。</p><p>​        操作系统本质也是一个软件，作为最接近硬件的系统软件，负责处理器管理、存储器管理、设备管理、文件管理和提供用户接口。</p><h1 id="操作系统有哪些分类"><a href="#操作系统有哪些分类" class="headerlink" title="操作系统有哪些分类"></a>操作系统有哪些分类</h1><ul><li>批处理操作系统</li><li>分时操作系统</li><li>实时操作系统</li><li>通用操作系统：兼顾批操作和分时功能，如Windows，Linux，MacOS等。</li></ul><h1 id="内核态和用户态"><a href="#内核态和用户态" class="headerlink" title="内核态和用户态"></a>内核态和用户态</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>​        为了避免操作系统和关键数据被用户程序破坏，将处理器执行状态分为内核态和用户态。</p><ul><li>内核态是操作系统管理程序执行时所处的状态，能够执行包含特权指令在内的一切指令，能够访问系统内所有的存储空间。</li><li>用户态是用户程序执行时处理器所处的状态，不能执行特权指令，只能访问用户地址空间。</li><li>用户程序运行在用户态，操作系统内核运行在内核态。</li></ul><h2 id="如何转换"><a href="#如何转换" class="headerlink" title="如何转换"></a>如何转换</h2><p>​        处理器从用户态切换到内核态的方法有三种：系统调用、异常和外部中断。</p><ul><li>系统调用是操作系统的最小功能单位，是操作系统提供的用户接口，系统调用本身是一种软中断。</li><li>异常，也叫内中断，是由错误引起，如文件损坏、缺页故障等。</li><li>外部中断，是通过两根信号线来通知处理器外设的状态变化，是硬中断。</li></ul><h1 id="并发和并行的区别"><a href="#并发和并行的区别" class="headerlink" title="并发和并行的区别"></a>并发和并行的区别</h1><ul><li>并发：指宏观上看起来两个程序在同时运行，比如单核CPU的多任务，但是微观上两个程序指令是交织进行，在单个周期内只运行一个指令。这种并发并不能提高计算机性能，只能提高效率（降低某个进程的响应时间）。</li><li>并行：</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MMU（内存管理单元）&quot;&gt;&lt;a href=&quot;#MMU（内存管理单元）&quot; class=&quot;headerlink&quot; title=&quot;MMU（内存管理单元）&quot;&gt;&lt;/a&gt;MMU（内存管理单元）&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://s2.loli.net/2022</summary>
      
    
    
    
    <category term="OS" scheme="http://isgoudan.top/categories/OS/"/>
    
    
    <category term="OS" scheme="http://isgoudan.top/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>C++小知识点</title>
    <link href="http://isgoudan.top/2022/02/27/C++%E9%9D%A2%E7%BB%8F%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://isgoudan.top/2022/02/27/C++%E9%9D%A2%E7%BB%8F%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2022-02-27T08:11:40.737Z</published>
    <updated>2022-03-15T08:38:55.299Z</updated>
    
    <content type="html"><![CDATA[<h1 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h1><ul><li>指针所指向的内存空间在程序运行过程中可以改变，而引用所绑定的对象一旦绑定就不能改变（是否可变）。</li><li>指针本身在内存中占有内存空间，引用相当于变量别名，而在内存中不占内存空间（是否占内存）。</li><li>指针可以为空，但是引用必须绑定对象（是否可空）。</li><li>指针可以有多级，但是引用只能一级（是否能多级）。</li></ul><h1 id="sizeof和strlen区别"><a href="#sizeof和strlen区别" class="headerlink" title="sizeof和strlen区别"></a>sizeof和strlen区别</h1><ul><li><p>strlen 是函数，sizeof 是运算符。</p></li><li><p>strlen 测量的是字符的实际长度，以’\0’ 结束（不包含’\0’ ）。而sizeof 测量的是字符的分配大小，如果未分配大小，则遇到’\0’ 结束（包含’\0’ ，也就是strlen测量的长度加1），如果已经分配内存大小，返回的就是分配的内存大小。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[] = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> str1[<span class="number">100</span>] = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"> </span><br><span class="line">cout &lt;&lt; <span class="built_in">strlen</span>(str) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(str) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(str1) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190929145538553.png" alt="img"></p><h1 id="不能声明为虚函数的函数"><a href="#不能声明为虚函数的函数" class="headerlink" title="不能声明为虚函数的函数"></a>不能声明为虚函数的函数</h1><p><strong>1，普通函数（非成员函数）</strong>：定义虚函数的主要目的是为了重写达到多态，所以普通函数声明为虚函数没有意义，因此编译器在编译时就绑定了它。<br><strong>2，静态成员函数</strong>：静态成员函数对于每个类都只有一份代码，所有对象都可以共享这份代码，他不归某一个对象所有，所以它也没有动态绑定的必要。,<br><strong>3，内联成员函数</strong>：内联函数本就是为了减少函数调用的代价，所以在代码中直接展开。但虚函数一定要创建虚函数表，这两者不可能统一。另外，内联函数在编译时被展开，而虚函数在运行时才动态绑定。<br><strong>4，构造函数</strong>：这个原因很简单，主要从语义上考虑。因为构造函数本来是为了初始化对象成员才产生的，然而虚函数的目的是为了在完全不了解细节的情况下也能正确处理对象，两者根本不能“ 好好相处 ”。因为虚函数要对不同类型的对象产生不同的动作，如果将构造函数定义成虚函数，那么对象都没有产生，怎么完成想要的动作？？</p><p><strong>5，友元函数</strong>：当我们把一个函数声明为一个类的友元函数时，它只是一个可以访问类内成员的普通函数，并不是这个类的成员函数，自然也不能在自己的类内将它声明为虚函数。</p><p>注意：友元本身可以是虚函数！！<br>如果一个类的友元函数是另一个类成员函数，那么它在自己的类内可以被声明为虚函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;指针和引用的区别&quot;&gt;&lt;a href=&quot;#指针和引用的区别&quot; class=&quot;headerlink&quot; title=&quot;指针和引用的区别&quot;&gt;&lt;/a&gt;指针和引用的区别&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;指针所指向的内存空间在程序运行过程中可以改变，而引用所绑定的对象一旦绑定就不能改</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>适配器</title>
    <link href="http://isgoudan.top/2022/02/25/%E9%80%82%E9%85%8D%E5%99%A8/"/>
    <id>http://isgoudan.top/2022/02/25/%E9%80%82%E9%85%8D%E5%99%A8/</id>
    <published>2022-02-25T05:40:02.661Z</published>
    <updated>2022-02-25T06:56:44.849Z</updated>
    
    <content type="html"><![CDATA[<h1 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h1><h2 id="函数适配器"><a href="#函数适配器" class="headerlink" title="函数适配器"></a>函数适配器</h2><p><strong>一元转二元：</strong></p><ul><li>bind2nd 绑定第二个参数。</li><li>继承binary_function&lt;参数类型1, 参数类型2, 返回值类型&gt;。</li><li>const修饰operator()。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrint</span>:</span> <span class="keyword">public</span> binary_fuction&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">void</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> start)</span>  <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; num+start &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; a&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    cin&lt;&lt;start;</span><br><span class="line">    for_each(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">MyPront</span>(), start));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="取反适配器"><a href="#取反适配器" class="headerlink" title="取反适配器"></a>取反适配器</h2><p>一元取反：</p><ul><li>not1()。</li><li>继承unary_function&lt;参数类型1,  返回值类型 &gt;。</li><li>const修饰。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreaterFive</span>:</span> <span class="keyword">public</span> unary_function&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt; <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 一元取反</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">not1</span>(<span class="built_in">GreatrerFive</span>()));  <span class="comment">//  找不大于5的 返回0。</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数指针适配器"><a href="#函数指针适配器" class="headerlink" title="函数指针适配器"></a>函数指针适配器</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyPrint03</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; v+ start &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tets03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">ptr_fun</span>(<span class="built_in">MyPrint03</span>()), <span class="number">100</span>)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="成员函数适配器"><a href="#成员函数适配器" class="headerlink" title="成员函数适配器"></a>成员函数适配器</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">int</span> age) : <span class="built_in">mAge</span>(age) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; mAge &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test04</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;Person&gt; p;</span><br><span class="line">    p.<span class="built_in">push_back</span>(<span class="built_in">Person</span>(<span class="number">1</span>));</span><br><span class="line">    p.<span class="built_in">push_back</span>(<span class="built_in">Person</span>(<span class="number">2</span>));</span><br><span class="line">    p.<span class="built_in">push_back</span>(<span class="built_in">Person</span>(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    for_each(p.<span class="built_in">begin</span>(), p.<span class="built_in">end</span>(), <span class="built_in">mem_fun_ref</span>(&amp;Person::showAge));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;适配器&quot;&gt;&lt;a href=&quot;#适配器&quot; class=&quot;headerlink&quot; title=&quot;适配器&quot;&gt;&lt;/a&gt;适配器&lt;/h1&gt;&lt;h2 id=&quot;函数适配器&quot;&gt;&lt;a href=&quot;#函数适配器&quot; class=&quot;headerlink&quot; title=&quot;函数适配器&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="适配器" scheme="http://isgoudan.top/tags/%E9%80%82%E9%85%8D%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>仿函数、谓词和lambda表达式</title>
    <link href="http://isgoudan.top/2022/02/25/%E4%BB%BF%E5%87%BD%E6%95%B0%E3%80%81%E8%B0%93%E8%AF%8D%E5%92%8Clambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://isgoudan.top/2022/02/25/%E4%BB%BF%E5%87%BD%E6%95%B0%E3%80%81%E8%B0%93%E8%AF%8D%E5%92%8Clambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2022-02-25T03:08:04.709Z</published>
    <updated>2022-03-15T01:34:10.359Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数对象（仿函数）"><a href="#函数对象（仿函数）" class="headerlink" title="函数对象（仿函数）"></a>函数对象（仿函数）</h1><p>​        重载函数调用操作符的类，其对象称为函数对象，即其行为类似函数的对象，又称为仿函数。重载了“（）”使其可以向函数一样调用。</p><p><strong>注意 ：</strong></p><ul><li>函数对象（仿函数）是一个类，不是一个函数。</li><li>函数对象（仿函数）重载了“（）”使其可以向函数一样调用。</li></ul><p><strong>分类：</strong></p><ul><li>一元仿函数：一个参数。</li><li>二元仿函数：两个参数。</li></ul><h1 id="内建仿函数"><a href="#内建仿函数" class="headerlink" title="内建仿函数"></a>内建仿函数</h1><ul><li>头文件：<code>#include&lt;functional&gt;</code></li><li>取反仿函数：<code>template&lt;class T&gt; T negate&lt;T&gt;</code></li><li>加法仿函数：<code>template&lt;class T&gt; T plus&lt;T&gt;</code> </li><li>大于仿函数：<code>template&lt;class T&gt; bool greater&lt;T&gt;</code></li><li>小于仿函数：<code>template&lt;class T&gt; bool less&lt;T&gt;</code></li><li>….</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">negate&lt;<span class="keyword">int</span>&gt; n;</span><br><span class="line">cout &lt;&lt; <span class="built_in">n</span>(<span class="number">10</span>) &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    plus&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">plus</span>(<span class="number">1</span>,<span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; a &#123;<span class="number">1</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());  <span class="comment">// 7 7 6 4 3 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h1><p>​        谓词就是一个判断式，是一个返回bool类型的函数，或者也可以是函数对象（仿函数）。一个参数是一元谓词，两个参数是二元谓词。</p><h1 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h1><ul><li>写法：<code>[捕获列表](参数列表) &#123; 函数内容 &#125;</code>。</li><li>捕获列表是lambda所在函数中定义的局部变量的列表。</li><li>捕获作用：若某算法的可调用表达式是一元谓词但是需要多个参数时则可用捕获。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;函数对象（仿函数）&quot;&gt;&lt;a href=&quot;#函数对象（仿函数）&quot; class=&quot;headerlink&quot; title=&quot;函数对象（仿函数）&quot;&gt;&lt;/a&gt;函数对象（仿函数）&lt;/h1&gt;&lt;p&gt;​        重载函数调用操作符的类，其对象称为函数对象，即其行为类似函数的对象</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="仿函数" scheme="http://isgoudan.top/tags/%E4%BB%BF%E5%87%BD%E6%95%B0/"/>
    
    <category term="谓词" scheme="http://isgoudan.top/tags/%E8%B0%93%E8%AF%8D/"/>
    
    <category term="lambda" scheme="http://isgoudan.top/tags/lambda/"/>
    
  </entry>
  
  <entry>
    <title>Linux基础知识点</title>
    <link href="http://isgoudan.top/2022/02/24/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://isgoudan.top/2022/02/24/Linux%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2022-02-24T07:01:28.387Z</published>
    <updated>2022-03-07T07:52:18.444Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><table><thead><tr><th>命令</th><th>执行操作</th></tr></thead><tbody><tr><td>history</td><td>查看历史命令</td></tr><tr><td>ls</td><td>查看文件目录    -l 显示详细信息    -a 显示隐藏目录    -R递归显示子目录信息</td></tr><tr><td>cd</td><td>更改目录</td></tr><tr><td>pwd</td><td>查看当前的工作目录</td></tr><tr><td>mkdir</td><td>创建目录</td></tr><tr><td>tree</td><td>目录成树状显示</td></tr><tr><td>rmdir</td><td>删除目录，只能删非空目录</td></tr><tr><td>which</td><td>显示对应命令所在的路径</td></tr><tr><td>touch</td><td>创建文件，如果不存在创建，如果存在则只更改访问时间</td></tr><tr><td>rm</td><td>删除文件或者目录  -r 递归删除子目录    rm -rf * 强制删除目录下所有内容</td></tr><tr><td>cp</td><td>拷贝文件或者目录</td></tr><tr><td>mv</td><td>移动文件或者目录</td></tr><tr><td>cat</td><td>直接显示文件信息</td></tr><tr><td>more和less</td><td>分屏显示文件信息</td></tr><tr><td>head</td><td>head -n file 显示文件头n行，不加-n默认10行</td></tr><tr><td>tail</td><td>tail -n file 显示文件后n行；tail -f file 查看文件尾部内容，不退出，用于追踪日志</td></tr><tr><td>du</td><td>-h 查看文件占用空间</td></tr><tr><td>ln</td><td>建立硬连接   ln hello hello.hard1   见下图 ；  ln -s hello hello.hard3  建立软连接</td></tr><tr><td>unlink</td><td>删除软硬连接</td></tr><tr><td>chmod</td><td>改变文件权限</td></tr><tr><td>chown</td><td>改变文件所属权限  sudo chown   用户：组  文件名|目录</td></tr><tr><td>find</td><td>find dir [opt] 内容     opt：-name  -type  -size        按名字、类型、大小找文件</td></tr><tr><td>grep</td><td>过滤信息</td></tr><tr><td>xargs</td><td>将前一目录的输出分成小块输入给后面的命令</td></tr><tr><td>zip</td><td>zip -r zipname.zip filename1 filename2 …   压缩文件  -r递归子目录</td></tr><tr><td>unzip</td><td>unzip zipname.zip  解压文件</td></tr><tr><td>tar</td><td>tar zcvf zipname.tar.gz filename1 filename2 …  压缩文件 <br />tar zxvf zipname.tar.gz  解压文件</td></tr><tr><td>rar</td><td>rar a -r rarname（可以无后缀） filename1 filename2 …  压缩文件<br />rar x rarname.rar 解压文件</td></tr><tr><td>ps</td><td>ps aux 查看进程信息<br />ps ajk  也是查看进程信息，可以追溯进程之间的血缘关系</td></tr><tr><td>kill</td><td>给进程发送一个信号<br /> kill -9 pid  杀死进程</td></tr></tbody></table><h1 id="小知识点"><a href="#小知识点" class="headerlink" title="小知识点"></a>小知识点</h1><p><strong>通配符*和？：</strong>* 代表任意多个字符，? 代表任意一个字符。</p><p><strong>相对路径和绝对路径：</strong> 以”/“开头为绝对路径，否则为相对路径。 </p><p><font color=red>linux一切皆文件。</font></p><p><strong>文件权限表示法：</strong></p><p><img src="https://s2.loli.net/2022/02/26/aCGT69pZHrv8cnO.png" alt="image.png"></p><p><strong>硬连接：</strong></p><ul><li>文件指向同一块磁盘块，只要有一个文件内容变了，建立连接的文件也跟着变。</li></ul><p><strong>软连接：</strong></p><ul><li>相当于创建快捷方式。</li></ul><p><img src="https://s2.loli.net/2022/02/26/dSngu69ODZKw2Vp.png" alt="image.png"></p><p><strong>类unix系统目录结构：</strong></p><p><img src="https://s2.loli.net/2022/02/26/NRCgm4r6dMULqFb.png" alt="image.png"></p><p><strong>进程的虚拟地址空间</strong></p><p><img src="https://s2.loli.net/2022/03/03/yKps2PtraMoSBZG.png" alt="QQ截图20220303111420.png"></p><h1 id="GCC流程"><a href="#GCC流程" class="headerlink" title="GCC流程"></a>GCC流程</h1><ul><li><strong>示例代码</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="keyword">int</span> main（<span class="keyword">void</span>） &#123;</span><br><span class="line"><span class="built_in">printf</span>（<span class="string">&quot;hello\n&quot;</span>）;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>预编译过程</strong></li></ul><p>这个过程处理宏定义和include，去除注释，不会对语法进行检查。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E a.c -o a.i</span><br></pre></td></tr></table></figure><ul><li><strong>编译过程</strong></li></ul><p>这个阶段，检查语法，生成汇编代码。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S a.i -o a.s</span><br></pre></td></tr></table></figure><ul><li><strong>汇编过程</strong></li></ul><p>这个阶段，生成目标代码。</p><p>此过程生成ELF格式的目标代码。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c a.s -o a.o</span><br></pre></td></tr></table></figure><ul><li><strong>链接过程</strong></li></ul><p>链接过程。生成可执行代码。链接分为两种，一种是静态链接，另外一种是动态链接。使用静态链接的好处是，依赖的动态链接库较少，对动态链接库的版本不会很敏感，具有较好的兼容性；缺点是生成的程序比较大。使用动态链接的好处是，生成的程序比较小，占用较少的内存。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc a.o -o a</span><br><span class="line">./a</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200607142556997.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDcxODc5NA==,size_16,color_FFFFFF,t_70" alt="image.png"></p><p><strong>动态库和静态库制作流程：</strong><a href="https://blog.csdn.net/weixin_44718794/article/details/106599417">https://blog.csdn.net/weixin_44718794/article/details/106599417</a></p><h1 id="Makefile文件编写"><a href="#Makefile文件编写" class="headerlink" title="Makefile文件编写"></a>Makefile文件编写</h1><ul><li><p>命名规则：makefile  Makefile</p></li><li><p>写法：</p><ul><li>目标：依赖</li><li>Tab键 规则命令</li></ul></li><li><p>Eg（第一版 ）：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">app:main.c add.c sub.c div.c mul.c</span></span><br><span class="line">gcc -o app -I ./<span class="keyword">include</span> main.c add.c sub.c div.c mul.c</span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line"><span class="comment"># make -f makefilename 可以指定具体的makefile文件</span></span><br></pre></td></tr></table></figure><p>如果更改其中一个，所有源码都重新编译。</p><p>Eg（第二版 ）：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># objFlies 定义的目标文件</span></span><br><span class="line">objFiles=main.o add.o sub.o div.o mul.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标文件用法 $（var）</span></span><br><span class="line"><span class="section">app:<span class="variable">$(objFiles)</span></span></span><br><span class="line">gcc -o app -I ./<span class="keyword">include</span> main.o add.o sub.o div.o mul.o</span><br><span class="line"></span><br><span class="line"><span class="section">main.o:main.c</span></span><br><span class="line">gcc -c main.c -I./<span class="keyword">include</span></span><br><span class="line"><span class="section">add.o:add.c</span></span><br><span class="line">gcc -c add.c -I./<span class="keyword">include</span></span><br><span class="line"><span class="section">sub.o:sub.c</span></span><br><span class="line">gcc -c sub.c -I./<span class="keyword">include</span></span><br><span class="line"><span class="section">div.o:div.c</span></span><br><span class="line">gcc -c div.c -I./<span class="keyword">include</span></span><br><span class="line"><span class="section">mul.o:mul.c</span></span><br><span class="line">gcc -c mul.c -I./<span class="keyword">include</span></span><br></pre></td></tr></table></figure><p>makefile隐含规则：默认处理第一个目标。</p><p>Eg（第三版 ）：</p><ul><li>函数：<ul><li>wildcard 进行文件匹配。</li><li>patsubst 内容替换。</li></ul></li><li>makefile变量：<ul><li>$@ 代表目标。</li><li>$^ 代表全部依赖。</li><li>$&lt; 代表第一个依赖。</li><li>$? 代表第一个变化的依赖 。</li></ul></li><li>@在规则前代表不输出该条规则的命令。</li><li>-在规则前代表该条规则报错，仍然继续执行。</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">SecFiles =<span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line"></span><br><span class="line">objFiles=<span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,<span class="variable">$(SrcFiles)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标文件用法 $（var）</span></span><br><span class="line"><span class="section">app:<span class="variable">$(objFiles)</span></span></span><br><span class="line">gcc -o app -I ./<span class="keyword">include</span> <span class="variable">$(objFiles)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># $@,$&lt;只能在规则中出现</span></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">gcc -c <span class="variable">$&lt;</span> -I ./<span class="keyword">include</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义伪目标，防止有歧义</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:clean all</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm *.o</span><br><span class="line">rm app</span><br></pre></td></tr></table></figure></li></ul><h1 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h1><ul><li>启动gdb:<code>gdb app</code>app为对应程序名。</li><li>在gdb启动程序：<ul><li><code>r(un)</code> 启动。</li><li><code>start</code> 启动-停留在 main函数，分步调试。</li><li><code>n(ext)</code> 下一条指令。</li><li><code>s(tep)</code> 下一条指令，可以进入函数内部，库函数不能进。</li><li><code>q(uit)</code> 退出。</li><li><code>b(reak)</code> n 在主函数所在文件 第n行设置断点， <code>b func</code> 在func函数设置断点， <code>b main.cpp:2=10</code> 在某个文件某一行设置断点；<code>b main.cpp:2=10 if i==0</code>设置条件断点。</li><li><code>l(ist)</code> 查看主函数对应文件，<code>list func.cpp:1</code>看func从第一行 。</li><li><code>info b</code> 查看断点。</li><li><code>d(el)  n</code> 删除断点，n对应info b里的第几个 断点。</li><li><code>c(ontinue)</code> 跳到下一断点。</li><li><code>p(rint) context </code>打印context的内容。</li><li><code>ptype x</code>  打印x类型。</li><li><code>set</code> 设置变量值。</li><li><code>display argc</code> 执行任何一个指令argc的值都显示一下。</li><li><code>undisplay n</code>不显示display，n代表display的那个行号，也可以通过info display查看。</li></ul></li><li>gdb追踪core<ul><li>查看core文件大小 ：<code>ulimit -c</code></li><li>设置生成core文件大小：<code>ulimit -c unlimited</code> 设置无限大</li><li>gdb app core<ul><li>where 查看错误在哪。</li></ul></li></ul></li></ul><h1 id="umask"><a href="#umask" class="headerlink" title="umask"></a>umask</h1><ul><li>设置文件没有的权限。</li><li>用户默认创建文件的最高权限为666。</li><li>用户默认创建目录的最高权限为777。</li></ul><h1 id="Linux库函数"><a href="#Linux库函数" class="headerlink" title="Linux库函数"></a>Linux库函数</h1><p><strong>open：</strong></p><ul><li>查看 man 2 open</li><li><code>int open(const char *pathname, int flags);</code></li><li><code>int open(const char *pathname, int flags, mode_t mode);</code><ul><li>pathname 文件名</li><li>flags<ul><li>必选项<ul><li>O_RDONLY  只读。</li><li>O_WRONLY 只写。</li><li>O_RWR         读写。</li></ul></li><li>可选项<ul><li>O_APPEND 追加。</li><li>O_CREAT    创建文件。<ul><li>O_EXCL 与 O_CREAT 如果文件存在报错。</li><li>创建的文件权限是（mode&amp;~umask）。</li></ul></li><li>O_NONBLOCK  非阻塞。</li></ul></li></ul></li></ul></li><li>返回值：返回一个新的文件描述符，返回的是当前最小可用的文件描述符。失败返回-1，设置errno。</li><li>注意：在打开fifo文件时read端会阻塞等待write端open，write端同理，也会阻塞的能带另一端打开。</li></ul><p><strong>close</strong>：</p><ul><li><code>int close(int fd);</code> 关闭文件描述符。</li><li>返回值：成功返回0，失败返回-1。</li></ul><p><strong>read：</strong></p><ul><li><code> ssize_t read(int fd, void *buf, size_t count);</code></li><li>fd          文件描述符</li><li>buf        缓冲区</li><li>count    缓冲区大小</li><li>返回值：<ul><li>失败返回-1，设置errno。</li><li>成功返回读的大小。</li><li>0代表读到文件末尾。</li><li>非阻塞的情况下，read返回-1，但是此时需要判断errno的值。</li></ul></li></ul><p><strong>write：</strong></p><ul><li><code>ssize_t write(int fd, const void *buf, size_t count);</code></li><li>fd          文件描述符</li><li>buf        缓冲区</li><li>count    缓冲区大小</li><li>返回值：失败返回-1，设置errno；成功返回写入的字节数；0代表未写入。 </li></ul><p><strong>lseek:</strong></p><ul><li><p><code>off_t lseek(int fd, off_t offset, int whence);</code></p></li><li><p>fd 文件描述符</p></li><li><p>offset 偏移量 设0</p></li><li><p>whence </p><ul><li>SEEK_SET  文件开始位置    </li><li>SEEK_CUR 当前位置</li><li>SEEK_END 结尾</li></ul></li><li><p>返回值：成功返回当前位置到开始的长度；失败返回-1，设置errno。</p></li><li><p>函数作用：</p><ul><li>移动文件读写位置。</li><li>计算文件大小。</li><li>拓展文件。</li></ul></li></ul><p><strong>阻塞的概念：</strong></p><ul><li>read函数在读设备或者读管道或者读网络的时候。</li></ul><p><strong>fcntl：</strong></p><ul><li><p><code>int fcntl(int fd, int cmd, ... /* arg */ );</code></p></li><li><pre><code class="c++">int fd = open(&quot;/dev/tty&quot;, O_RDWR)// 设置非阻塞int flags = fcntl(fd, F_GETFL);flags |= O_NONBLOCK;fcntl(fd, F_SETFL, flags);</code></pre></li></ul><p><strong>stat:</strong></p><ul><li><p><code>int stat(const char *pathname, struct stat *statbuf);</code>获得文件信息。</p></li><li><p>函数参数</p><ul><li>pathname 文件名。</li><li>statbuf       传出参数。</li></ul></li><li><p>返回值：成功返回0，失败返回-1，设置errno。</p></li><li><p>lstat和stat：stat会穿透到源文件，lstat不会。</p></li></ul><p><strong>access：</strong></p><ul><li>判断文件权限和文件是否存在。具体用法百度。</li></ul><p><strong>truncate：</strong></p><ul><li>截断文件。用法百度。</li></ul><p><strong>link系列函数：</strong></p><ul><li>创建删除软硬连接，读取连接。用法百度。</li></ul><p><strong>rename：</strong></p><ul><li>重命名函数。</li></ul><p><strong>getcwd：</strong></p><ul><li>获取当前工作路径。</li></ul><p><strong>chdir：</strong></p><ul><li>改变进程工作路径。</li></ul><p><strong>mkdir、rmdir、opendir、readdir、closedir：</strong></p><ul><li>创建删除打开读关闭 dir。</li></ul><p><strong>dup2和dup:</strong></p><ul><li>主要用于重定向。</li><li><code>int dup2(int oldfd, int newfd);</code><ul><li>把newfd指向oldfd。</li><li>成功返回newfd，失败返回-1，设置errno。</li></ul></li><li><code>int dup(int oldfd);</code><ul><li>新生成一个fd指向oldfd，新生成的fd是当前可用最小的。</li><li>返回值为新的fd。</li></ul></li></ul><p><strong>execl和execlp：</strong></p><ul><li><code>int execl(const char *path, const char *arg, .../* (char  *) NULL */);</code><ul><li>执行其他程序，需要加路径。</li><li>Eg：<code>execl(&quot;./bin/ls&quot;, &quot;ls&quot;, &quot;-l&quot;, NULL);</code></li></ul></li><li><code>int execlp(const char *file, const char *arg, .../* (char  *) NULL */);</code><ul><li>执行程序，使用当前PATH环境变量，可以不用加路径。</li><li>Eg：<code>execl(&quot;ls&quot;, &quot;ls&quot;, &quot;-l&quot;, NULL);</code></li></ul></li><li>path/file 为要执行的程序。</li><li>arg参数列表<ul><li>列表最后要一个NULL结尾。</li></ul></li><li>返回值：只有失败才返回。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;常用命令&quot;&gt;&lt;a href=&quot;#常用命令&quot; class=&quot;headerlink&quot; title=&quot;常用命令&quot;&gt;&lt;/a&gt;常用命令&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;执行操作&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tb</summary>
      
    
    
    
    <category term="Linux" scheme="http://isgoudan.top/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://isgoudan.top/tags/Linux/"/>
    
    <category term="GCC" scheme="http://isgoudan.top/tags/GCC/"/>
    
    <category term="makefile" scheme="http://isgoudan.top/tags/makefile/"/>
    
  </entry>
  
  <entry>
    <title>C++STL</title>
    <link href="http://isgoudan.top/2022/02/23/STL/"/>
    <id>http://isgoudan.top/2022/02/23/STL/</id>
    <published>2022-02-23T03:17:51.490Z</published>
    <updated>2022-03-15T03:10:59.945Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>​        STL广义上分为：容器（container）、算法（algorithm）、迭代器（iterator）。容器和算法通过迭代器进行无缝连接。</p><p>​        STL细分为六大组件：容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器。</p><ul><li>容器：各种数据结构，如vector、list、deque、set、map等，用来存放数据。从实现角度看，STL容器是一种class template。</li><li>算法：各种常用算法，如sort、find、copy、for_each。从实现角度看，STL算法是一种function template。</li><li>迭代器：扮演了容器和算法之间的调和剂，共5种类型（输入、输出、前向、双向、随机访问）。从实现角度看，迭代器是一种将operator*，operator-&gt;，operator++，operator–等指针相关操作予以重载的class template，所有的STL容器都有自己的专属迭代器。原生指针（native pointer）也是一种迭代器。</li><li>仿函数：行为类似函数，可作为算法的某种策略。从实现角度看，仿函数是一种重载了operator()的class或者class template。</li><li>适配器：一种用来修饰容器或者仿函数迭代器接口的东西。</li><li>空间配置器：负责空间的配置与管理。从实现角度看，配置器是一个实现了动态空间配置、空间管理、空间释放的class template。</li></ul><p>​        STL六大组件的交互关系：容器通过空间配置器取得数据存储空间，算法通过迭代器存储容器中的内容，仿函数可以协助算法完成不同策略得变化，适配器可以修饰仿函数。</p><h1 id="STL优点"><a href="#STL优点" class="headerlink" title="STL优点"></a>STL优点</h1><ul><li>STL为C++一部分，不用额外安装。</li><li>STL一个重要特性是将数据和操作分离，数据由容器类别加以管理，操作则由可定制的算法定义。迭代器在两者之间充当“粘合剂”，以使算法可以和容器交互运作。</li><li>程序员不用考虑STL内部实现，直接使用。</li><li>STL具有高可重用性，高性能，高移植性，跨平台的优点。<ul><li>高可重用性：STL几乎所有代码都采用模板类和模板函实现，相比于传统的函数和类提供了更好的代码重用机会。</li><li>高性能：如map可以高效从大量数据在检索指定记录，因为采用红黑树。</li><li>高移植性：如在项目A使用STL编写模块，可以直接移植到项目B。</li></ul></li></ul><h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h1><ul><li>序列式容器：强调值的顺序，每个元素均有固定位置，除非用插入删除操作改变，如vector、deque、list等。</li><li>关联式容器：非线性的二叉树结构，个元素间没有严格的物理上得顺序关系，也就是说元素在容器中并没有保存元素置入容器时的逻辑顺序。关联式容器一个显著特点：在值中选择一个值作为关键字key，key起到索引的作用，方便查找。如set、multiset、map、multimap等。 </li></ul><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><ul><li>质变算法：运算过程中改变区间内元素内容。如拷贝，替换，删除等。</li><li>非质变算法：运算过程中不改变区间内元素内容。如查找，计数，遍历等。</li></ul><h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>​        提供一种方法，使之能够依序遍历某个容器所含的各个元素，而又无需暴露该容器内部的表示方式。</p><table><thead><tr><th>名称</th><th>功能</th><th>支持操作</th></tr></thead><tbody><tr><td>输入迭代器</td><td>提供对数据的只读访问</td><td>只读，支持++，–，!=</td></tr><tr><td>输出迭代器</td><td>提供对数据的只写访问</td><td>只写，支持++</td></tr><tr><td>前向迭代器</td><td>提供读写操作，并向前推进迭代器</td><td>读写，支持++，==，!=</td></tr><tr><td>双向迭代器</td><td>提供读写操作，并能向前和向后操作</td><td>读写，支持++,–，==，!=</td></tr><tr><td>随机访问迭代器</td><td>提供读写操作，并能以跳跃的方式访问容器的任意数据，功能最强。</td><td>读写，支持++，–，[n]，-n，&lt;，&lt;=，&gt;，&gt;=, ==，!=</td></tr></tbody></table><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><ul><li>s[]访问和s.at()访问区别：[]访问越界会直接挂掉，at则抛出异常。</li><li>string -&gt; const char* :   <code>const char *p = s.c_str();</code> 。</li><li>const char* -&gt; string：<code>string s2(p);</code>。</li><li>C++存在const char*到string的隐式类型转换，不存在从string到const char*的隐式类型转换。</li></ul><h1 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h1><ul><li><p>vector所谓的动态增加大小，并不是在原有空间之后虚接新空间，而是找一块更大空间，将原数据拷贝，然后释放原空间。所以一旦引起空间配置，则原有的迭代器失效。</p></li><li><p>利用swap收缩空间：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;    <span class="comment">// &gt;10000</span></span><br><span class="line">    cout &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// = 10000</span></span><br><span class="line">    </span><br><span class="line">    v.<span class="built_in">resize</span>(<span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;    <span class="comment">// &gt;10000  和之前一样</span></span><br><span class="line">    cout &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// = 3</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 巧用swap</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;(v).<span class="built_in">swap</span>(v);<span class="comment">// v初始化匿名对象，交换两个指针，然后释放掉匿名对象（那个大的就被释放了）</span></span><br><span class="line">    cout &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;    <span class="comment">// = 3  </span></span><br><span class="line">    cout &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// = 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>reserve(int len);</code>容器预留len个元素长度，预留位置不初始化，元素不可访问。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(p != &amp;v[<span class="number">0</span>]) &#123;  <span class="comment">// 查看开辟10万个数据重新开辟多少次空间。</span></span><br><span class="line">            p = &amp;v[<span class="number">0</span>];</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; num &lt;&lt; endl; <span class="comment">// &gt;1,好多次</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 改进：</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">    v1.<span class="built_in">reserve</span>(<span class="number">100000</span>);</span><br><span class="line">    <span class="keyword">int</span> *p1 = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(p1 != &amp;v[<span class="number">0</span>]) &#123;  <span class="comment">// 查看开辟10万个数据重新开辟多少次空间。</span></span><br><span class="line">            p1 = &amp;v[<span class="number">0</span>];</span><br><span class="line">            num1++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; num1 &lt;&lt; endl; <span class="comment">//  = 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>s[]访问和s.at()访问区别：[]访问越界会直接挂掉，at则抛出异常。</p></li></ul><h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><ul><li>没有迭代器，不提供遍历功能。</li></ul><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><ul><li><p>双向循环链表。</p></li><li><p>不支持随机访问。</p></li><li><p>所有不支持随机访问的迭代器，不可以用系统提供的算法，但是这个类内部会提供。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="keyword">int</span>&gt; L&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(L.<span class="built_in">begin</span>(), L.<span class="built_in">end</span>());  <span class="comment">// 报错</span></span><br><span class="line">L.<span class="built_in">sort</span>();</span><br></pre></td></tr></table></figure></li></ul><h1 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h1><h2 id="优先队列使用lambda表达式"><a href="#优先队列使用lambda表达式" class="headerlink" title="优先队列使用lambda表达式"></a>优先队列使用lambda表达式</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> cmp = [&amp;nums1, &amp;nums2](<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp; a, <span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp; b) &#123;</span><br><span class="line">    <span class="keyword">return</span> nums1[a.first] + nums2[a.second] &gt; nums1[b.first] + nums2[b.second];</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, vector&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;, <span class="keyword">decltype</span>(cmp)&gt; <span class="built_in">que</span>(cmp);</span><br></pre></td></tr></table></figure><ul><li>decltype 类型指示符，返回函数的返回值类型。</li><li>在初始化priority_queue时，&lt;&gt;中的三个参数必须都是类型名，而cmp为实例化的对象，所以加decltype进行转换。</li><li>que后加（cmp）原因是priority_queue内部实现的时候是根据&lt;&gt;第三个参数实例化一个对象，也就是需要调用其默认构造函数，但是因为lambda这种特殊的class没有默认构造函数，所以需要调用其拷贝构造函数，priority_queue内部定义了这种实现方式，就是通过que(cmp)传入cmp（lambda对象）来直接进行排序操作。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;p&gt;​        STL广义上分为：容器（container）、算法（algorithm）、迭代器（iterator）。容器</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="STL" scheme="http://isgoudan.top/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>进程、线程和信号</title>
    <link href="http://isgoudan.top/2022/02/22/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/"/>
    <id>http://isgoudan.top/2022/02/22/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/</id>
    <published>2022-02-22T12:09:07.884Z</published>
    <updated>2022-03-15T03:13:23.782Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>​        进程是操作系统中最重要的抽象概念之一，是资源分配的基本单位，是独立运行的基本单位。</p><p>​        进程的经典定义就是一个执行中程序的实例。系统中的每个程序（程序就是编译好的二进制文件）都运行在某个进程的上下文（context）中。上下文是由程序正确运行所需的状态组成。这个状态包括存放在内存中的程序代码和数据，他的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。</p><p>进程一般由以下部分组成：</p><ul><li>进程控制块PCB，是进程存在的唯一标志，包含进程标识符PID、进程当前状态、程序、数据地址、进程优先级、CPU现场保护区（用于进程切换）、占有的资源清单等等。</li><li>程序段。</li><li>数据段。</li></ul><h2 id="进程和程序"><a href="#进程和程序" class="headerlink" title="进程和程序"></a>进程和程序</h2><ul><li>程序是编译好的二进制文件。</li><li>进程是运行着的程序。从程序员角度，进程是运行一系列指令的过程。从操作系统角度，进程是资源分配的基本单位，是独立运行的基本单位。</li><li>区别：<ul><li>程序占用磁盘，不占用系统资源。</li><li>进程占用内存，占用系统资源。</li><li>一个程序可以对应多个进程，一个进程只能对应一个程序。</li><li>程序没有生命周期，进程有。</li></ul></li></ul><h2 id="简述进程间通信方法"><a href="#简述进程间通信方法" class="headerlink" title="简述进程间通信方法"></a>简述进程间通信方法</h2><p>​        每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程A把数据从用户空间拷到内核缓冲区，进程B再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信。</p><p>​        不同进程间的通信本质：进程之间可以看到一份公共资源；而提供这份资源的形式或者提供者不同，造成了通信方式的不同。</p><p>​        进程间通信主要包括管道、系统IPC（包括消息队列、信号量、信号、共享内存等）以及套接字socket。</p><h2 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h2><ul><li>IPC：Inter Process Communication进程间通信，通过内核提供的缓冲区进行数据交换的机制。</li><li>常见通信方式：单工（广播），半双工（对讲机），全双工（打电话）。</li><li>IPC通信方式：<ul><li>pipe             管道–只支持有血缘关系的进程间通信，半双工通信。</li><li>fifo               有名管道–不同进程间也可以通信。</li><li>mmap          文件映射（共享）IO–速度最快。</li><li>本地socket  最稳定。</li><li>信号              携带信息量最小。</li><li>共享内存    </li><li>消息队列</li></ul></li></ul><h2 id="进程的状态与状态转换"><a href="#进程的状态与状态转换" class="headerlink" title="进程的状态与状态转换"></a>进程的状态与状态转换</h2><p>进程在运行时有三种基本状态：就绪态、运行态和阻塞态。（五态模型还有新建态和终止态）。</p><ul><li>运行态：进程占有处理器正在运行的状态。进程已获得CPU，其程序正在执行。在单处理机系统中，只有一个进程处于执行状态；在多处理机系统中，则有多个进程处于执行状态。</li><li>就绪态：进程具备运行条件，等待系统分配处理器以便运行的状态。当进程已分配到除CPU以外的所有必要资源后，只要再获得CPU，便可立即执行，进程这时的状态称为就绪态。在一个系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列。</li><li>阻塞态：又称为等待态或睡眠态，指进程不具备运行条件，正在等待某个时间完成的状态。</li></ul><p>各状态之间的转换：</p><p><img src="https://s2.loli.net/2022/03/09/p9TfiQYyzcDGXF2.png" alt="进程状态转换"></p><ul><li>就绪→执行：处于就绪状态的进程，当进程调度程序为之分配了处理机后，该进程便由就绪状态转变成运行状态。</li><li>执行→就绪：处于运行态程序在执行过程中，因分配给他的一个时间片用完而不得不让出CPU，遇是进程从运行态转变成就绪态。</li><li>执行→阻塞：正在执行的进程因等待某种事件发生而无法继续执行时，便从执行状态变成阻塞态。</li><li>阻塞→就绪：处于阻塞态的进程，若等待的事件已经发生，于是进程由阻塞状态转变为就绪态。</li></ul><h2 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h2><p>​        管道是一种最基本的IPC机制，作用域有血缘关系的进程之间，完成数据传递。调用pipe系统函数即可创建一个管道，有如下特质：</p><ul><li>其本质是一个伪文件（实为一个内核缓冲区）。</li><li>有两个文件描述符引用，一个表示读端，一个表示写端，</li><li>规定数据从管道的写端流入管道，从读端流出。</li></ul><p><strong>管道原理：</strong>管道实为内核使用环形队列机制，借助内核缓冲区实现。</p><p><strong>管道局限性：</strong></p><ul><li>数据自己读不能自己写，如果需要双向通信需要创建多根管道。 </li><li>数据一旦被读走，便不在管道中存在，不可反复读取。</li><li>由于管道采用半双工通信方式，因此数据只能在一个方向流动。</li><li>只能在有公共祖先的进程间使用管道。</li></ul><p><strong>管道函数：</strong></p><ul><li><p><code> int pipe(int pipefd[2]);</code></p><ul><li>pipefd 读写文件描述符，0代表读，1代表写。</li><li>返回值：失败-1，成功0。</li></ul></li><li><p>读管道 ：</p><ul><li>写端 全部关闭 – read读到0，相当于读到文件末尾。</li><li>写端没有全部关闭。<ul><li>有数据  – read读到数据。</li><li>无数据  – read阻塞，fcntl函数可以更改非阻塞。</li></ul></li></ul></li><li><p>写管道：</p><ul><li>读端全部关闭  –  产生一个信号SIGPIPE，程序异常终止。</li><li>读端未全部关闭。<ul><li>管道已满  –  write阻塞。</li><li>管道未满  –  write正常写入。</li></ul></li></ul></li></ul><ul><li><code>long fpathconf(int fd, int name);</code><ul><li>计算管道大小。</li><li>name 设置为  _PC_PIPE_BUF。</li></ul></li></ul><h2 id="FIFO通信"><a href="#FIFO通信" class="headerlink" title="FIFO通信"></a>FIFO通信</h2><p>​        FIFO有名管道，实现无血缘关系进程通信。</p><ul><li>创建一个管道的伪文件。<ul><li>mkfifo myfifo 命令创建。</li><li><code>int mkfifo(const char *pathname, mode_t mode);</code> 函数创建。</li></ul></li><li>内核会针对fifo文件开辟一个缓冲区，操作fifo文件–实际上就是文件读写，可以操作缓冲区，实现进程间通信。</li></ul><h2 id="mmap通信"><a href="#mmap通信" class="headerlink" title="mmap通信"></a>mmap通信</h2><p>​        mmap共享映射区，可以无血缘关系进程通信。</p><ul><li><code>void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);</code><ul><li>创建映射区。</li><li>addr     传NULL。</li><li>length  映射区长度。</li><li>prot：<ul><li>PROT_READ   可读 。</li><li>PROT_WRITE  可写。</li><li>MAP_ANON     可以创建匿名映射，不用再建立一个文件，这时候fd设为-1。这个宏在有些Unix系统没有，匿名映射只能实现有血缘关系的进程通信。</li></ul></li><li>flag：<ul><li>MAP_SHARED 共享的，对内存的修改会影响到源文件。</li><li>MAP_PRIVATE 私有的，修改不反应到磁盘实际文件，是一个copy-on-write（写时复制）的映射方式。</li></ul></li><li>fd  文件描述符。</li><li>offeset  偏移量。</li><li>返回值：<ul><li>成功返回可用的内存首地址。</li><li>失败返回MAP_FAILED。</li></ul></li></ul></li><li><code>int munmap(void *addr, size_t length);</code><ul><li>释放映射区。</li><li>addr 传mmap返回值。</li><li>length mmap创建的长度。</li><li>返回值：<ul><li>失败返回-1。</li><li>成功返回0。</li></ul></li></ul></li></ul><p><img src="https://s2.loli.net/2022/03/08/W9iZmHUJXEIGMRO.png" alt="QQ截图20220308132738.png"></p><h2 id="共享内存通信"><a href="#共享内存通信" class="headerlink" title="共享内存通信"></a>共享内存通信</h2><p>​        共享内存使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。</p><p><strong>特点：</strong></p><ul><li>共享内存是最快的一种IPC，因为进程是直接对内存进行操作来实现通信，避免了数据在用户空间和内核空间来回拷贝。</li><li>因为多个进程可以同时操作，所以需要进行同步处理。</li><li>信号量和共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。</li></ul><h2 id="进程调度的时机"><a href="#进程调度的时机" class="headerlink" title="进程调度的时机"></a>进程调度的时机</h2><ul><li>当前运行的进程运行结束。</li><li>当前运行的进程由于某种原因阻塞。</li><li>执行完系统调用等系统程序后返回用户进程。</li><li>在使用抢占调度的系统中，具有更高优先级的进程就绪时。</li><li>分时系统中，分给当前进程的时间片用完。</li></ul><h2 id="不能进行进程调度的情况"><a href="#不能进行进程调度的情况" class="headerlink" title="不能进行进程调度的情况"></a>不能进行进程调度的情况</h2><ul><li>在中断处理程序执行时。</li><li>在操作系统的内核程序临界区内。</li><li>其他需要完全屏蔽中断的原子操作过程中。</li></ul><h2 id="进程的调度策略"><a href="#进程的调度策略" class="headerlink" title="进程的调度策略"></a>进程的调度策略</h2><ul><li>先到先服务调度算法</li><li>短作业优先调度算法</li><li>优先级调度算法</li><li>时间片轮转调度算法</li><li>高响应比优先调度算法（响应比 = （等待时间+需要服务时间）/需要服务时间）</li><li>多级队列调度算法</li><li>多级反馈队列调度算法</li></ul><h2 id="进程调度策略的基本设计指标"><a href="#进程调度策略的基本设计指标" class="headerlink" title="进程调度策略的基本设计指标"></a>进程调度策略的基本设计指标</h2><ol><li>CPU利用率 。</li><li>系统吞吐率，即单位时间内CPU完成的作业的数量。</li><li>响应时间。</li><li>周转时间。是指作业从提交到完成的时间间隔。从每个作业的角度看，完成每个作业的时间也是很关键 。<ul><li>平均周转时间 </li><li>带权周转时间 </li><li>平均带权周转时间</li></ul></li></ol><h2 id="孤儿进程和僵尸进程"><a href="#孤儿进程和僵尸进程" class="headerlink" title="孤儿进程和僵尸进程"></a>孤儿进程和僵尸进程</h2><ul><li>孤儿进程：父亲死了 ，子进程被init进程领养。父进程退出，子进程还在运行的这些子进程都是孤儿进程，孤儿进程将会被init进程(1号进程)收养，并由 init进程对他们完成状态收集工作。</li><li>僵尸进程：子进程死了，父进程没有回收子进程的资源（PCB）。进程使用fork创建子进程，如果子进程退出，而父进程没有盗用wait或者 waitpid获取子进程状态信息，那么子进程的进程描述符依然保存在系统中的这些进程为僵尸进程。</li><li>如何回收僵尸进程：<ul><li>kill 父进程，init领养子进程后，自动回收。</li><li>wait和waitpid</li></ul></li></ul><h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><p>​        操作系统中，进程是具有不同的地址空间的，两个进程是不能感知对方的存在的。有时候，需要多个进程来协同完成一些任务。</p><p>​        当多个进程需要对同一个内核资源进行操作时，这些进程便是竞争关系，操作系统必须协调各个进程对资源的占用，进程的互斥是解决进程间竞争关系的方法。进程互斥指若干进程要使用同一共享资源时，任何时刻最多允许一个进程去使用，其他进程要使用该资源的进程必须等待，直到占有资源的进程释放该资源。</p><p>​        当多个进程协同完成一些任务时，不同进程的执行进度不一致，这便产生了进程同步问题。需要操作系统干预，在特定的同步点对所有进程进行同步，这种协作进程之间相互等待对方消息或信号的协调关系称为进程同步，进程互斥本质上也是一种进程同步。</p><p><strong>进程同步方法：</strong></p><ul><li>互斥锁</li><li>读写锁</li><li>条件变量</li><li>记录锁</li><li>信号量</li><li>屏障</li></ul><h2 id="进程API"><a href="#进程API" class="headerlink" title="进程API"></a>进程API</h2><p><strong>fork:</strong></p><ul><li><code>pid_t fork();</code> </li><li>创建一个新的进程。fork函数将运行着的程序分成2个（几乎）完全一样的进程，每个进程都启动一个从代码的同一位置开始执行的线程。子进程使用相同的pc（程序计数器），相同的CPU寄存器，在父进程中使用的相同打开文件。</li><li>返回值：<ul><li>失败 -1。</li><li>成功，两次返回。<ul><li>父进程返回子进程id。</li><li>子进程返回0。</li></ul></li></ul></li><li>父子进程的数据：读时共享，写时复制。</li></ul><p><strong>getpid，getppid：</strong></p><ul><li><code>pid_t getpid();</code>获得进程id。</li><li><code>pid_t getppid()</code>获得父进程id。</li></ul><p><strong>wait:</strong></p><ul><li><p>回收子进程，知道子进程死亡原因。</p></li><li><p>作用：</p><ul><li>阻塞等待。</li><li>回收子进程资源。</li><li>查看死亡原因。</li></ul></li><li><p><code>pid_t wait(int *wstatus);</code></p><ul><li>没有子进程退出会阻塞。</li><li>wstatus 传出参数，告知死亡原因，具体看百度。</li><li>返回值：<ul><li>成功返回终止的子进程ID。</li><li>失败返回-1。</li></ul></li></ul></li><li><p><code>pid_t waitpid(pid_t pid, int *wstatus, int options);</code></p><ul><li><p>pid </p><p><img src="https://s2.loli.net/2022/03/07/latG6nAJriKVXLy.png" alt="QQ截图20220307111516.png"></p></li><li><p>wstatus 传出参数，告知死亡原因，具体看百度。</p></li><li><p>options</p><ul><li>设置0和wait差不多。</li><li>设置WNOHANG 如果没有子进程退出立刻返回。</li></ul></li><li><p>返回值：</p><ul><li>如果设置了WNOHANG，如果没有子进程退出，返回0。如果有子进程退出，返回PID。</li><li>失败返回-1（没有子进程）。</li></ul></li></ul></li><li><p>通过捕捉SIGCHLD信号也可以在捕获函数中释放子进程。</p></li></ul><h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2><p><strong>守护进程：</strong>守护进程(daemon)是一类在后台运行的特殊进程，用于执行特定的系统任务。很多守护进程在系统引导的时候启动，并且一直运行直到系统关闭。另一些只在需要的时候才启动，完成任务后就自动结束。</p><p><strong>会话：</strong>进程组的更高一级，多个进程组对应一个会话。创建会话时，只能组员创建，不能组长创建。</p><p><strong>进程组：</strong>多个进程在同一个组，第一个进程默认是进程组组长。</p><p><strong>创建会话步骤：</strong>创建子进程，杀死父进程，子进程自当会长。</p><p><strong>守护进程步骤：</strong></p><ul><li><font color=red>创建子进程fork</font></li><li><font color=red>父进程退出</font></li><li><font color=red>子进程当会长setid</font></li><li>切换工作目录$HOME</li><li>设置掩码  umask</li><li>关闭文件描述符0，1，2，为了避免浪费资源</li><li><font color=red>执行核心逻辑</font></li><li>退出</li></ul><p><strong>扩展：</strong><br>通过nohub指令也可以达到守护进程创建的效果。</p><p><code>nohub ./a.out &gt; 1.log &amp;</code></p><ul><li>nohub指令会让cmd收不到SIGHUB信号</li><li>&amp;代表后台运行。</li></ul><hr><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>​        轻量级的进程，一个进程可以有多个线程，默认情况下一个进程只有一个线程。线程是最小的执行单位，进程是最小的系统资源分配单位。在linux里内核实现都是通过clone函数实现的。</p><ul><li>线程是进程划分的任务，是一个进程内可调度的实体，是CPU调度的基本单位，用于保存程序的实时性，实现进程内部的并发。</li><li>线城市操作系统可识别的最小执行和调度单位。每个线程都独自占用一个虚拟处理器：独自的寄存器组，指令计数器和处理器状态。</li><li>每个线程完成不同的任务，但是属于同一个进程的不同线程之间共享同一地址空间（也就是同样的动态内存，映射文件，目标代码等等），打开的文件队列和其他内核资源。</li></ul><h2 id="为什么需要线程"><a href="#为什么需要线程" class="headerlink" title="为什么需要线程"></a>为什么需要线程</h2><p><strong>线程产生原因：</strong>进程可以使多个程序能并发执行，以提高资源的利用率和系统的吞吐量；但是其 具有一些缺点：</p><ul><li>进程在同一时刻只能做一个任务，很多时候不能充分利用CPU资源。</li><li>进程在执行过程中如果发生阻塞，整个进程就会挂起，即使进程中其他任务不依赖于等待的资源，进程仍会被阻塞。</li></ul><p>引入线程就是为了解决以上进程的不足，线程具有如下优点：</p><ul><li>从资源上讲，开辟一个线程所需要的资源远小于一个进程。</li><li>从切换效率上来讲，运行于一个进程中的多个线程，他们之间使用相同的地址空间，而且线程间彼此切换所需要的时间也远远小于进程间切换所需要的时间（这种时间差异主要由于缓存的大量未命中导致）。</li><li>从通信机制上来讲，线程间方便的通信机制。对不同线程来说，他们具有独立的地址空间，要进行数据的传递只能通过进程间通信的方式进行。线程则不然 ，属于同一个进程的不同线程之间共享同一地址空间，所以一个线程的数据可以被其他线程感知，线程间可以直接读写进程数据段（如全局变量）来进行通信（需要一些同步措施）。</li><li>线程提高程序并发性，充分利用CPU资源。</li></ul><p>Linux下线程缺点：</p><ul><li>调试困难。</li><li>库函数，不稳定。</li><li>对信号支持不好。</li></ul><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>​        操作系统中，属于同一进程的线程之间具有相同的地址空间，线程之间共享数据变得简单高效。遇到竞争的线程同时修改同一数据或者协作的线程设置同步点问题时，需要使用一些线程同步的方法解决这些问题。</p><p><strong>线程同步方法：</strong></p><ul><li><p>互斥锁</p></li><li><p>读写锁</p><ul><li><p>读是共享，写是独占，写的优先级高。</p></li><li><p>读写锁仍然是一把锁，只是有不同的状态：</p><ul><li>未加锁</li><li>读锁</li><li>写锁</li></ul></li><li><p>使用场景：适合读的线程多。</p></li></ul></li><li><p>条件变量</p><ul><li>可以引起阻塞，并非锁 。</li><li>要和互斥量组合使用。</li><li>避免不必要的竞争。</li></ul></li><li><p>信号量</p><ul><li>就是加强版的互斥锁，允许多个线程访问共享资源。</li></ul></li><li><p>自旋锁</p></li><li><p>屏障</p></li></ul><h2 id="线程和进程的区别和联系"><a href="#线程和进程的区别和联系" class="headerlink" title="线程和进程的区别和联系"></a>线程和进程的区别和联系</h2><ul><li>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。</li><li>进程在执行过程中拥有独立的地址空间，而多个线程共享进程的地址空间。（资源分配给进程，同一进程的所有线程共享该进程的所有资源 。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段 ，用来存放所有局部变量和临时变量）。</li><li>进程是资源分配的最小单位，而线程是CPU调度的最小单位。</li><li>通信：由于同一进程中多个线程具有相同的地址空间，使他们之间的同步和通信的实现也变得比较容易，进程间通信IPC通过内核提供的缓冲区进行数据交换，而线程间可以直接读写进程数据段（如全局变量）来进行通信（需要一些同步方法 ，以保证数据的一致性）。</li><li>进程编程调试简单可靠性高，但是创建销毁开销大；线程正相反，开销小，切换速度快 ，但是编程调试相对 复杂。</li><li>进程间不会相互影响；一个进程内某个线程挂掉将导致整个进程挂掉。</li><li>进程适应于多核、多机分布；线程是用于多核。</li></ul><h2 id="线程API"><a href="#线程API" class="headerlink" title="线程API"></a>线程API</h2><p><strong>pthread_self:</strong></p><ul><li><code>pthread_t pthread_self(void);</code>查看线程id。</li></ul><p><strong>pthread_creat:</strong></p><ul><li><code>int pthread_create(pthread_t *thread, const pthread_attr_t *attr,void *(*start_routine) (void *), void *arg);</code> 创建一个线程。</li><li>thread 线程id，传出参数。</li><li>attr 代表线程的属性。</li><li>第三个参数 ，函数指针，void* func（void*）。</li><li>arg 线程执行函数的参数。</li><li>返回值：<ul><li>成功返回0。</li><li>失败返回errno。</li></ul></li></ul><p><font color=red>注意：Compile and link with -pthread。</font></p><p><strong>pthread_exit:</strong></p><ul><li><code>void pthread_exit(void *retval);</code>退出线程。</li><li>retval 函数传出参数。设NULL。</li></ul><p><strong>线程退出注意事项：</strong></p><ul><li>在线程中使用pthread_exit。</li><li>在线程中使用return（主控线程即主函数return代表退出进程）。</li><li>exit代表退出整个进程。</li></ul><p><strong>pthread_join:</strong></p><ul><li><code>int pthread_join(pthread_t thread, void **retval);</code>线程回收函数，阻塞等待回收。</li><li>thrad 创建的时候传出的第一个参数，想回收的线程id。</li><li>retval代表传出线程的退出信息。如果是被pthread_cancel杀死的，返回-1。</li></ul><p><strong>pthread_cancel:</strong></p><ul><li><code>int pthread_cancel(pthread_t thread);</code> 杀死线程。</li><li>thrad 创建的时候传出的第一个参数，想杀死的线程id。</li><li>返回值：<ul><li>失败返回errno。</li><li>成功返回0。</li></ul></li></ul><p><strong>strerror：</strong></p><ul><li><code>char *strerror(int errnum);</code>  获得错误码对应的错误信息。</li></ul><p><strong>pthread_detach:</strong></p><ul><li><code>int pthread_detach(pthread_t thread);</code> 线程分离，此时不用pthread_join回收资源。</li></ul><p><strong>pthread_equal:</strong></p><ul><li><code> int pthread_equal(pthread_t t1, pthread_t t2);</code>比较两个线程id是否相等。</li><li>线程id在进程内部唯一。</li></ul><p><strong>pthread_attr进程属性控制函数：</strong></p><ul><li><code> int pthread_attr_init(pthread_attr_t *attr);</code>   初始化线程属性。</li><li><code>int pthread_attr_destroy(pthread_attr_t *attr);</code>销毁线程属性。</li><li><code> int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);</code> 设置属性分离<ul><li>attr 用pthread_attr_init初始化的属性。</li><li>detachstate<ul><li>PTHREAD_CREATE_DETACHED 线程分离。</li><li>PTHREAD_CREATE_JOINABLE   允许回收。  默认是这个状态。</li></ul></li></ul></li></ul><p><strong>pthread_mutex互斥量函数：</strong></p><ul><li><code>int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);</code><ul><li>restrict 约束该块内存区域对应的数据，只能通过后面的变量进行访问和修改。</li><li>mutex 互斥量– 锁。</li><li>attr 互斥量的属性，一般传NULL。</li><li><code>pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;</code>或者用这个进行mutex初始化，不用上述函数。</li></ul></li><li><code>int pthread_mutex_lock(pthread_mutex_t *mutex);</code> 给共享资源加锁。<ul><li>mutex 是pthread_mutex_init初始化的锁。rugu</li><li>如果当前未锁，成功加锁。如果已经加锁，阻塞等待。</li></ul></li><li><code>int pthread_mutex_trylock(pthread_mutex_t *mutex);</code> 尝试加锁。<ul><li>mutex 是pthread_mutex_init初始化的锁。</li><li>如果当前未锁，成功加锁返回0，失败设置errno。</li></ul></li><li><code> int pthread_mutex_unlock(pthread_mutex_t *mutex);</code> 解锁。</li><li><code>int pthread_mutex_destroy(pthread_mutex_t *mutex);</code> 摧毁锁。<ul><li>mutex 是pthread_mutex_init初始化的锁。</li></ul></li></ul><p><em><strong>互斥量只是建议锁</strong></em></p><p><strong>pthread_rwlock读写锁函数 ：</strong></p><ul><li><p><code>int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock,const pthread_rwlockattr_t *restrict attr)</code>初始化锁</p><ul><li><code>pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER;</code>同上</li></ul></li><li><p><code> int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);</code>销毁锁</p></li><li><p><code> int pthread_rwlock_rdlock(pthread_rwlock_twr *rwlock);</code>加读锁</p></li><li><p><code> int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);</code>加写锁</p></li><li><p><code> int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);</code>释放锁</p></li></ul><p><strong>pthrad_cond条件变量函数：</strong></p><ul><li><p><code>int pthread_cond_timedwait(pthread_cond_t *restrict cond,pthread_mutex_t *restrict mutex,const struct timespec *restrict abstime);</code> 超时等待。 </p><ul><li><p>```c++<br>struct timespec {</p><pre><code>           time_t tv_sec;      /* Seconds */           long   tv_nsec;     /* Nanoseconds [0 .. 999999999] */       &#125;;</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - abstime 写 time（NULL）+秒数。 </span><br><span class="line"></span><br><span class="line">- `int pthread_cond_wait(pthread_cond_t *restrict cond,pthread_mutex_t *restrict mutex);`条件变量阻塞等待。</span><br><span class="line"></span><br><span class="line">  - 先释放锁mutex。</span><br><span class="line">  - 阻塞在cond条件变量上。</span><br><span class="line"></span><br><span class="line">- `int pthread_cond_init(pthread_cond_t *restrict cond,const pthread_condattr_t *restrict attr);`初始化条件变量。</span><br><span class="line"></span><br><span class="line">  - `pthread_cond_t cond = PTHREAD_COND_INITIALIZER;`    </span><br><span class="line"></span><br><span class="line">- `int pthread_cond_destroy(pthread_cond_t *cond);`销毁条件变量。</span><br><span class="line"></span><br><span class="line">- `int pthread_cond_signal(pthread_cond_t *cond);`唤醒至少一个阻塞在条件变量cond上的线程。</span><br><span class="line"></span><br><span class="line">- `int pthread_cond_broadcast(pthread_cond_t *cond);`唤醒所有阻塞在条件变量cond上的线程。</span><br><span class="line"></span><br><span class="line">**信号量函数：**</span><br><span class="line"></span><br><span class="line">- `int sem_init(sem_t *sem, int pshared, unsigned int value);` 初始化信号量</span><br><span class="line">  - sem定义的信号量，传出参数。</span><br><span class="line">  - pshared  </span><br><span class="line">    - 0代表线程信号量。</span><br><span class="line">    - 非0代表进程信号量。</span><br><span class="line">  - value 定义信号量个数。</span><br><span class="line">- `int sem_destroy(sem_t *sem);`摧毁信号量。</span><br><span class="line">- `int sem_wait(sem_t *sem);`申请信号量</span><br><span class="line">  - 成功value--。</span><br><span class="line">  - 当信号量为0阻塞。</span><br><span class="line">- ` int sem_post(sem_t *sem);`释放信号量 。</span><br><span class="line">  - value++。</span><br><span class="line"></span><br><span class="line">## 线程共享资源和非共享资源</span><br><span class="line"></span><br><span class="line">### 共享资源</span><br><span class="line"></span><br><span class="line">1. 文件描述符表</span><br><span class="line">2. 每种信号的处理方式</span><br><span class="line">3. 当前工作目录</span><br><span class="line">4. 用户ID和组ID</span><br><span class="line">5. 内存地址空间</span><br><span class="line"></span><br><span class="line">### 非共享资源</span><br><span class="line"></span><br><span class="line">1. 线程id</span><br><span class="line">2. 处理器现场和栈指针（内核栈）</span><br><span class="line">3. 独立的栈空间（用户空间栈）</span><br><span class="line">4. errno变量</span><br><span class="line">5. 信号屏蔽字</span><br><span class="line">6. 调度优先级</span><br><span class="line"></span><br><span class="line">## 多线程模型</span><br><span class="line"></span><br><span class="line">- 多对一模型：将多个用户级线程映射到同一个内核级线程上。该模型下，线程在用户空间进行管理，效率较高。缺点就是一个线程阻塞，整个进程内所有线程都会阻塞，几乎没有系统继续使用这个模型。</span><br><span class="line">- 一对一模型：将内核线程与用户线程一一对应。优点是一个线程阻塞时，不会影响到其他线程的执行。该模型具有更好的并发性。缺点是内核线程数量一般有上线，会限制用户线程的数量，更多的内核线程数目也给线程切换带来额外的负担。Linux和Windows操作系统都是使用一对一模型。</span><br><span class="line">- 多对多模型：将多个用户级线程映射到多个内核级线程上，结合了多对一模型和一对一模型的特点。</span><br><span class="line"></span><br><span class="line">## 进程同步和线程同步的区别</span><br><span class="line"></span><br><span class="line">​进程之间地址空间不同，不能感知对方的存在，同步时需要将锁放在多进程共享的空间。而线程之间共享同一地址空间，同步时把锁放在所属的同一进程空间即可。</span><br><span class="line"></span><br><span class="line">----</span><br><span class="line"></span><br><span class="line"># 信号</span><br><span class="line"></span><br><span class="line">## 什么是信号</span><br><span class="line"></span><br><span class="line">​一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件。Linux系统上支持的30多种不同类型的信号。每种 信号类型都对应于某种系统事件。底层的硬件异常是由内核异常处理程序处理的，正常情况下，对用户进程而言不可见。信号提供一种机制，通知用户进程发生了这些异常。信号也叫软件产生的中断，有可能会有延迟。</span><br><span class="line"></span><br><span class="line">1. 发送信号：内核通过更新目的进程上下文中的某个状态，发送一个信号到目的进程。发送信号的原因：</span><br><span class="line">   - 内核检测到一个系统事件，比如零错误或者子进程终止。</span><br><span class="line">   - 一个进程调用了kill函数，显式要求内核发送一个信号给目的进程。一个进程可以发送信号给他自己。</span><br><span class="line">2. 接收信号：当目的进程被内核强迫以某种方式对信号的发送作出反应时，它就接收了信号。进程可以忽略、终止或者通过执行一个称为信号处理程序（signal handler）的用户层函数捕获这个信号。</span><br><span class="line"></span><br><span class="line">**特点：**简单，不能带大量信息，满足特定条件发生。</span><br><span class="line"></span><br><span class="line">**信号的机制：**进程B发送给进程A，内核产生信号，内核处理。</span><br><span class="line"></span><br><span class="line">**信号产生：**</span><br><span class="line"></span><br><span class="line">- 按键产生 crtl+c crtl+z  crtl+\。</span><br><span class="line">- 调用函数  kill  raise   abort。</span><br><span class="line">- 定时器  alarm， setitimer。</span><br><span class="line">- 命令产生  kill。</span><br><span class="line">- 硬件异常  段错误，浮点型错误，总线错误，SIGPIPE。</span><br><span class="line"></span><br><span class="line">**信号状态：**</span><br><span class="line"></span><br><span class="line">- 产生。</span><br><span class="line">- 递答  信号到达并且处理完。</span><br><span class="line">- 未决  信号被阻塞。</span><br><span class="line"></span><br><span class="line">**信号默认处理方式：**</span><br><span class="line"></span><br><span class="line">- 忽略。</span><br><span class="line">- 执行默认动作。</span><br><span class="line">- 捕获。</span><br><span class="line"></span><br><span class="line">**信号四要素：**</span><br><span class="line"></span><br><span class="line">- 编号</span><br><span class="line">- 事件</span><br><span class="line">- 名称</span><br><span class="line">- 默认处理动作：忽略、终止、终止+core、暂停、继续。</span><br><span class="line"></span><br><span class="line">**信号集：**</span><br><span class="line"></span><br><span class="line">![信号集](https://s3.bmp.ovh/imgs/2022/03/311eea32a3ddcab1.png)</span><br><span class="line"></span><br><span class="line">**信号捕捉特性：**</span><br><span class="line"></span><br><span class="line">- 进程正常运行时，默认PCB中有一个信号屏蔽字，假定为⭐，它决定了进程自动屏蔽那些信号。当注册了某个信号捕捉函数 ，捕捉到该信号后，要调用该函数，该函数有可能执行很长时间，在这期间所屏蔽的信号不由⭐指定，而是用sa_mask指定。调用完信号处理函数在恢复为⭐。</span><br><span class="line">- \*\*\*信号捕捉函数执行期间，\*\*\*信号自动被屏蔽。</span><br><span class="line">- 阻塞的常规信号不支持排队，产生多次只记录一次。（后32个实时信号支持排队）</span><br><span class="line"></span><br><span class="line">**内核实现信号捕捉过程：**</span><br><span class="line"></span><br><span class="line">![1](https://img2018.cnblogs.com/blog/1241434/201908/1241434-20190811095430459-2130640271.png)</span><br><span class="line"></span><br><span class="line">## 信号API</span><br><span class="line"></span><br><span class="line">### 系统API产生信号</span><br><span class="line"></span><br><span class="line">**kill:**</span><br><span class="line"></span><br><span class="line">- `int kill(pid_t pid, int sig);`</span><br><span class="line">- pid:</span><br><span class="line">  - \&gt;0，要发送进程ID。</span><br><span class="line">  - =0，代表当前调用进程组内所有进程。</span><br><span class="line">  - =-1，代表有权限发送的所有进程。</span><br><span class="line">  - &lt;0，代表-pid对应的组内所有进程。</span><br><span class="line">- sig：对应的信号。</span><br><span class="line"></span><br><span class="line">**raise和abort:**</span><br><span class="line"></span><br><span class="line">- `int raise(int sig);`</span><br><span class="line">- sig：对应的信号。给自己发。</span><br><span class="line">- `void abort(void);`</span><br><span class="line">- 直接给自己发个异常信号。</span><br><span class="line"></span><br><span class="line">### 时钟信号</span><br><span class="line"></span><br><span class="line">**alarm：**</span><br><span class="line"></span><br><span class="line">- `unsigned int alarm(unsigned int seconds);`</span><br><span class="line">- 定时给自己发SIGALRM信号，也会使进程终止。</span><br><span class="line">- 返回值：上次闹钟剩余的秒数。</span><br><span class="line">- 如果传入参数为0，代表取消闹钟。</span><br><span class="line"></span><br><span class="line">**setitimer：**</span><br><span class="line"></span><br><span class="line">- ` int getitimer(int which, struct itimerval *curr_value);`</span><br><span class="line"></span><br><span class="line">- `int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value);`</span><br><span class="line"></span><br><span class="line">  - ```c++</span><br><span class="line">    struct itimerval &#123;</span><br><span class="line">        struct timeval it_interval; /* Interval for periodic timer 周期性时间设置*/</span><br><span class="line">        struct timeval it_value;    /* Time until next expiration 第一次闹钟时间*/</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    struct timeval &#123;</span><br><span class="line">        time_t      tv_sec;         /* seconds 秒*/</span><br><span class="line">        suseconds_t tv_usec;        /* microseconds 微秒*/</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></li><li><p>which</p><ul><li>ITIMER_REAL  自然定时法，发送SIGALRM信号，</li><li>ITIMER_VIRTUAL 计算进程执行时间，发送SIGVTALRM信号。</li><li>ITIMER_PROF  进程执行时间+调度时间，发送SIGPROF信号。</li></ul></li><li><p>new_value 要设置的闹钟时间。</p></li><li><p>old_value  传出原闹钟时间。</p></li></ul></li></ul><h3 id="信号集处理函数"><a href="#信号集处理函数" class="headerlink" title="信号集处理函数"></a>信号集处理函数</h3><ul><li><p>```c++<br>// 清空信号集<br>int sigemptyset(sigset_t *set);</p><p>// 填充信号集<br>int sigfillset(sigset_t *set);</p><p>// 添加某个信号到信号集<br>int sigaddset(sigset_t *set, int signum);</p><p>// 从集合中删除某个信号<br>int sigdelset(sigset_t *set, int signum);</p><p>// 是否为集合中的成员，是return 1 否return 0<br>int sigismember(const sigset_t *set, int signum);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**sigprocmask：**</span><br><span class="line"></span><br><span class="line">- `int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);`设置阻塞或者解除阻塞信号集。</span><br><span class="line">- how</span><br><span class="line">  - SIG_BLOCK  设置阻塞。</span><br><span class="line">  - SIG_UNBLOCK  解除阻塞。</span><br><span class="line">  - SIG_SETMASK  设置set为新的阻塞信号集。</span><br><span class="line">- set        传入的信号集。</span><br><span class="line">- oldset  传出旧的信号集。</span><br><span class="line"></span><br><span class="line">**sigpending:**</span><br><span class="line"></span><br><span class="line">- `int sigpending(sigset_t *set);`获取当前的未决信号集。</span><br><span class="line">- set 传出参数，当前的未决信号集。</span><br><span class="line"></span><br><span class="line">### 信号捕捉</span><br><span class="line"></span><br><span class="line">**signal：**</span><br><span class="line"></span><br><span class="line">- ```c++</span><br><span class="line">  typedef void (*sighandler_t)(int); </span><br><span class="line">  </span><br><span class="line">  sighandler_t signal(int signum, sighandler_t handler); // 定义一个handler函数来进行捕捉到信号后执行什么操作，signum为信号。</span><br></pre></td></tr></table></figure></li><li><p>捕捉信号并进行相关处理。</p></li></ul><p><strong>sigaction：</strong></p><ul><li><p><code>int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);</code>注册捕捉函数 。</p></li><li><p>signum 捕捉的信号。</p></li><li><p>act 传入的动作</p><ul><li><pre><code class="c++">struct sigaction &#123;    void     (*sa_handler)(int);      // 函数指针，捕捉后的动作    void     (*sa_sigaction)(int, siginfo_t *, void *);    sigset_t   sa_mask;                // 执行捕捉函数期间，临时屏蔽的信号集    int        sa_flags;            // 一般填0使用第一个函数指针，填SA_SIGINFO用第二个    void     (*sa_restorer)(void);  // 无效&#125;;</code></pre></li></ul></li><li><p>oldact 原动作，传出参数，恢复现场。</p></li></ul><h2 id="如何编写正确且安全的信号处理函数"><a href="#如何编写正确且安全的信号处理函数" class="headerlink" title="如何编写正确且安全的信号处理函数"></a>如何编写正确且安全的信号处理函数</h2><ol><li><p>处理程序要尽可能简单。 避免麻烦的最好方法是保持处理程序尽可能小和简单。例如，处理程序可 能只是简单地设置全局标志并立即返回；所有与接收信号相关的处理都由主程序执行，它周期性地 检查(并重置)这个标志。 </p></li><li><p>在处理程序中只调用异步信号安全的函数。 所谓异步信号安全的函数(或简称安全的函数)能够被信 号处理程序安全地调用，原因有二：要么它是可重入的(例如只访问局部变量），要么它不能被信号 处理程序中断。 </p></li><li><p>保存和恢复errno。 许多Linux 异步信号安全的函数都会在出错返回时设置errno在处理程序中调用 这样的函数可能会干扰主程序中其他依赖于分。解决方法是在进人处理程序时把errno 保存在一个 局部变量中，在处理程序返回前恢复它。注意，只有在处理程序要返回时才有此必要。如果处理程 序调用_exit终止该进程，那么就不需要这样做了。 </p></li><li><p>阻塞所有的信号，保护对共享全局数据结构的访问。 如果处理程序和主程序或其他处理程序共享一 个全局数据结构，那么在访问(读或者写)该数据结构时，你的处理程序和主程序应该暂时阻塞所有 的信号。这条规则的原因是从主程序访问一个数据结构d 通常需要一系列的指令，如果指令序列被 访问d 的处理程序中断，那么处理程序可能会发现d 的状态不一致，得到不可预知的结果。在访问d 时暂时阻塞信号保证了处理程序不会中断该指令序列。</p></li><li><p>用volatile 声明全局变量。 考虑一个处理程序和一个main 函数，它们共享一个全局变量g 。处理程 序更新g，main 周期性地读g， 对于一个优化编译器而言，main 中g的值看上去从来没有变化过， 因此使用缓存在寄存器中g 的副本来满足对g 的每次引用是很安全的。如果这样，main 函数可能永 远都无法看到处理程序更新过的值。可以用volatile 类型限定符来定义一个变量，告诉编译器不要 缓存这个变量。例如：volatile 限定符强迫编译器毎次在代码中引用g时，都要从内存中读取g的 值。一般来说，和其他所有共享数据结构一样，应该暂时阻塞信号，保护每次对全局变量的访问。 volatile int g; </p></li><li><p>用sig_atomic_t声明标志。在常见的处理程序设计中，处理程序会写全局标志来记录收到了信号。 主程序周期性地读这个标志，响应信号，再清除该标志。对于通过这种方式来共享的标志，C 提供 一种整型数据类型sig_atomic_t对它的读和写保证会是原子的（不可中断的）。 </p></li><li><p>信号的一个与直觉不符的方面是未处理的信号是不排队的。因为 pending 位向量中每种类型的信号 只对应有一位，所以每种类型最多只能有一个未处理的信号。关键思想是如果存在一个未处理的信 号就表明至少有一个信号到达了。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; title=&quot;进程&quot;&gt;&lt;/a&gt;进程&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;​  </summary>
      
    
    
    
    <category term="OS" scheme="http://isgoudan.top/categories/OS/"/>
    
    
    <category term="面经" scheme="http://isgoudan.top/tags/%E9%9D%A2%E7%BB%8F/"/>
    
    <category term="OS" scheme="http://isgoudan.top/tags/OS/"/>
    
    <category term="进程" scheme="http://isgoudan.top/tags/%E8%BF%9B%E7%A8%8B/"/>
    
    <category term="线程" scheme="http://isgoudan.top/tags/%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="信号" scheme="http://isgoudan.top/tags/%E4%BF%A1%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>内存泄露</title>
    <link href="http://isgoudan.top/2022/02/22/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <id>http://isgoudan.top/2022/02/22/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</id>
    <published>2022-02-22T12:06:36.573Z</published>
    <updated>2022-02-23T07:34:48.943Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h1><p>​        内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是<a href="http://baike.baidu.com/view/330120.htm">应用程序</a>分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。</p><h1 id="内存是如何泄露的？"><a href="#内存是如何泄露的？" class="headerlink" title="内存是如何泄露的？"></a>内存是如何泄露的？</h1><ul><li>堆区数据未被释放。</li></ul><h1 id="C-中的内存泄露该如何避免？"><a href="#C-中的内存泄露该如何避免？" class="headerlink" title="C++ 中的内存泄露该如何避免？"></a>C++ 中的内存泄露该如何避免？</h1><ul><li>避免在堆区开辟数据。</li><li>使用智能指针，而不是手动管理内存。</li><li>使用 std::string 来替代 char*。</li><li>善用 RAII（Resource Acquisition Is Initialization）思想：在类的构造函数中分配资源，在类的析构函数中释放资源。</li></ul><h1 id="如果发生了内存泄露，该如何定位问题代码？"><a href="#如果发生了内存泄露，该如何定位问题代码？" class="headerlink" title="如果发生了内存泄露，该如何定位问题代码？"></a>如果发生了内存泄露，该如何定位问题代码？</h1><ul><li>使用工具软件BoundsChecker，BoundsChecker是一个运行时错误检测工具，它主要定位程序运行时期发生的各种错误。</li><li>调试运行DEBUG版程序，运用以下技术：CRT(C run-time libraries)、运行时函数调用堆栈、内存泄漏时提示的内存分配序号(集成开发环境OUTPUT窗口)，综合分析内存泄漏的原因，排除内存泄漏。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;内存泄漏&quot;&gt;&lt;a href=&quot;#内存泄漏&quot; class=&quot;headerlink&quot; title=&quot;内存泄漏&quot;&gt;&lt;/a&gt;内存泄漏&lt;/h1&gt;&lt;p&gt;​        内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="面经" scheme="http://isgoudan.top/tags/%E9%9D%A2%E7%BB%8F/"/>
    
    <category term="内存" scheme="http://isgoudan.top/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>文件读写</title>
    <link href="http://isgoudan.top/2022/02/22/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/"/>
    <id>http://isgoudan.top/2022/02/22/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/</id>
    <published>2022-02-22T07:00:58.804Z</published>
    <updated>2022-02-22T07:17:31.528Z</updated>
    
    <content type="html"><![CDATA[<h1 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h1><ul><li>头文件<code>#include&lt;fstream&gt;</code></li></ul><h2 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// 以输出方式打开文件</span></span><br><span class="line">    <span class="comment">//  ofstream ofs(&quot;./test.txt&quot;, ios::out | ios::trunc);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 也可以后期指定打开方式</span></span><br><span class="line">    ofstream ofs;</span><br><span class="line">    ofs.<span class="built_in">open</span>(<span class="string">&quot;./test.txt&quot;</span>, ios::out | ios::trunc);</span><br><span class="line">    <span class="keyword">if</span>(!ofs.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;open fail&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ofs&lt;&lt;<span class="string">&quot;goudan&quot;</span>&lt;&lt;endl;</span><br><span class="line">    ofs&lt;&lt;<span class="string">&quot;11&quot;</span>&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// 以输出方式打开文件</span></span><br><span class="line">    <span class="comment">//  ifstream ifs(&quot;./test.txt&quot;, ios::in);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 也可以后期指定打开方式</span></span><br><span class="line">    ifstream ifs;</span><br><span class="line">    ifs.<span class="built_in">open</span>(<span class="string">&quot;./test.txt&quot;</span>, ios::out | ios::trunc);</span><br><span class="line">    <span class="keyword">if</span>(!ifs.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;open fail&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第一种方式</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span>(ifs&gt;&gt;buf) &#123; <span class="comment">// 按行读取</span></span><br><span class="line">cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第二种方式</span></span><br><span class="line">    <span class="keyword">char</span> buf2[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span>(ifs.<span class="built_in">eof</span>()) &#123;<span class="comment">// eof读到文件尾</span></span><br><span class="line">ifs.<span class="built_in">getline</span>(buf2, <span class="built_in"><span class="keyword">sizeof</span></span>(buf2));</span><br><span class="line">        cout &lt;&lt; buf2 &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第三种方式，不推荐，按单个字符读取</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">while</span>(c = ifs.<span class="built_in">get</span>() != EOF) &#123; <span class="comment">// EOF文件尾</span></span><br><span class="line">        cout &lt;&lt; c;</span><br><span class="line">    &#125;</span><br><span class="line">    ifs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;读写文件&quot;&gt;&lt;a href=&quot;#读写文件&quot; class=&quot;headerlink&quot; title=&quot;读写文件&quot;&gt;&lt;/a&gt;读写文件&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;头文件&lt;code&gt;#include&amp;lt;fstream&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 i</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="文件操作" scheme="http://isgoudan.top/tags/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>输入输出流</title>
    <link href="http://isgoudan.top/2022/02/22/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/"/>
    <id>http://isgoudan.top/2022/02/22/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/</id>
    <published>2022-02-22T06:44:12.954Z</published>
    <updated>2022-03-11T08:11:39.314Z</updated>
    
    <content type="html"><![CDATA[<h1 id="标准输入流"><a href="#标准输入流" class="headerlink" title="标准输入流"></a>标准输入流</h1><ul><li><code>cin.get(一个参数)</code>缓冲区中读取一个字符。</li><li><code> cin.get(两个参数)</code>读取字符串，不读换行符。</li><li><code>cin.getline()</code>读取字符串，读取换行符并扔掉。</li><li><code>cin.ignore(N)</code>忽略N个字符。</li><li><code>cin.peek()</code>偷窥，偷看一个字符然后放回缓冲区 。</li><li><code>cin.putback(c)</code>把字符c放回缓冲区。</li><li><code>cin.fail()</code>看标志位，0正常，1不正常。</li><li><code>cin.clear()</code>重置标志位。</li><li><code>cib.sync()</code>清空缓冲区。</li></ul><h1 id="标准输出流"><a href="#标准输出流" class="headerlink" title="标准输出流"></a>标准输出流</h1><ul><li><code>cout.flush</code>刷新缓冲区，Linux有效。</li><li><code>cout.put()</code> 向缓冲区写字符。</li><li><code>cout.write()</code>从缓冲区写num个字节到当前输出流中。</li></ul><p><img src="https://s2.loli.net/2022/02/22/H1IZo4N5h6X7Dji.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;标准输入流&quot;&gt;&lt;a href=&quot;#标准输入流&quot; class=&quot;headerlink&quot; title=&quot;标准输入流&quot;&gt;&lt;/a&gt;标准输入流&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cin.get(一个参数)&lt;/code&gt;缓冲区中读取一个字符。&lt;/li&gt;
&lt;li&gt;&lt;code</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="IO" scheme="http://isgoudan.top/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>C++异常</title>
    <link href="http://isgoudan.top/2022/02/21/C++%E5%BC%82%E5%B8%B8/"/>
    <id>http://isgoudan.top/2022/02/21/C++%E5%BC%82%E5%B8%B8/</id>
    <published>2022-02-21T06:33:07.439Z</published>
    <updated>2022-02-22T06:44:11.033Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><ul><li>基本思想：将问题检测和问题处理相分离。</li><li>try试图执行try{}中的内容。</li><li>在可能出现异常的地方抛出异常 eg： throw -1； </li><li>try下面catch捕获异常。</li><li>catch(捕获类型)   …代表所有其他类型。</li><li>如果不能处理异常，继续向上抛出  thow；</li><li>如果没有任何处理异常的地方，那么程序调用terminate函数终止程序 。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myDevide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="number">-1</span>;  <span class="comment">// 抛出int异常</span></span><br><span class="line">        <span class="comment">// throw 3.14;  抛出double异常</span></span><br><span class="line">        <span class="comment">// throw &quot;a&quot;;</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="built_in">myDevide</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">int</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;int error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">double</span>) &#123;</span><br><span class="line">        <span class="comment">// throw;  如果加上这个，则异常向上反馈，最后只输出 main double error</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;double error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(...) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;other error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">test01</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">double</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;main double error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h1><h2 id="自己写类"><a href="#自己写类" class="headerlink" title="自己写类"></a>自己写类</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;自定义 error&quot;</span> &lt;&lt; endl; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myDevide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">MyException</span>();  <span class="comment">// 匿名对象    </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="built_in">myDevide</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(MyException e) &#123;</span><br><span class="line">e.<span class="built_in">prinError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承系统中自带的"><a href="#继承系统中自带的" class="headerlink" title="继承系统中自带的"></a>继承系统中自带的</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyOutOfRangeException</span> :</span> <span class="keyword">public</span> exception &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyOutOfRangeException</span>(string errorInfo) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_ErrorInfo = errorInfo;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">MyOutOfRangeException</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> cont <span class="keyword">char</span>* <span class="title">what</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_ErrorInfo.<span class="built_in">c_str</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    string m_ErrorInfo;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h1 id="栈解旋"><a href="#栈解旋" class="headerlink" title="栈解旋"></a>栈解旋</h1><ul><li>从try开始到throw抛出异常前，所有栈上的对象都会被释放，这个过程称为栈解旋。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;自定义 error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myDevide</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 栈解旋</span></span><br><span class="line">        <span class="comment">// 从try开始到throw抛出异常前，所有栈上的对象都会被释放，这个过程称为栈解旋。</span></span><br><span class="line">        Person p1;</span><br><span class="line">        Person p2;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">MyException</span>();  <span class="comment">// 匿名对象    </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="built_in">myDevide</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(MyException e) &#123;</span><br><span class="line">e.<span class="built_in">prinError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">p1构造</span></span><br><span class="line"><span class="comment">p2构造</span></span><br><span class="line"><span class="comment">p2析构</span></span><br><span class="line"><span class="comment">p1析构</span></span><br><span class="line"><span class="comment">自定义 error</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="异常接口声明"><a href="#异常接口声明" class="headerlink" title="异常接口声明"></a>异常接口声明</h1><ul><li>抛出特定类型异常。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该代码不能在VS里运行，可以在QT和linux运行。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="title">throw</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span>)</span>  </span>&#123;<span class="comment">// throw(int)只能抛出int类型异常 throw()不抛出任何类型异常</span></span><br><span class="line"><span class="keyword">throw</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">func</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(<span class="keyword">int</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;int error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="异常变量的生命周期"><a href="#异常变量的生命周期" class="headerlink" title="异常变量的生命周期"></a>异常变量的生命周期</h1><ul><li>如果<code>catch(MyException e)</code> 会多开销一份数据，调用拷贝构造。</li><li>如果<code>catch(MyException *e)</code>，如果不new会提前释放对象，new需要自己释放delete。</li><li>推荐<code>catch(MyException &amp;e)</code>，只一份数据。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyException</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;MyException moren gouzao&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">MyException</span>(<span class="keyword">const</span> MyException &amp;e) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;MyException kaobei gouzao&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;自定义 error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">MyException</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;MyException xigou&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">MyException</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">doWork</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(MyException &amp;e) &#123; <span class="comment">// MyException e会多开销一份数据</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;catch error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">输出catch(MyException e)情况：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">MyException moren gouzao</span></span><br><span class="line"><span class="comment">MyException kaobei gouzao</span></span><br><span class="line"><span class="comment">catch error</span></span><br><span class="line"><span class="comment">MyException xigou</span></span><br><span class="line"><span class="comment">MyException xigou</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注：编译器会做优化，不会立刻将匿名对象释放掉，所以可以改为 catch(MyException &amp;e)减少开销。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="异常的多态使用"><a href="#异常的多态使用" class="headerlink" title="异常的多态使用"></a>异常的多态使用</h1><ul><li>利用多态实现<code>printError()</code>同一个接口调用。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseException</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">printError</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NullPointException</span> :</span> <span class="keyword">public</span> BaseException  &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt;  <span class="string">&quot;Null Point Error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">NullPointException</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">doWork</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(BaseException &amp;e) &#123;</span><br><span class="line">        e.<span class="built_in">printError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="系统标准异常使用"><a href="#系统标准异常使用" class="headerlink" title="系统标准异常使用"></a>系统标准异常使用</h1><ul><li>头文件<code>#include&lt;stdexcept&gt;</code>。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">if</span>(age &lt; <span class="number">0</span> || age &gt; <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;年龄越界！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span>  </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="number">1000</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(out_of_range &amp;e) &#123;</span><br><span class="line">        cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;  <span class="comment">// 年龄越界！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本思想&quot;&gt;&lt;a href=&quot;#基本思想&quot; class=&quot;headerlink&quot; title=&quot;基本思想&quot;&gt;&lt;/a&gt;基本思想&lt;/h1&gt;&lt;h1 id=&quot;异常&quot;&gt;&lt;a href=&quot;#异常&quot; class=&quot;headerlink&quot; title=&quot;异常&quot;&gt;&lt;/a&gt;异常&lt;/h</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="异常" scheme="http://isgoudan.top/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>C++类型转换</title>
    <link href="http://isgoudan.top/2022/02/20/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>http://isgoudan.top/2022/02/20/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</id>
    <published>2022-02-20T06:18:06.186Z</published>
    <updated>2022-02-21T06:33:04.791Z</updated>
    
    <content type="html"><![CDATA[<h1 id="静态类型转换（static-cast）"><a href="#静态类型转换（static-cast）" class="headerlink" title="静态类型转换（static_cast）"></a>静态类型转换（static_cast）</h1><ul><li><p>写法<code>static_cast&lt;目标类型&gt;(原始对象)</code>。</p></li><li><p>可以进行基础类型转换。</p></li><li><p>父与子的class可以转换。</p></li><li><p>没有父子关系的class不可以转换。</p></li></ul><h1 id="动态类型转换（dynamic-cast）"><a href="#动态类型转换（dynamic-cast）" class="headerlink" title="动态类型转换（dynamic_cast）"></a>动态类型转换（dynamic_cast）</h1><ul><li><p>写法<code>dynamic_cast&lt;目标类型&gt;(原始对象)</code>。</p></li><li><p>不可以转换基础数据类型。</p></li><li><p>父子间可以转换。</p><ul><li>一般父转子，不可以。</li><li>子转父，可以。</li><li>如果发生多态，都可以。</li></ul></li></ul><h1 id="常量转换（const-cast）"><a href="#常量转换（const-cast）" class="headerlink" title="常量转换（const_cast）"></a>常量转换（const_cast）</h1><ul><li><p>写法<code>const_cast&lt;目标类型&gt;(原始对象)</code>。</p></li><li><p>用来修改类型的const属性。</p><ul><li>常量指针和非常量指针相互转换，并且仍然指向原来对象。</li><li>常量引用和非常量引用相互转换，并且仍然指向原来对象。</li></ul></li></ul><p>​    <font color=red><strong>注意：不能对非指针和非引用的变量使用const_cast操作符去移除他的const。</strong></font></p><h1 id="重新解释转换（reinterpret-cast）"><a href="#重新解释转换（reinterpret-cast）" class="headerlink" title="重新解释转换（reinterpret_cast）"></a>重新解释转换（reinterpret_cast）</h1><ul><li><p>写法<code>reinterpret_cast&lt;目标类型&gt;(原始对象)</code>。</p></li><li><p>什么都可以转，最不安全，不推荐。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;静态类型转换（static-cast）&quot;&gt;&lt;a href=&quot;#静态类型转换（static-cast）&quot; class=&quot;headerlink&quot; title=&quot;静态类型转换（static_cast）&quot;&gt;&lt;/a&gt;静态类型转换（static_cast）&lt;/h1&gt;&lt;ul&gt;
</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="类型转换" scheme="http://isgoudan.top/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>C++模板</title>
    <link href="http://isgoudan.top/2022/02/18/C++%E6%A8%A1%E6%9D%BF/"/>
    <id>http://isgoudan.top/2022/02/18/C++%E6%A8%A1%E6%9D%BF/</id>
    <published>2022-02-18T06:45:18.207Z</published>
    <updated>2022-02-27T08:24:59.278Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h1><p>​        函数模板实际上是建立一个通用函数，其函数类型和形参类型不具体制定用一个虚拟的类型来代表，这个通用函数就是函数模板。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型参数化，泛型编程</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span>  <span class="comment">// 告诉编译器，T是一个通用类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap</span><span class="params">(T &amp;a, T &amp;b)</span> </span>&#123;</span><br><span class="line">    T tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// typename和class二者没啥区别,等价</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 自动类型推导</span></span><br><span class="line">    <span class="built_in">mySwap</span>(a, b);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 显式指定类型</span></span><br><span class="line">    mySwap&lt;<span class="keyword">int</span>&gt;(a, b);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 模板必须指定出T才可以使用。</span></span><br><span class="line">    <span class="built_in">func</span>();  <span class="comment">// 报错</span></span><br><span class="line">    func&lt;<span class="keyword">int</span>&gt;(); <span class="comment">// 正常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数模板和普通函数区别以及调用规则"><a href="#函数模板和普通函数区别以及调用规则" class="headerlink" title="函数模板和普通函数区别以及调用规则"></a>函数模板和普通函数区别以及调用规则</h1><p><strong>区别:</strong></p><ul><li>函数模板不能进行隐式类型转换，普通函数可以。</li></ul><p><strong>调用规则：</strong></p><ul><li>c++编译器优先考虑普通函数。</li><li>可以通过空模板实参列表的语法限定编译器只能通过模板匹配。</li><li>函数模板可以向普通函数一样被重载。</li><li>如果函数模板可以产生一个更好的匹配，优先使用函数模板。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt; </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPlus</span><span class="params">(T &amp;a, T &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPlus01</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">myPlus</span>(a, c); <span class="comment">// 报错，不能执行</span></span><br><span class="line">    <span class="built_in">myPlus2</span>(a, c); <span class="comment">// 可以执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数和函数模板的调用规则</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt; </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(T &amp;a, T &amp;b)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;函数模板print&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt; </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(T &amp;a, T &amp;b, T &amp;c)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;重载函数模板print&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;普通函数print&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果出现重载，优先使用普通函数调用，如果普通函数只声明没有实现，会出现错误</span></span><br><span class="line"><span class="built_in">myPrint</span>(a, b); <span class="comment">// 普通函数print</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果想强制使用模板，可以使用空参数列表</span></span><br><span class="line">    myPrint&lt;&gt;(a, b);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 函数模板可以发生重载</span></span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">30</span>;</span><br><span class="line">    <span class="built_in">myPrint</span>(a, b, c);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果函数模板可以产生更好的匹配，优先使用函数模板</span></span><br><span class="line">    <span class="keyword">char</span> d = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">    <span class="keyword">char</span> e = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line"><span class="built_in">myPrint</span>(d, e); <span class="comment">// 调用函数模板</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="模板机制"><a href="#模板机制" class="headerlink" title="模板机制"></a>模板机制</h1><ul><li>模板不是万能的，不能适用所有的数据类型。</li><li>函数模板通过具体类型产生不同的函数。</li><li>编译器对函数模板进行<strong>两次</strong>编译，在声明地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译（替换后代码称为模板函数）。</li></ul><h1 id="模板局限性及解决"><a href="#模板局限性及解决" class="headerlink" title="模板局限性及解决"></a>模板局限性及解决</h1><ul><li>模板不能解决所有的类型。</li><li>如果出现不能解决的类型，可以通过第三代具体化进行解决。</li><li>语法<code>template &lt;&gt; 返回值 函数名&lt;具体类型&gt;(参数)&#123;&#125;</code>       返回值和函数名必须和模板一致。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name, <span class="keyword">int</span> age) : <span class="built_in">mName</span>(name), <span class="built_in">mAge</span>(age)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    string mName;</span><br><span class="line">    <span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCompare</span><span class="params">(T &amp;a, T &amp;b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a == b) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过第三代具体化自定义数据类型解决问题</span></span><br><span class="line"><span class="comment">// 如果具体化能够优先匹配，那么选择具体化</span></span><br><span class="line"><span class="comment">// 语法template &lt;&gt; 返回值 函数名&lt;具体类型&gt;(参数)      返回值和函数名必须和模板一致</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">bool</span> myCompare&lt;Person&gt;(Person &amp;a, Person &amp;b) &#123;</span><br><span class="line"><span class="keyword">if</span>(a.mAge == b.mAge) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;jerry&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="built_in">myCompare</span>(p1, p2);  <span class="comment">// 如果没具体化自定义实现会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h1><ul><li>写法：<code>template&lt;class T, ...&gt;</code> 紧跟着类。</li><li>相比于函数模板，类模板可以有默认类型参数。</li><li>函数模板可以进行自动类型推导，类模板不可以。</li><li>成员函数一开始不会创建，在运行时才会创建。</li></ul><p><strong>类模板做函数的参数的三种方式：</strong></p><ul><li>显式指定类型</li><li>xxxxxxxxxx #include<stdexcept>​class Person {public:    Person(int age) {        if(age &lt; 0 || age &gt; 200) {            throw out_of_range(“年龄越界！”);        }    }        int m_Age;};​void test01()  {    try {        Person p(1000);    }    catch(out_of_range &amp;e) {        cout &lt;&lt; e.what() &lt;&lt; endl;  // 年龄越界！    }}c++</li><li>整体模板化</li></ul><p><strong>查看类型名称的方式：</strong><code>typeid(T1).name</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">NameType</span>, <span class="keyword">class</span> <span class="title">AgeType</span> =</span> <span class="keyword">int</span>&gt;  <span class="comment">// 类模板可以有默认类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(NameType name, Agetype age) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;age:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    NameType m_Name;</span><br><span class="line">    AgeType m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 类模板不支持自动类型推导</span></span><br><span class="line">    <span class="comment">// Person p(&quot;goudan&quot;, 100);   会出错</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">Person&lt;string, <span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;goudan&quot;</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传参方式</span></span><br><span class="line"><span class="comment">// 1.指定传入类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork1</span><span class="params">(Person&lt;string, <span class="keyword">int</span>&gt; &amp;p)</span> </span>&#123;</span><br><span class="line">    p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.参数模板化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T1, class T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork2</span><span class="params">(Person&lt;T1, T2&gt; &amp;p)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 如何查看类型</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(T1).name &lt;&lt; endl;</span><br><span class="line">    p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.整体模板化</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork3</span><span class="params">(T &amp;p)</span> </span>&#123;</span><br><span class="line">p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person&lt;string, <span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(<span class="string">&quot;goudan&quot;</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="built_in">doWork1</span>(p);</span><br><span class="line">    <span class="built_in">doWork2</span>(p);</span><br><span class="line">    <span class="built_in">doWork3</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类模板碰到继承的问题"><a href="#类模板碰到继承的问题" class="headerlink" title="类模板碰到继承的问题"></a>类模板碰到继承的问题</h1><ul><li>基类如果是模板类，必须让子类告诉编译器基类中的T是什么类型。否则无法分配内存，编译不通过。</li><li>利用参数列表<code>class Child : public Base&lt;int&gt;</code> </li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// child继承base必须告诉base中T的类型，否则无法分配内存</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Base&lt;<span class="keyword">int</span>&gt; &#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// child2 也是模板类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child2</span> :</span> <span class="keyword">public</span> Base&lt;T2&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T1 m_B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Child2&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt; c2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>类模板类外实现成员函数：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">NameType</span>, <span class="keyword">class</span> <span class="title">AgeType</span>&gt;</span>  <span class="comment">// 类模板可以有默认类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(NameType name, Agetype age); </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    NameType m_Name;</span><br><span class="line">    AgeType m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">NameType</span>, <span class="keyword">class</span> <span class="title">AgeType</span>&gt;</span></span><br><span class="line">Person&lt;NameType, AgeType&gt;::<span class="built_in">Person</span>(NameType name, Agetype age) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">NameType</span>, <span class="keyword">class</span> <span class="title">AgeType</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> Person&lt;NameType, AgeType&gt;::<span class="built_in">showPerson</span>() &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;age:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color=red><strong>注意：类模板不要用分文件编写，如果用正常的分文件编写会出现问题，因为类模板成员函数一开始不会创建，在运行时才会创建，导致包含.h头文件，不会创建函数实现，无法解析外部命令，所以在检查#include“Person.h”不会有问题，但是到链接阶段会链接不到成员函数，可以改成#include“Person.cpp”（但是一般不这么做，一般解决方案为：把实现和声明放在一个文件下，改名为hpp文件，hpp一般为模板）</strong></font></p><h1 id="类模板碰到友元函数"><a href="#类模板碰到友元函数" class="headerlink" title="类模板碰到友元函数"></a>类模板碰到友元函数</h1><p><strong>友元函数类内实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">printPerson</span><span class="params">(Person&lt;T1, T2&gt; &amp;p)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; p.m_Name &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(T1 name, T2 age) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;age:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 m_Name;</span><br><span class="line">    T2 m_Age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>友元函数类外实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 让编译器看到printPErson,否则编译器看不到他的声明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 让编译器看到Person类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span><span class="class"><span class="keyword">class</span> <span class="title">Person</span>;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span><span class="function"><span class="keyword">void</span> <span class="title">printPerson</span><span class="params">(Person&lt;T1, T2&gt; &amp;p)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="comment">// 友元函数类外实现，利用空参数列表&lt;&gt;告诉编译器这是模板函数声明，否则是普通函数声明</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span> printPerson&lt;&gt;(Person&lt;T1, T2&gt; &amp;p);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(T1 name, T2 age) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;age:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T1 m_Name;</span><br><span class="line">    T2 m_Age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T1, class T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPerson</span><span class="params">(Person&lt;T1, T2&gt; &amp;p)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; p.m_Name &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;函数模板&quot;&gt;&lt;a href=&quot;#函数模板&quot; class=&quot;headerlink&quot; title=&quot;函数模板&quot;&gt;&lt;/a&gt;函数模板&lt;/h1&gt;&lt;p&gt;​        函数模板实际上是建立一个通用函数，其函数类型和形参类型不具体制定用一个虚拟的类型来代表，这个通用函数就是函</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="模板" scheme="http://isgoudan.top/tags/%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>C++多态</title>
    <link href="http://isgoudan.top/2022/01/17/C++%E5%A4%9A%E6%80%81/"/>
    <id>http://isgoudan.top/2022/01/17/C++%E5%A4%9A%E6%80%81/</id>
    <published>2022-01-17T07:33:27.666Z</published>
    <updated>2022-02-18T06:35:35.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><ul><li><p>C++支持编译时多态（静态多态）和运行时多态（动态多态）。重载–静态多态。虚函数和继承–动态多态。</p></li><li><p>静态多态和动态多态的区别就是函数地址是早绑定（静态连编，编译阶段绑定好地址）还是晚绑定（动态联编，运行时绑定好地址）。</p></li><li><p>什么叫多态？</p><ul><li>父类的引用或指针指向子类对象。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;   <span class="comment">// 改为 virtual void speak()</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;animal speak&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cat</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;  <span class="comment">// 子类中的 virtual 可写可不写</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;cat speak&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数func里， speak函数的地址早就绑定好了，在编译阶段就确定了地址</span></span><br><span class="line"><span class="comment">// 如果像调用cat的speak，不能提前绑定好函数地址，所以需要在运行的时候再去确定函数地址</span></span><br><span class="line"><span class="comment">// 动态联编写法：把speak（）在父类声明为虚函数，就发生了多态</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Animal &amp;animal)</span> </span>&#123;</span><br><span class="line">    animal.<span class="built_in">speak</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Cat cat;</span><br><span class="line">    <span class="built_in">func</span>(cat);  <span class="comment">// animal speak;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="多态内部原理"><a href="#多态内部原理" class="headerlink" title="多态内部原理"></a>多态内部原理</h1><ul><li>Animal 内部结构<ul><li><p>Animal 内部存在一个vfptr（virtual function pointer）虚函数表指针。</p></li><li><p>虚函数表指针指向虚函数表。</p></li><li><p>当Cat中没有写speak函数时，Cat的vfptr指向Animal speak函数，如下图：</p></li><li><p><img src="https://s2.loli.net/2022/01/18/XW46U1CHu3JRas8.png" alt="image.png"></p></li><li><p>当Cat中重写了speak函数后，Cat的vfptr指向自己的cat speak函数（对象创建的时候，调用构造函数，将所有的虚函数指针都指向自己的虚函数表，这个操作我们看不到），如下图：</p></li><li><p><img src="https://s2.loli.net/2022/01/18/u7mxhFrbGjA6kvI.png" alt="image.png"></p></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(Animal) &lt;&lt; endl;  <span class="comment">// 没加virtual时是1，加了以后是4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>深入剖析内部调用</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Animal * animal = <span class="keyword">new</span> Cat;</span><br><span class="line">    <span class="comment">// (*(int *)*(int *)animal) 为函数地址</span></span><br><span class="line">    ((<span class="built_in"><span class="keyword">void</span></span>(*)()) (*(<span class="keyword">int</span> *)*(<span class="keyword">int</span> *)animal))();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h1><ul><li>如果父类有纯虚函数，子类继承父类，子类必须将其实现，否则子类也是一个抽象类。</li><li>如果父类有纯虚函数，那么父类不能实例化对象。</li><li>如果类有了纯虚函数，通常称为抽象类。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;   <span class="comment">// 虚函数</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;animal speak&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 纯虚函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h1><ul><li>虚析构解决问题：是为了delete基类指针指向派生类时防止子类的数据不会被释放造成内存泄露。</li><li>纯虚析构：<ul><li>纯虚析构，需要声明，还需要实现，类内声明，类外实现。</li><li>如果类中出现纯虚析构，那么这个类也算抽象类。</li><li>抽象类不能实例化对象。</li></ul></li><li>虚析构和纯虚析构区别：纯虚析构的类不能实例化对象。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Animal speak&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 普通析构 不会调用子类的析构，所以可能导致释放不干净</span></span><br><span class="line">    <span class="comment">// 利用虚析构解决该问题</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Animal xigou&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 纯虚析构</span></span><br><span class="line">    <span class="comment">// 纯虚析构，需要声明，还需要实现，类内声明，类外实现</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal::~<span class="built_in">Animal</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Animal chunxu&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cat</span>(<span class="keyword">const</span> <span class="keyword">char</span> * name) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;mName = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(name) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;name, name);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Cat speak&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">Cat</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Cat xigou&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;mName != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;mName;</span><br><span class="line">            <span class="keyword">this</span>-&gt;mName = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span>* mName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Animal * cat = <span class="keyword">new</span> <span class="built_in">Cat</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    animal-&gt;<span class="built_in">speak</span>();   <span class="comment">// Cat speak</span></span><br><span class="line">    <span class="keyword">delete</span> animal;  <span class="comment">// 父类析构函数没加virtual：Animal xigou</span></span><br><span class="line">    <span class="comment">// 父类改成虚析构后： Cat xigou</span></span><br><span class="line">    <span class="comment">//   Animal xigou</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;多态&quot;&gt;&lt;a href=&quot;#多态&quot; class=&quot;headerlink&quot; title=&quot;多态&quot;&gt;&lt;/a&gt;多态&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;C++支持编译时多态（静态多态）和运行时多态（动态多态）。重载–静态多态。虚函数和继承–动态多态。&lt;/p&gt;
&lt;/li&gt;
&lt;</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="多态" scheme="http://isgoudan.top/tags/%E5%A4%9A%E6%80%81/"/>
    
    <category term="抽象类" scheme="http://isgoudan.top/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    
    <category term="纯虚函数" scheme="http://isgoudan.top/tags/%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
    <category term="虚函数" scheme="http://isgoudan.top/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>C++继承</title>
    <link href="http://isgoudan.top/2022/01/15/C++%E7%BB%A7%E6%89%BF/"/>
    <id>http://isgoudan.top/2022/01/15/C++%E7%BB%A7%E6%89%BF/</id>
    <published>2022-01-15T07:10:38.731Z</published>
    <updated>2022-02-18T06:19:42.645Z</updated>
    
    <content type="html"><![CDATA[<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><ul><li>解决代码的复用。</li><li>语法： class 子类 ： 继承方式  父类</li></ul><h1 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h1><ul><li>三种：public、private、protected</li></ul><p><img src="https://s2.loli.net/2022/01/16/x3k79EPCJQdefIL.png" alt="QQ截图20220116151208.png"></p><ul><li>子类会继承父类的所有内容，包括私有属性，只是被编译器隐藏起来，访问不到私有成员。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>()&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(Son) &lt;&lt; endl;   <span class="comment">// 输出16；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="继承中的构造和析构函数"><a href="#继承中的构造和析构函数" class="headerlink" title="继承中的构造和析构函数"></a>继承中的构造和析构函数</h1><ul><li>子类会继承父类的成员属性和成员函数，但是子类不会继承父类的构造函数和析构函数。只有父类自己知道如何构造和析构自己的属性，而子类不知道。另外operator=也不会继承下来。</li><li>子类创建对象时，会先调用父类的构造，然后调用自身的构造。</li><li>析构顺序和构造顺序正好相反。</li><li>当父类的构造函数有参数时，需要在子类初始化列表（参数列表）中显式调用父类的构造函数。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base2</span>(<span class="keyword">int</span> a) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;有参构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son2</span> :</span> <span class="keyword">public</span> Base2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Son2() &#123;&#125;   // 报错，不存在无参构造</span></span><br><span class="line">    <span class="built_in">Son2</span>(<span class="keyword">int</span> a) : <span class="built_in">Base2</span>(a) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="继承中的同名处理"><a href="#继承中的同名处理" class="headerlink" title="继承中的同名处理"></a>继承中的同名处理</h1><ul><li>如果子类和父类拥有同名的属性和函数，子类不会覆盖父类成员，加作用域就可调父类的。</li><li>如果子类与父类的成员函数名称相同，子类会把父类的<strong>所有</strong>同名版本都隐藏掉，想调用必须加作用域。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123;</span><br><span class="line">        m_A = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base func&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Son</span>() &#123;</span><br><span class="line">        m_A = <span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Son func&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Son S1;</span><br><span class="line">    cout &lt;&lt; s1.m_A &lt;&lt; endl;  <span class="comment">// cout 200</span></span><br><span class="line">    cout &lt;&lt; s1.Base::m_A &lt;&lt;endl;  <span class="comment">// cout 100</span></span><br><span class="line"></span><br><span class="line">    s1.<span class="built_in">func</span>();</span><br><span class="line">    s1.Base::<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="继承中静态成员的处理"><a href="#继承中静态成员的处理" class="headerlink" title="继承中静态成员的处理"></a>继承中静态成员的处理</h1><ul><li>静态成员属性，子类可以继承下来。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Base::m_A = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; Son::m_A &lt;&lt;endl;  <span class="comment">// cout 10;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base func&quot;</span> &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base func(int)&quot;</span> &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Base::m_A = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Son func&quot;</span> &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Son::m_A = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; Son::m_A &lt;&lt;endl;  <span class="comment">// cout 20;</span></span><br><span class="line">    cout &lt;&lt; Base::m_A &lt;&lt;endl;  <span class="comment">// cout 10;</span></span><br><span class="line"></span><br><span class="line">    Son::<span class="built_in">func</span>();      <span class="comment">// Son func</span></span><br><span class="line">    Base::<span class="built_in">func</span>();    <span class="comment">// Base func</span></span><br><span class="line">    Son::Base::<span class="built_in">func</span>(<span class="number">10</span>);    <span class="comment">// Base func(int)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h1><ul><li>多继承中很容易引发二义性问题</li><li>语法 ： class Son : public Base1, public Base2 {}</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base1</span>() &#123;</span><br><span class="line">        m_A = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base2</span>() &#123;</span><br><span class="line">        m_A = <span class="number">20</span>;</span><br><span class="line">    &#125;A</span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_C;</span><br><span class="line">    <span class="keyword">int</span> m_D;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(Son) &lt;&lt; endl;     <span class="comment">// 16</span></span><br><span class="line"></span><br><span class="line">    Son s1;</span><br><span class="line">    <span class="comment">// s1.m_A;        // 二义性 error</span></span><br><span class="line">    cout &lt;&lt; s1.Base1::m_A &lt;&lt; endl;  <span class="comment">// 10</span></span><br><span class="line">    cout &lt;&lt; s1.Base2::m_A &lt;&lt; endl;  <span class="comment">// 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="菱形继承和虚继承"><a href="#菱形继承和虚继承" class="headerlink" title="菱形继承和虚继承"></a>菱形继承和虚继承</h1><ul><li>菱形继承存在部分数据重复继承两份的问题，为解决该问题，采用虚继承的方式。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tuo</span> :</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SheepTuo</span> :</span> <span class="keyword">public</span> Sheep, <span class="keyword">public</span> Tuo &#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SheepTuo st;</span><br><span class="line">    st.Sheep::m_Age = <span class="number">10</span>;</span><br><span class="line">    st.Tuo::m_Age = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">// 存在两份数据，造成资源浪费</span></span><br><span class="line">    cout &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;   <span class="comment">// 10</span></span><br><span class="line">    cout &lt;&lt; st.Tuo::m_Age &lt;&lt; endl;     <span class="comment">// 20;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用虚继承解决：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tuo</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SheepTuo</span> :</span> <span class="keyword">public</span> Sheep, <span class="keyword">public</span> Tuo &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 虚继承后操作一份共享数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SheepTou st;</span><br><span class="line">    st.Sheep::m_Age = <span class="number">10</span>;</span><br><span class="line">    st.Tuo::m_Age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;   <span class="comment">// 20</span></span><br><span class="line">    cout &lt;&lt; st.Tuo::m_Age &lt;&lt; endl;     <span class="comment">// 20;</span></span><br><span class="line">    cout &lt;&lt; st.m_Age &lt;&lt; endl;         <span class="comment">// 此时可以直接访问，没有二义性的情况了，只有一份m_Age</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/01/16/TdmLwOuqiYxXVaM.png" alt="QQ截图20220116203008.png"></p><h1 id="向上类型转换和向下类型转换"><a href="#向上类型转换和向下类型转换" class="headerlink" title="向上类型转换和向下类型转换"></a>向上类型转换和向下类型转换</h1><ul><li>基类转派生类。<ul><li>向下类型转换   安全的。</li></ul></li><li>派生类转基类。<ul><li>向上类型转换  不安全。</li></ul></li><li>如果发生了多态。<ul><li>总是安全的。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;解决代码的复用。&lt;/li&gt;
&lt;li&gt;语法： class 子类 ： 继承方式  父类&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;继承方</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="继承" scheme="http://isgoudan.top/tags/%E7%BB%A7%E6%89%BF/"/>
    
    <category term="父类子类转换" scheme="http://isgoudan.top/tags/%E7%88%B6%E7%B1%BB%E5%AD%90%E7%B1%BB%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>四旋翼仿真控制模块</title>
    <link href="http://isgoudan.top/2022/01/15/%E5%9B%9B%E6%97%8B%E7%BF%BC%E4%BB%BF%E7%9C%9F%E5%90%84%E6%A8%A1%E5%9D%97%E6%A2%B3%E7%90%86/"/>
    <id>http://isgoudan.top/2022/01/15/%E5%9B%9B%E6%97%8B%E7%BF%BC%E4%BB%BF%E7%9C%9F%E5%90%84%E6%A8%A1%E5%9D%97%E6%A2%B3%E7%90%86/</id>
    <published>2022-01-14T16:11:29.100Z</published>
    <updated>2022-01-15T02:58:45.788Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PositionControl"><a href="#PositionControl" class="headerlink" title="PositionControl"></a>PositionControl</h1><p>​        以下模块参照PX4源码。</p><h2 id="positionControl"><a href="#positionControl" class="headerlink" title="_positionControl"></a>_positionControl</h2><p>所需数据：_pos_sp 和 _pos 和 _gain_pos_p 和 _lim_vel_horizontal</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> PositionControl::_positionControl() &#123;</span><br><span class="line">    <span class="comment">// P-position controller  对位置进行p比例控制</span></span><br><span class="line">    Vector3f vel_sp_position = (_pos_sp - _pos).<span class="built_in">emult</span>(_gain_pos_p);</span><br><span class="line">    <span class="comment">// Position and feed-forward velocity setpoints or position states being NAN results in them not having an influence位置和前馈速度设定点或位置状态为 NAN 导致它们没有影响</span></span><br><span class="line">    _vel_sp += vel_sp_position;</span><br><span class="line">    <span class="comment">// 确保没有NAN</span></span><br><span class="line">    <span class="comment">// ControlMath::setZeroIfNanVector3f(vel_sp_position); </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过优先考虑沿方向的速度分量来约束水平速度</span></span><br><span class="line">    <span class="comment">// 前馈项上的期望位置设定值。</span></span><br><span class="line">    _vel_sp.<span class="built_in">xy</span>() = ControlMath::<span class="built_in">constrainXY</span>(vel_sp_position.<span class="built_in">xy</span>(), (_vel_sp - vel_sp_position).<span class="built_in">xy</span>(), _lim_vel_horizontal);  <span class="comment">// _lim_vel_horizontal水平速度限制</span></span><br><span class="line">    <span class="comment">// Constrain velocity in z-direction. 可以不考虑z轴</span></span><br><span class="line">    <span class="comment">// _vel_sp(2) = math::constrain(_vel_sp(2), -_lim_vel_up, _lim_vel_down);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="velocityControl"><a href="#velocityControl" class="headerlink" title="_velocityControl"></a>_velocityControl</h2><p>来自_positionControl： _vel_sp </p><p>所需数据： _vel 和 _gain_vel_p 和 _gain_vel_d</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> PositionControl::_velocityControl(<span class="keyword">const</span> <span class="keyword">float</span> dt) &#123;</span><br><span class="line"><span class="comment">// PID velocity control</span></span><br><span class="line">    Vector3f vel_error = _vel_sp - _vel;  <span class="comment">// 速度误差</span></span><br><span class="line">    Vector3f acc_sp_velocity = vel_error.<span class="built_in">emult</span>(_gain_vel_p) + _vel_int - _vel_dot.<span class="built_in">emult</span>(_gain_vel_d);  <span class="comment">// emult是乘 _gain_vel_p </span></span><br><span class="line">    <span class="comment">// 如果acc_sp_velocity不是NAN值，就加到期望加速度里，</span></span><br><span class="line">    _acc_sp += acc_sp_velocity； <span class="comment">// _acc_sp 期望加速度</span></span><br><span class="line"></span><br><span class="line">    _accelerationControl();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 垂直方向积分器抗饱和  感觉没用</span></span><br><span class="line"><span class="comment">//if ((_thr_sp(2) &gt;= -_lim_thr_min &amp;&amp; vel_error(2) &gt;= 0.0f) ||</span></span><br><span class="line"><span class="comment">//    (_thr_sp(2) &lt;= -_lim_thr_max &amp;&amp; vel_error(2) &lt;= 0.0f)) &#123;</span></span><br><span class="line"><span class="comment">//vel_error(2) = 0.f;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在保持水平边距的同时，优先考虑垂直控制</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> Vector2f <span class="title">thrust_sp_xy</span><span class="params">(_thr_sp)</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> thrust_sp_xy_norm = thrust_sp_xy.<span class="built_in">norm</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> thrust_max_squared = math::<span class="built_in">sq</span>(_lim_thr_max);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 确定在保持水平边距的情况下还剩下多少垂直推力  这部分应该不重要</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> allocated_horizontal_thrust = math::<span class="built_in">min</span>(thrust_sp_xy_norm, _lim_thr_xy_margin);  <span class="comment">// 分配的水平推力</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> thrust_z_max_squared = thrust_max_squared - math::<span class="built_in">sq</span>(allocated_horizontal_thrust);    <span class="comment">// 推力 z 最大平方</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 饱和最大垂直推力  感觉没用</span></span><br><span class="line">    _thr_sp(<span class="number">2</span>) = math::<span class="built_in">max</span>(_thr_sp(<span class="number">2</span>), -<span class="built_in">sqrtf</span>(thrust_z_max_squared));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 确定优先垂直控制后还剩多少水平推力</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> thrust_max_xy_squared = thrust_max_squared - math::<span class="built_in">sq</span>(_thr_sp(<span class="number">2</span>));</span><br><span class="line"><span class="keyword">float</span> thrust_max_xy = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (thrust_max_xy_squared &gt; <span class="number">0</span>) &#123;</span><br><span class="line">thrust_max_xy = <span class="built_in">sqrtf</span>(thrust_max_xy_squared);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 水平方向饱和推力</span></span><br><span class="line"><span class="keyword">if</span> (thrust_sp_xy_norm &gt; thrust_max_xy) &#123;</span><br><span class="line">_thr_sp.<span class="built_in">xy</span>() = thrust_sp_xy / thrust_sp_xy_norm * thrust_max_xy;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 水平方向使用跟踪 Anti-Windup：在饱和期间，积分器用于使输出不饱和</span></span><br><span class="line"><span class="comment">// see Anti-Reset Windup for PID controllers, L.Rundqwist, 1990</span></span><br><span class="line">    <span class="comment">// 参见 PID 控制器的防复位饱和，L.Rundqwist，1990</span></span><br><span class="line"><span class="keyword">const</span> Vector2f acc_sp_xy_limited = <span class="built_in">Vector2f</span>(_thr_sp) * (CONSTANTS_ONE_G / _hover_thrust);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> arw_gain = <span class="number">2.f</span> / _gain_vel_p(<span class="number">0</span>);</span><br><span class="line">vel_error.<span class="built_in">xy</span>() = <span class="built_in">Vector2f</span>(vel_error) - (arw_gain * (<span class="built_in">Vector2f</span>(_acc_sp) - acc_sp_xy_limited));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保积分不会得到 NAN</span></span><br><span class="line">ControlMath::<span class="built_in">setZeroIfNanVector3f</span>(vel_error);</span><br><span class="line"><span class="comment">// 更新速度控制的组成部分</span></span><br><span class="line">_vel_int += vel_error.<span class="built_in">emult</span>(_gain_vel_i) * dt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 限制推力积分</span></span><br><span class="line">_vel_int(<span class="number">2</span>) = math::<span class="built_in">min</span>(<span class="built_in">fabsf</span>(_vel_int(<span class="number">2</span>)), CONSTANTS_ONE_G) * <span class="built_in">sign</span>(_vel_int(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="accelerationControl"><a href="#accelerationControl" class="headerlink" title="_accelerationControl"></a>_accelerationControl</h2><p>最终给出期望推力</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> PositionControl::_accelerationControl()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 假设在垂直方向上由于重力产生的标准加速度用于姿态生成</span></span><br><span class="line">Vector3f body_z = <span class="built_in">Vector3f</span>(-_acc_sp(<span class="number">0</span>), -_acc_sp(<span class="number">1</span>), CONSTANTS_ONE_G).<span class="built_in">normalized</span>();</span><br><span class="line">ControlMath::<span class="built_in">limitTilt</span>(body_z, <span class="built_in">Vector3f</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>), _lim_tilt);</span><br><span class="line"><span class="comment">// 假设悬停推力产生标准重力的比例推力</span></span><br><span class="line"><span class="keyword">float</span> collective_thrust = _acc_sp(<span class="number">2</span>) * (_hover_thrust / CONSTANTS_ONE_G) - _hover_thrust;</span><br><span class="line"><span class="comment">// Project thrust to planned body attitude</span></span><br><span class="line">collective_thrust /= (<span class="built_in">Vector3f</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>).<span class="built_in">dot</span>(body_z));</span><br><span class="line">collective_thrust = math::<span class="built_in">min</span>(collective_thrust, -_lim_thr_min);</span><br><span class="line">_thr_sp = body_z * collective_thrust;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;PositionControl&quot;&gt;&lt;a href=&quot;#PositionControl&quot; class=&quot;headerlink&quot; title=&quot;PositionControl&quot;&gt;&lt;/a&gt;PositionControl&lt;/h1&gt;&lt;p&gt;​        以下模块参照PX4</summary>
      
    
    
    
    <category term="UAV Simulation" scheme="http://isgoudan.top/categories/UAV-Simulation/"/>
    
    
    <category term="UAV" scheme="http://isgoudan.top/tags/UAV/"/>
    
  </entry>
  
  <entry>
    <title>智能指针</title>
    <link href="http://isgoudan.top/2022/01/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <id>http://isgoudan.top/2022/01/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</id>
    <published>2022-01-14T11:43:39.996Z</published>
    <updated>2022-01-15T15:41:27.603Z</updated>
    
    <content type="html"><![CDATA[<h1 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h1><p>​        用来托管自定义类型的对象，让对象进行自动释放</p><p> <a href="%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD.md">运算符重载.md</a> 里有相关内容</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;智能指针&quot;&gt;&lt;a href=&quot;#智能指针&quot; class=&quot;headerlink&quot; title=&quot;智能指针&quot;&gt;&lt;/a&gt;智能指针&lt;/h1&gt;&lt;p&gt;​        用来托管自定义类型的对象，让对象进行自动释放&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;%E8%BF%90%E7%</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="智能指针" scheme="http://isgoudan.top/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>运算符重载</title>
    <link href="http://isgoudan.top/2022/01/14/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    <id>http://isgoudan.top/2022/01/14/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</id>
    <published>2022-01-14T08:03:59.128Z</published>
    <updated>2022-01-17T07:40:58.633Z</updated>
    
    <content type="html"><![CDATA[<h1 id="左移运算符重载"><a href="#左移运算符重载" class="headerlink" title="左移运算符重载"></a>左移运算符重载</h1><ul><li>必须写在写在全局函数中，如果重载时想访问类的私有成员，需要将全局函数作类的友元。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;cout, Person &amp;A) &#123;</span><br><span class="line">    cout &lt;&lt; A.mA;</span><br><span class="line">    <span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="加法运算符重载"><a href="#加法运算符重载" class="headerlink" title="加法运算符重载"></a>加法运算符重载</h1><ul><li>可以在成员函数进行重载，也可以在全局函数重载。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person <span class="keyword">operator</span>+(Person &amp;A, Person&amp; B) &#123;  <span class="comment">// 全局方式  ，局部只需要把参数改下，返回this指针就行</span></span><br><span class="line">Person temp;</span><br><span class="line">    temp.mA = A.mA + B.mA;</span><br><span class="line">    temp.mB = A.mB + B.mB;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="前置递增运算符重载"><a href="#前置递增运算符重载" class="headerlink" title="前置递增运算符重载"></a>前置递增运算符重载</h1><ul><li>可以在成员函数进行重载，也可以在全局函数重载。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInteger</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyInteger</span>() &#123;</span><br><span class="line">mNum = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MyInteger&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">        <span class="keyword">this</span>.mNum++;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mNum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyInteger&amp; <span class="keyword">operator</span>++(MyInteger&amp; A) &#123;</span><br><span class="line">    A.mNum++;</span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="后置递增运算符重载"><a href="#后置递增运算符重载" class="headerlink" title="后置递增运算符重载"></a>后置递增运算符重载</h1><ul><li>可以在成员函数进行重载，也可以在全局函数重载。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInteger</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyInteger</span>() &#123;</span><br><span class="line">mNum = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MyInteger <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">        MyInteger tmp = *<span class="keyword">this</span>;</span><br><span class="line">        A.mNum++;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mNum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyInteger <span class="keyword">operator</span>++(MyInteger&amp; A, <span class="keyword">int</span>) &#123;</span><br><span class="line">    MyInteger tmp = A;</span><br><span class="line">    A.mNum++;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="指针运算符重载"><a href="#指针运算符重载" class="headerlink" title="指针运算符重载"></a>指针运算符重载</h1><h2 id="智能指针实现"><a href="#智能指针实现" class="headerlink" title="智能指针实现"></a>智能指针实现</h2><p>用来托管自定义类型的对象，让对象进行自动释放，new出来的对象自动释放。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">int</span> age) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;age：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;xigou&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 智能指针</span></span><br><span class="line"><span class="comment">// 用来托管自定义类型的对象，让对象进行自动释放</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">smartPointer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">smartPointer</span>(Person *person) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;person = person;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重载-&gt;让智能指针对象像Person *p一样使用</span></span><br><span class="line">    Person * <span class="keyword">operator</span>-&gt;() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;person;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  重载*</span></span><br><span class="line">    Person&amp; <span class="keyword">operator</span>*() &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>-&gt;person;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">smartPointer</span>(Person *person) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;person != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>-&gt;person;</span><br><span class="line">            <span class="keyword">this</span>-&gt;person = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Person *person;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">smartPointer <span class="title">sp</span><span class="params">(<span class="keyword">new</span> Person(<span class="number">10</span>))</span></span>;  <span class="comment">//  开辟到栈上，自动释放</span></span><br><span class="line">    sp-&gt;<span class="built_in">showAge</span>();  <span class="comment">// sp-&gt;-&gt;showAge(),  编译器优化了写法</span></span><br><span class="line">    </span><br><span class="line">    (*sp).<span class="built_in">showAge</span>();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h1><ul><li>系统默认提供给类的赋值运算符写法是简单的值拷贝。</li><li>如果有数据在堆区，可能会有深浅拷贝问题。</li><li>如果想链式编程需要返回return *this;</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="keyword">char</span>* name) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;pName = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(name) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;pName, name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;age：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> Person &amp; p) &#123;</span><br><span class="line">        <span class="comment">// 如果原来堆区有内容，先释放掉</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>-&gt;pName != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pName;</span><br><span class="line">            thsi-&gt;pName = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>-&gt;pName = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(p.pName) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;pName, p.pName);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">Person</span>() &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>-&gt;pName != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pName;</span><br><span class="line">            thsi-&gt;pName = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span>* pName;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;goudan&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;gousheng&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;&quot;</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    p3 = p2 = p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="运算符重载"><a href="#运算符重载" class="headerlink" title="[]运算符重载"></a>[]运算符重载</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;myArray[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="和-关系运算符重载"><a href="#和-关系运算符重载" class="headerlink" title="==和!=关系运算符重载"></a>==和!=关系运算符重载</h1><ul><li>类似加号运算符重载</li></ul><h1 id="函数调用运算符重载"><a href="#函数调用运算符重载" class="headerlink" title="函数调用运算符重载"></a>函数调用运算符重载</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrint</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">MyPrint <span class="title">myPrint</span><span class="params">()</span></span>;</span><br><span class="line"><span class="built_in">myPrint</span>(<span class="string">&quot;hello world&quot;</span>);  <span class="comment">// 仿函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="amp-amp-和"><a href="#amp-amp-和" class="headerlink" title="&amp;&amp; 和 ||"></a>&amp;&amp; 和 ||</h1><ul><li>这两个不要重载，因为无法实现它们的短路规则。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;左移运算符重载&quot;&gt;&lt;a href=&quot;#左移运算符重载&quot; class=&quot;headerlink&quot; title=&quot;左移运算符重载&quot;&gt;&lt;/a&gt;左移运算符重载&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;必须写在写在全局函数中，如果重载时想访问类的私有成员，需要将全局函数作类的友元。&lt;/li</summary>
      
    
    
    
    <category term="C++" scheme="http://isgoudan.top/categories/C/"/>
    
    
    <category term="C++" scheme="http://isgoudan.top/tags/C/"/>
    
    <category term="重载" scheme="http://isgoudan.top/tags/%E9%87%8D%E8%BD%BD/"/>
    
  </entry>
  
</feed>
